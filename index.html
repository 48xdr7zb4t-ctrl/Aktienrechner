<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wachstum Rechner (Jahreswerte → CAGR)</title>
  <style>
    body{font-family:Arial, sans-serif;background:#f4f4f4;margin:0;padding:28px}
    .wrap{max-width:980px;margin:0 auto}
    .card{background:#fff;border-radius:14px;padding:18px 18px 8px;margin-bottom:16px;box-shadow:0 2px 10px rgba(0,0,0,.06)}
    h1{margin:0 0 10px;font-size:22px; text-align:center;}
    h2{margin:0 0 10px;font-size:18px}
    .muted{color:#666;font-size:13px;line-height:1.35; text-align:center;}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .grid3{display:grid;grid-template-columns:repeat(5, 1fr);gap:10px}
    label{font-size:13px;color:#333}
    input,select,button{width:100%;padding:10px;border-radius:10px;border:1px solid #d6d6d6;font-size:14px;box-sizing:border-box}
    button{background:#2f7dff;color:#fff;border:none;cursor:pointer;margin-top:10px}
    button:hover{opacity:.92}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .out{background:#fafafa;border:1px dashed #d6d6d6;border-radius:12px;padding:12px;margin-top:12px}
    .kpi{display:flex;justify-content:space-between;gap:10px;margin:8px 0}
    .kpi b{font-size:14px}
    .vol-muted { font-size:12px; color:#888; line-height:1.3; }
    .vol-subtitle { font-size:12px; color:#999; margin-top:4px; }
      
    .err{color:#b00020;font-size:13px;margin-top:8px}
    table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px}
    th,td{border:1px solid #e6e6e6;padding:8px;text-align:left}
    th{background:#f2f2f2}
    .small{font-size:12px;color:#666}
    @media (max-width:900px){
      .grid3{grid-template-columns:repeat(2, 1fr)}
    }
      .kpi.highlight b{
    font-size:16px;   /* etwas größer */
    font-weight:800;  /* fett */
  }
  
  #nutzenTable th { white-space: nowrap; }
#nutzenTable td { vertical-align: top; min-width: 140px; }
#nutzenTable .nutzenCell { white-space: nowrap; }


/* --- Nutzen: Rollen-Details (aufklappbar) --- */
.roleBox { margin-top:12px; }
.roleGrid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
@media (max-width:900px){ .roleGrid{ grid-template-columns:1fr; } }

.roleDetails {
  border:1px solid #e6e6e6;
  border-radius:12px;
  background:#fff;
  padding:10px 12px;
}
.roleDetails summary{
  cursor:pointer;
  font-weight:700;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  list-style:none;
}
.roleDetails summary::-webkit-details-marker{ display:none; }

.roleDetails summary .sumRow{
  
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;

}
.roleDetails summary { position: relative; z-index: 1; }
  /* Klick zählt immer für summary */

.roleBadge{
  font-size:12px;
  padding:3px 8px;
  border-radius:999px;
  background:#f2f2f2;
  white-space:nowrap;
}
.roleBadge.ok{ background:#eaf7ef; color:#1d6b3a; border:1px solid #cfe9d9; }
.roleBadge.bad{ background:#fdecec; color:#8a1f2a; border:1px solid #f6c9cf; }

.roleBadge.mid{ background:#fff3cd; color:#856404; border:1px solid #ffeeba; }


.roleMeta { margin-top:6px; font-size:12px; color:#666; line-height:1.35; }

.roleChecks{
  margin:10px 0 0;
  padding-left:18px;
  font-size:13px;
  line-height:1.45;
}
.roleChecks li{ margin:4px 0; }
.roleChecks .ok{ color:#1d6b3a; }
.roleChecks .bad{ color:#8a1f2a; }
.roleChecks .muted{ color:#777; }

 /* FIX: Nutzen-Buttons wieder klickbar (Overlay/Z-Index) */
#page-nutzen .card { position: relative; }
#nutzen_parseBtn, #nutzen_clearBtn, #nutzen_big, #nutzen_cagrYears {
  position: relative;
  z-index: 50;
}
#nutzenTable, #nutzen_roles, #nutzen_result {
  position: relative;
  z-index: 1;
}
  
#nutzen_bigMirror { display:none !important; }

/* ===============================
   OVERLAY: Rollen / Stress / Range
   =============================== */
.nutzenOverlayBackdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.45);
  display:none;
  z-index:9998;
}
.nutzenOverlay{
  position:fixed; inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9999;
  padding:18px;
}
.nutzenOverlayPanel{
  width:min(920px, 96vw);
  max-height:86vh;
  overflow:auto;
  background:#fff;
  border-radius:16px;
  box-shadow:0 10px 35px rgba(0,0,0,.22);
  border:1px solid #e9e9e9;
}
.nutzenOverlayHead{
  position:sticky;
  top:0;
  background:#fff;
  z-index:1;
  padding:14px 16px;
  border-bottom:1px solid #eee;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.nutzenOverlayTitle{
  font-size:16px;
  font-weight:800;
  margin:0;
}
.nutzenOverlayClose{
  width:auto;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid #d6d6d6;
  background:#f3f3f3;
  color:#333;
  cursor:pointer;
}
.nutzenOverlayBody{ padding:14px 16px; }

.overlayGrid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
}
@media (max-width:900px){
  .overlayGrid{ grid-template-columns:1fr; }
}

.overlayCard{
  border:1px solid #e6e6e6;
  border-radius:14px;
  background:#fafafa;
  padding:12px;
}
.overlayCard h3{
  margin:0 0 10px;
  font-size:14px;
}

.statusPill{
  display:inline-flex;
  align-items:center;
  gap:8px;
  font-size:12px;
  font-weight:700;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid #e6e6e6;
  background:#fff;
}
.statusDot{
  width:10px; height:10px; border-radius:999px;
  background:#bbb;
}
.statusGreen .statusDot{ background:#1d6b3a; }
.statusYellow .statusDot{ background:#b8860b; }
.statusRed .statusDot{ background:#8a1f2a; }

.roleChips{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-top:8px;
}
.roleChip{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid #e6e6e6;
  background:#fff;
  font-size:12px;
  font-weight:700;
}
.roleChip.off{ opacity:.55; }

.overlayMiniTable{
  width:100%;
  border-collapse:collapse;
  font-size:12px;
  margin-top:10px;
}
.overlayMiniTable th, .overlayMiniTable td{
  border:1px solid #e6e6e6;
  padding:8px;
}
.overlayMiniTable th{ background:#f2f2f2; }

/* Overlay darf nur Klicks fressen, wenn es wirklich offen ist */
.nutzenOverlayBackdrop,
.nutzenOverlay{
  pointer-events: none;   /* wenn versteckt: keine Klicks blockieren */
}

/* wenn offen (per JS), dann wieder klickbar */
.nutzenOverlayBackdrop.isOpen,
.nutzenOverlay.isOpen{
  pointer-events: auto;
}


  </style>
</head>
<body>
<div class="wrap">


<!-- STARTSEITE (Menü) -->
<section id="page-home">

  <div class="card">
    <h1>Aktienübersicht</h1>
    <div class="muted">Wichtig bei Aktienkauf</div>
  </div>

  <div class="card">
    <div class="grid">
      <button type="button" onclick="goPage('etf')">Quellensteuerliste</button>
      <button type="button" onclick="goPage('finanztransaktionssteuer')">Finanztransaktionssteuer</button>
      <button type="button" onclick="goPage('cagr')">CAGR Rechner</button>
      <button type="button" onclick="goPage('icr')">Zinsdeckung (ICR) Rechner</button>
      <button type="button" onclick="goPage('volatility')">Volatilität (Std-Abw.)</button>
      <button type="button" onclick="goPage('checks')">Profitabel & FCF Check</button>
      <button type="button" onclick="goPage('fairprice')">Fairer Preis Rechner</button>
      <button type="button" onclick="goPage('fcfpayout')">(FCF-Payout Rechner)-in FCF Check</button>
      <button type="button" onclick="goPage('nutzen')">Nutzen Check</button>
      <button type="button" onclick="goPage('fx')">USD ⇄ EUR Rechner</button>

    </div>
  </div>
</section>

<section id="page-cagr" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Jahreswerte → CAGR + Jahr-zu-Jahr Wachstum</h1>
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <label>Was berechnen?</label>
        <select id="mode">
          <option value="revenue">Umsatz </option>
          <option value="eps">EPS</option>
          <option value="opmargin">Operative Marge</option>
          <option value="dividend">Dividende </option>
          <option value="price5y">Kurs </option>
          
        </select>
      </div>
      <div>
 <label>Anzahl Jahre (1–4)</label>
 <select id="years">
  <option value="2">1 Jahr</option>   <!-- 2 Datenpunkte => 1 Jahr -->
  <option value="3">2 Jahre</option>  <!-- 3 Datenpunkte => 2 Jahre -->
  <option value="4">3 Jahre</option>  <!-- 4 Datenpunkte => 3 Jahre -->
  <option value="5" selected>4 Jahre</option> <!-- 5 Datenpunkte => 4 Jahre -->
</select>

    </div>
    </div>

    <div style="margin-top:14px">
      <div id="yearInputs" class="grid3" style="margin-top:8px"></div>
      <div class="small">Erlaubt: 1.250.000 oder 1.250.000,50 oder 1250000</div>
    </div>

    <!-- Kurs 5Y (CAGR) - extra Eingabebox -->
<div id="price5yBox" style="display:none; margin-top:14px">
  <div class="grid">
    <div>
      <label>Kurs vor ~4 Jahren</label>
      <input id="pStart" inputmode="decimal" placeholder="z.B. 25,50" />
    </div>
    <div>
      <label>Kurs heute</label>
      <input id="pEnd" inputmode="decimal" placeholder="z.B. 40,10" />
    </div>
  </div>

  <div class="grid" style="margin-top:12px">
    <div>
    <label>Jahre</label>
     <input id="pYears" type="number" min="1" max="4" step="1" value="4" />
     <div class="small">1–4 Jahre einstellbar (wie bei FY-Logik üblich).</div>
    </div>
    <div></div>
  </div>
</div>

    <button id="calc" type="button">Berechnen</button>

    <div id="err" class="err" style="display:none"></div>
<div id="out" class="out" style="display:none"></div>

  </div> <!-- Ende: .card (CAGR) -->
</section> <!-- Ende: #page-cagr -->

<section id="page-fairprice" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Fairer Preis Rechner</h1>
  </div>

  <div class="card">
    <div class="grid">
      <!-- Rechner A: Implizites KGV Target aus Price Target -->
      <div class="out">
        <div class="kpi"><span><b>KGV Target berechnen</b></span><span class="small">Price Target / EPS</span></div>

        <label for="fp_epsA">EPS (Diluted, FY)</label>
        <input id="fp_epsA" inputmode="decimal" placeholder="z.B. 2,50" />

        <label for="fp_priceTarget" style="margin-top:10px">Price Target</label>
        <input id="fp_priceTarget" inputmode="decimal" placeholder="z.B. 40" />

        <button id="fp_calcPe" type="button" style="margin-top:10px">KGV Target berechnen</button>

        <div id="fp_peOut" class="out" style="display:none; margin-top:10px"></div>
        <div id="fp_peErr" class="err" style="display:none"></div>
      </div>

      <!-- Rechner B: Fairer Preis aus EPS & KGV Target -->
      <div class="out">
        <div class="kpi"><span><b>Fairer Preis</b></span><span class="small">EPS × KGV Target</span></div>

        <label for="fp_epsB">EPS (Diluted, FY)</label>
        <input id="fp_epsB" inputmode="decimal" placeholder="z.B. 2,50" />

        <label for="fp_peTarget" style="margin-top:10px">KGV Target</label>
        <input id="fp_peTarget" inputmode="decimal" placeholder="z.B. 15"  />

        <button id="fp_calcFair" type="button" style="margin-top:10px">Fairen Preis berechnen</button>

        <div id="fp_fairOut" class="out" style="display:none; margin-top:10px"></div>
        <div id="fp_fairErr" class="err" style="display:none"></div>
      </div>
    </div>
  </div>
</section>

<section id="page-fcfpayout" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>FCF-Payout Rechner</h1>
    <div class="muted">Dividenden gesamt ÷ Free Cash Flow (FCF)</div>
  </div>

  <div class="card">
    <div class="grid">

      <!-- Option A: Dividenden gesamt direkt -->
      <div class="out">
        <div class="kpi">
          <span><b>Option A: Dividenden gesamt</b></span>
          <span class="small">direkt eingeben</span>
        </div>

        <label for="fcf_divTotal">Dividenden gesamt (z. B. FY/TTM) Common Dividends Paid</label>
        <input id="fcf_divTotal" inputmode="decimal" placeholder="z.B. 1.250.000.000" />

        <label for="fcf_fcfA" style="margin-top:10px">FCF (gleiche Periode) 1Y</label>
        <input id="fcf_fcfA" inputmode="decimal" placeholder="z.B. 2.000.000.000" />

        <button id="fcf_calcA" type="button" style="margin-top:10px">FCF-Payout berechnen</button>

        <div id="fcf_outA" class="out" style="display:none; margin-top:10px"></div>
        <div id="fcf_errA" class="err" style="display:none"></div>
      </div>

      <!-- Option B: Dividende/Aktie + Aktienanzahl -->
      <div class="out">
        <div class="kpi">
          <span><b>Option B: Dividende/Aktie × Aktien</b></span>
          <span class="small">Dividenden gesamt berechnen</span>
        </div>

        <label for="fcf_dps">Dividende je Aktie (DPS)</label>
        <input id="fcf_dps" inputmode="decimal" placeholder="z.B. 2,10" />

        <label for="fcf_shares" style="margin-top:10px">Aktienanzahl (Shares, avg.)</label>
        <input id="fcf_shares" inputmode="decimal" placeholder="z.B. 1.100.000.000" />

        <label for="fcf_fcfB" style="margin-top:10px">FCF (gleiche Periode)</label>
        <input id="fcf_fcfB" inputmode="decimal" placeholder="z.B. 2.000.000.000" />

        <button id="fcf_calcB" type="button" style="margin-top:10px">FCF-Payout berechnen</button>

        <div id="fcf_outB" class="out" style="display:none; margin-top:10px"></div>
        <div id="fcf_errB" class="err" style="display:none"></div>
      </div>

    </div>

    <div class="small" style="margin-top:10px">
      Hinweis: Periode muss identisch sein (FY oder TTM). Wenn FCF ≤ 0, ist „Payout“ nicht sinnvoll (nicht gedeckt).
    </div>
  </div>
</section>


<section id="page-icr" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Zinsdeckung (ICR) Rechner</h1>
    <div class="muted">Typisch: EBIT ÷ Zinsaufwand (Interest Expense)</div>
  </div>

  <div class="card">
    <div class="grid">
      <div class="out">
        <div class="kpi">
          <span><b>ICR berechnen</b></span>
          <span class="small">EBIT / Zinsaufwand</span>
        </div>

        <label for="icr_ebit">EBIT</label>
        <input id="icr_ebit" inputmode="decimal" placeholder="z.B. 1.250.000.000" />

        <label for="icr_interest" style="margin-top:10px">Zinsaufwand (Interest Expense)</label>
        <input id="icr_interest" inputmode="decimal" placeholder="z.B. 150.000.000" />

        <button id="icr_calc" type="button" style="margin-top:10px">Zinsdeckung berechnen</button>

        <div id="icr_out" class="out" style="display:none; margin-top:10px"></div>
        <div id="icr_err" class="err" style="display:none"></div>

        <div class="small" style="margin-top:10px">
          Hinweis: In Cashflow/Income Statements ist „Interest Expense“ oft negativ (Vorzeichen). Dieser Rechner nutzt automatisch den Betrag (|Zinsaufwand|).
        </div>
      </div>

      <div class="out">
        <div class="kpi">
          <span><b>Interpretation (grob)</b></span>
          <span class="small">Daumenregeln</span>
        </div>
        <div class="small">
          • &lt; 2: kritisch<br/>
          • 2–4: eher schwach/erhöhtes Risiko<br/>
          • ≥ 4: eher solide<br/>
          • ≥ 8: sehr komfortabel (branchenabhängig)
        </div>
      </div>
    </div>
  </div>
</section>



<section id="page-checks" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Checks</h1>
    <div class="muted">Profitabel (Net Income &gt; 0) und FCF positiv (FCF &gt; 0)</div>
   </div>

   <div class="card">
    <div class="grid">

      <!-- Rechner 1: Profitabel -->
      <div class="out">
        <div class="kpi">
          <span><b>Profitabel?</b></span>
          <span class="small">Net Income (FY) &gt; 0</span>
        </div>

        <label for="chk_netIncome">Net Income (FY)</label>
        <input id="chk_netIncome" inputmode="decimal" placeholder="z.B. 1250000 oder 1.250.000" />

        <button id="chk_profitBtn" type="button">Prüfen</button>

        <div id="chk_profitErr" class="err" style="display:none"></div>
        <div id="chk_profitOut" class="out" style="display:none; margin-top:10px"></div>
      </div>

      <!-- Rechner 2: FCF positiv -->
      <div class="out">
        <div class="kpi">
          <span><b>FCF positiv?</b></span>
          <span class="small">FCF (FY) &gt; 0</span>
        </div>

        <label for="chk_fcf">FCF (FY)</label>
        <input id="chk_fcf" inputmode="decimal" placeholder="z.B. 350000 oder 350.000" />

        <button id="chk_fcfBtn" type="button">Prüfen</button>

        <div id="chk_fcfErr" class="err" style="display:none"></div>
        <div id="chk_fcfOut" class="out" style="display:none; margin-top:10px"></div>
      </div>



      <!-- Rechner 3: FCF aus OCF & CapEx -->
      <div class="out">
        <div class="kpi">
          <span><b>FCF berechnen</b></span>
          <span class="small">OCF − CapEx (oder + wenn CapEx negativ)</span>
        </div>

        <label for="chk_ocf">Operating Cash Flow (OCF)</label>
        <input id="chk_ocf" inputmode="decimal" placeholder="z.B. 1.250.000.000" />

        <label for="chk_capex" style="margin-top:10px">CapEx</label>
        <input id="chk_capex" inputmode="decimal" placeholder="z.B. 500.000.000 oder -500.000.000" />

        <div class="small" style="margin-top:8px">
          Regel: Wenn CapEx negativ eingegeben wird (z.B. -500), dann FCF = OCF + CapEx.
          Wenn CapEx positiv eingegeben wird, dann FCF = OCF − CapEx.
        </div>

        <button id="chk_fcfFromBtn" type="button" style="margin-top:10px">FCF berechnen → in Check übernehmen</button>

        <div id="chk_fcfFromErr" class="err" style="display:none"></div>
        <div id="chk_fcfFromOut" class="out" style="display:none; margin-top:10px"></div>
      </div>

      <!-- Rechner 4: FCF-Payout -->
<div class="out">
  <div class="kpi">
    <span><b>FCF-Payout</b></span>
    <span class="small">|Dividends Paid| ÷ FCF</span>
  </div>

  <label for="chk_divPaid">Dividends Paid (gesamt, FY/TTM)</label>
  <input id="chk_divPaid" inputmode="decimal" placeholder="z.B. -1.250.000.000 oder 1.250.000.000" />

  <label for="chk_fcfPayoutBase" style="margin-top:10px">FCF (gleiche Periode) </label>
  <input id="chk_fcfPayoutBase" inputmode="decimal" placeholder="z.B. 2.000.000.000" />

  <button id="chk_fcfPayoutBtn" type="button" style="margin-top:10px">FCF-Payout berechnen</button>

  <div id="chk_fcfPayoutErr" class="err" style="display:none"></div>
  <div id="chk_fcfPayoutOut" class="out" style="display:none; margin-top:10px"></div>

  <div class="small" style="margin-top:8px">
    Hinweis: Dividends Paid ist oft negativ → wird als Betrag (|…|) gerechnet. Wenn FCF ≤ 0, ist Payout nicht sinnvoll.
  </div>
    </div> 
  </div>   
</section>


<section id="page-volatility" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Volatilität (Std-Abw.)</h1>
    <div class="muted">
      Füge Kurs-Historie ein (z. B. von StockAnalysis: Date, Open, High, Low, Close, Adj Close, Change %, Volume).
      Der Rechner nutzt standardmäßig <b>Adj Close</b> (falls vorhanden), sonst <b>Close</b>.
    </div>
  </div>

  <div class="card">
    <label for="vol_big">Großes Eingabefeld (Historie)</label>
    <textarea id="vol_big" rows="10"
      style="width:100%;padding:10px;border-radius:10px;border:1px solid #d6d6d6;font-size:14px;box-sizing:border-box;resize:vertical"
      placeholder="Einfach hier reinkopieren…"></textarea>

    <div class="grid" style="margin-top:12px">
  <details style="margin-top:10px">
  <summary class="vol-muted" style="cursor:pointer">Erweiterte Optionen (Returns / Annualisierung)</summary>

  <div class="out" style="margin-top:10px">
    <div class="kpi"><span><b>Return-Definition</b></span><span class="vol-subtitle">optional</span></div>

    <label class="vol-muted" style="display:flex;gap:10px;align-items:center;margin-top:8px">
      <input type="radio" name="vol_retType" value="simple" checked>
      <span>Simple Returns</span>
    </label>
    <div class="vol-muted">Formel: (Pₜ / Pₜ₋₁ − 1) Simple Return</div>

    <label class="vol-muted" style="display:flex;gap:10px;align-items:center;margin-top:10px">
      <input type="radio" name="vol_retType" value="log">
      <span>Log Returns</span>
    </label>
    <div class="vol-muted">Formel: ln(Pₜ / Pₜ₋₁)  Log Return</div>

    <div style="margin-top:10px">
      <label class="vol-muted" for="vol_annualize">Annualisieren?</label>
      <select id="vol_annualize">
        <option value="no" selected>Nein (täglich)</option>
        <option value="yes">Ja (× √252)</option>
      </select>
      <div class="vol-muted">252 ≈ typische Handelstage/Jahr.</div>
    </div>
  </div>
</details>
      <div class="out">
        <div class="kpi"><span><b>Berechnung</b></span><span class="small">Aktion</span></div>
        <button type="button" id="vol_calcBtn">Volatilität berechnen</button>
        <button type="button" id="vol_clearBtn" style="background:#eee;color:#333">Leeren</button>
        <div id="vol_err" class="err" style="display:none;margin-top:10px"></div>
      </div>
    </div>

    <div id="vol_out" class="out" style="display:none;margin-top:12px"></div>

    <div class="small" style="margin-top:10px">
      Tipp: Wenn du Daten <b>neueste zuerst</b> einfügst, ist das okay – der Rechner sortiert automatisch nach Datum.
    </div>
  </div>
</section>

<section id="page-fx" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>USD ⇄ EUR Rechner</h1>
    <div class="muted">Standard: Offline-Kurs (vorgegeben). Optional kannst du den Kurs ändern oder per Button aktualisieren.</div>
  </div>

  <div class="card">
    <div class="grid">

      <div class="out">
        <div class="kpi">
          <span><b>Umrechnen</b></span>
          <span class="small">USD ↔ EUR</span>
        </div>

        <label for="fx_amount">Betrag</label>
        <input id="fx_amount" inputmode="decimal" placeholder="z.B. 100" />

        <div class="grid" style="margin-top:10px">
          <div>
            <label for="fx_from">Von</label>
            <select id="fx_from">
              <option value="USD" selected>USD</option>
              <option value="EUR">EUR</option>
            </select>
          </div>
          <div>
            <label for="fx_to">Nach</label>
            <select id="fx_to">
              <option value="EUR" selected>EUR</option>
              <option value="USD">USD</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <button type="button" id="fx_swapBtn" style="background:#eee;color:#333">↔ Swap</button>
          <button type="button" id="fx_refreshBtn">Kurs aktualisieren</button>
        </div>

<label for="fx_manualRate" style="margin-top:10px">Kurs (Standard = Offline-Default, optional anpassen)</label>
<input id="fx_manualRate" inputmode="decimal" placeholder="z.B. 0,92" />
<div class="small">Bedeutung: <b>1 (Von)</b> = Kurs in <b>(Nach)</b>. Beispiel: 1 USD = 0,92 EUR.</div>

        <button type="button" id="fx_calcBtn" style="margin-top:10px">Umrechnen</button>

        <div id="fx_err" class="err" style="display:none"></div>
        <div id="fx_out" class="out" style="display:none; margin-top:10px"></div>

        <div class="small" style="margin-top:10px">
         Hinweis: Frankfurter liefert i. d. R. Tageskurse (ECB, werktags aktualisiert).
<a href="https://frankfurter.dev/" target="_blank" rel="noopener">Quelle</a>
      </div>

      </div> 


      <div class="out">
        <div class="kpi">
          <span><b>Aktueller Kurs</b></span>
          <span class="small">Auto</span>
        </div>

        <div id="fx_rateBox" class="small" style="line-height:1.5">
          Kurs noch nicht geladen.
        </div>
      </div>

    </div>
  </div>
</section>


<section id="page-nutzen" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Nutzen Check</h1>
    <div class="muted">
      Tipp: Werte aus Excel/Google Sheets kopieren und hier einfügen (Tabs werden automatisch erkannt).
      Trennzeichen: Tab (Excel), Semikolon ; oder Zeilenumbrüche.
    </div>
  </div>

<div class="row" style="gap:10px; align-items:flex-end; margin-top:10px">
  <div style="min-width:220px">
    <label for="nutzen_cagrYears">CAGR Jahre (1–4)</label>
    <select id="nutzen_cagrYears">
      <option value="1">1 Jahr</option>
      <option value="2">2 Jahre</option>
      <option value="3">3 Jahre</option>
      <option value="4" selected>4 Jahre</option>
    </select>
    <div class="small">Nutzt automatisch die passenden CAGR-Spalten.</div>
  </div>

  <div style="min-width:220px">
    <label for="nutzen_volYears">Volatilität Jahr</label>
    <select id="nutzen_volYears">
      <option value="1">1Y</option>
      <option value="5">5Y</option>
      <option value="10">10Y</option>
    </select>
  </div>
</div>

  <div class="card">
    <div class="row" style="gap:10px; align-items:flex-end;">
      <div style="flex:1; min-width:220px;">
        <label for="nutzen_big">Großes Eingabefeld (55 Werte in Reihenfolge)</label>
        <textarea id="nutzen_big" rows="4" style="width:100%;padding:10px;border-radius:10px;border:1px solid #d6d6d6;font-size:14px;box-sizing:border-box;resize:vertical"></textarea>
        <div class="small" style="margin-top:6px">
          Reihenfolge = exakt die Überschriften (von links nach rechts). Fehlende Werte bleiben leer.
        </div>
      </div>
      <div style="min-width:220px">
        <button type="button" id="nutzen_parseBtn">Auf Spalten verteilen</button>
        <button type="button" id="nutzen_clearBtn" style="background:#eee;color:#333">Leeren</button>
        <button type="button" id="nutzen_overlayBtn" style="background:#111">Overlay (Rollen / Stress / Range)</button>
        
      </div>
    </div>

    <div style="overflow:auto; margin-top:12px">
      <table id="nutzenTable" style="min-width:2600px">
        <thead>
          <tr id="nutzenHeadRow"></tr>
        </thead>

        <!-- 1 großes Feld über die gesamte Breite (colspan=31) -->
        <tbody>
          <tr>
            <td id="nutzenBigCell" colspan="55" style="background:#fafafa">
              <div class="small" style="margin-bottom:6px;color:#666">

              </div>
              <!-- optionaler Spiegel-Output: wird per JS gesetzt -->
              
            </td>
          </tr>

          <!-- Ergebnis-Zeile: 31 Zellen -->
          <tr id="nutzenValueRow"></tr>
        </tbody>
      </table>
      <div id="nutzen_result" class="out" style="display:none; margin-top:12px"></div>

      <!-- Stress Flag (UI – Logik kommt später) -->
<div id="nutzen_stressBox" class="out" style="margin-top:12px">
  <div class="kpi">
    <span><b>Stress Flag</b></span>
    <span class="small">UI (später automatisch)</span>
  </div>

  <div id="nutzenStressPill" class="statusPill" style="margin-top:8px">
    <span class="statusDot"></span>
    <span id="nutzenStressText">– (noch nicht berechnet)</span>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <label>Manuell setzen (nur UI-Test)</label>
      <select id="nutzenStressSelect">
        <option value="auto" selected>Auto (später)</option>
        <option value="green">Grün</option>
        <option value="yellow">Gelb</option>
        <option value="red">Rot</option>
      </select>
    </div>
    <div></div>
  </div>

  <details style="margin-top:10px" open>
    <summary class="small" style="cursor:pointer">Begründung (Platzhalter)</summary>
    <div class="small" style="margin-top:8px;color:#666" id="nutzenStressWhy">
      Noch keine Begründung hinterlegt.
    </div>
  </details>
</div>
      <div id="nutzen_roles" class="roleBox"></div>
    </div>

    <div class="small" style="margin-top:10px">
      Hinweis: Die Werte werden als Text verteilt (z. B. „12,5%“,  ja“, „1.250.000“ bleibt erhalten).
    </div>
  </div>
</section>


<!-- OVERLAY: Rollen / Stress / Kauf+Nachkauf -->
<div id="nutzenOverlayBackdrop" class="nutzenOverlayBackdrop"></div>

<div id="nutzenOverlay" class="nutzenOverlay" aria-hidden="true">
  <div class="nutzenOverlayPanel" role="dialog" aria-modal="true" aria-labelledby="nutzenOverlayTitle">
    <div class="nutzenOverlayHead">
      <div>
        <div id="nutzenOverlayTitle" class="nutzenOverlayTitle">Nutzen-Overlay</div>
        <div class="small" style="margin-top:4px;color:#666">Rollen • Stress-Flag • Kauf/Nachkauf (UI – Logik kommt später)</div>
      </div>
      <button type="button" class="nutzenOverlayClose" id="nutzenOverlayCloseBtn">✕ Schließen</button>
    </div>

    <div class="nutzenOverlayBody">
      <div class="overlayGrid">

        <!-- Rollen -->
        <div class="overlayCard">
          <h3>Rollen</h3>
          <div class="small" style="color:#666">
            Aktuell nur Anzeige/Platzhalter. Auswahl kommt später über deine Auswertungslogik.
          </div>

          <div class="roleChips" id="nutzenOverlayRoles">
            <!-- wird per JS gefüllt -->
          </div>

          <details style="margin-top:10px">
            <summary class="small" style="cursor:pointer">Begründung / Checks (Platzhalter)</summary>
            <div class="small" style="margin-top:8px;color:#666" id="nutzenOverlayRolesWhy">
              Noch keine Begründung hinterlegt.
            </div>
          </details>
        </div>



        <!-- Stress Flag -->
        <div class="overlayCard">
          <h3>Stress Flag</h3>

          <div id="nutzenOverlayStressPill" class="statusPill">
            <span class="statusDot"></span>
            <span id="nutzenOverlayStressText">– (noch nicht berechnet)</span>
          </div>

          <div class="small" style="margin-top:10px;color:#666">
            (Optional) Manuell setzen — nur für UI-Test:
          </div>

          <div class="grid" style="margin-top:8px">
            <div>
              <label>Manuell</label>
              <select id="nutzenOverlayStressSelect">
                <option value="auto" selected>Auto (später)</option>
                <option value="green">Grün</option>
                <option value="yellow">Gelb</option>
                <option value="red">Rot</option>
              </select>
            </div>
            <div></div>
          </div>



          <!-- Preis & Aktionen (UI – keine Logik) -->
<div class="out" style="margin-top:12px">
  <div class="kpi">
    <span><b>Preis & Aktionen</b></span>
    <span class="small">UI (später automatisch)</span>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <label>Fairer Preis (manuell)</label>
      <input id="ov_fairPrice" type="number" step="0.01" placeholder="z. B. 400">
    </div>

    <div>
      <label>Kurs aktuell (optional)</label>
      <input id="ov_currentPrice" type="number" step="0.01" placeholder="z. B. 382.50">
    </div>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <label>Kaufen (UI)</label>
      <select id="ov_buySelect">
        <option value="auto" selected>Auto (später)</option>
        <option value="yes">Ja</option>
        <option value="maybe">Vielleicht</option>
        <option value="no">Nein</option>
      </select>
    </div>

    <div>
      <label>Nachkaufen (UI)</label>
      <select id="ov_addSelect">
        <option value="auto" selected>Auto (später)</option>
        <option value="yes">Ja</option>
        <option value="maybe">Vielleicht</option>
        <option value="no">Nein</option>
      </select>
    </div>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <div class="small" style="color:#666">Status</div>
      <div id="ov_actionSummary" class="small" style="margin-top:6px">
        Noch nichts gesetzt.
      </div>
    </div>
    <div>
      <button type="button" id="ov_clearActions" class="btn" style="margin-top:18px">
        Zurücksetzen
      </button>
    </div>
  </div>
</div>

          <details style="margin-top:10px" open>
            <summary class="small" style="cursor:pointer">Begründung (aufklappbar)</summary>
            <div class="small" style="margin-top:8px;color:#666" id="nutzenOverlayStressWhy">
              Noch keine Begründung hinterlegt.
            </div>
          </details>
        </div>

      </div>

      <!-- Kauf / Nachkauf -->
      <div class="overlayCard" style="margin-top:12px">
        <h3>Kauf- & Nachkauf-Range</h3>
        <div class="small" style="color:#666">
          UI steht — Berechnung kommt später. Unten zeigen wir schon die vorhandenen Werte aus deiner Tabelle (falls befüllt).
        </div>

        <table class="overlayMiniTable">
          <thead>
            <tr>
              <th>Feld</th>
              <th>Wert (aus Tabelle)</th>
            </tr>
          </thead>
          <tbody id="nutzenOverlayRangeBase">
            <!-- wird per JS gefüllt -->
          </tbody>
        </table>

        <details style="margin-top:10px">
          <summary class="small" style="cursor:pointer">Geplante Range-Logik (Platzhalter)</summary>
          <div class="small" style="margin-top:8px;color:#666">
            Beispiel später: Buy-Range = Fairer Preis × (1 − Sicherheitsmarge) … / Nachkauf in Stufen, abhängig Stress+Qualität.
          </div>
        </details>
      </div>

    </div>
  </div>
</div>


<section id="page-etf" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>

      <div class="row" style="align-items:flex-end; margin-top:10px">
      <div style="flex:1; min-width:220px">
        <label for="whtSearch">Suche (Land / Text)</label>
        <input id="whtSearch" type="text" placeholder="z.B. USA, Schweiz, 15%, Rückforderung …" />
      </div>
    </div>

    <h1 style="margin-top:10px">Quellensteuerliste</h1>
    <div class="muted">Übersicht: Standard-WHT, DBA (DE typ.) und DE-Behandlung (Privatanleger).</div>
    <div class="muted">Dividenden – Privatperson (DE steuerlich ansässig) - als Vergleichbroker wird Scalable genutzt</div>
  </div>

  <div class="card">
    <table id="whtTable">
      <thead>
        <tr>
          <th>Land</th>
          <th>Standard-WHT Dividenden</th>
          <th>DBA DE (typ.)</th>
          <th>DE-Behandlung (Privatanleger)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="small">Hinweis: Werte sind vereinfacht und beziehen sich auf die typische Abwicklung bei Scalable Capital. Je Wertpapier, Lagerstelle und Auszahlungsweg sind Abweichungen möglich; ggf. ist Rückforderung nötig.</div>
  </div>
</section>



<section id="page-finanztransaktionssteuer" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>

    <!-- SUCHFELD GANZ OBEN (nur FTS-Seite) -->
    <div class="row" style="align-items:flex-end; margin-top:10px">
      <div style="flex:1; min-width:220px">
        <label for="ftsSearch">Suche</label>
        <input id="ftsSearch" type="text" placeholder="z.B. Frankreich, 0,3%, Derivate …" />
      </div>
    </div>

    <h1 style="margin-top:10px">Finanztransaktionssteuer</h1>
    <div class="muted">Übersicht und Hinweise.</div>
  </div>

<table id="ftsTable">
  <thead>
    <tr>
      <th>Land</th>
      <th>Steuer (typ.)</th>
      <th>Wann fällt sie an?</th>
      <th>Scalable / Hinweis</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>
<div class="small">
  Hinweis: FTS-Regeln unterscheiden sich stark je Land und Produkt (Aktie/ETF/Derivat), Handelsplatz und Emittent.
  Werte sind vereinfacht als Orientierung.
</div>
</section>



</div>
<script>
   let whtSearchBound = false;
   let ftsSearchBound = false;
   let nutzenBound = false;
   let fxBound = false;


     const WHT_DATA = [
   { land:"Deutschland",
   standard:"25% KapESt + 5,5% Soli auf KapESt (+ ggf. KiSt)",
   dba:"–",
   de:"Scalable führt die Abgeltungsteuer (KapESt, Soli, ggf. KiSt) bei steuerpflichtigen Vorgängen automatisch ab; Freistellungsauftrag und Verlustverrechnungstöpfe werden dabei berücksichtigt."}, //  [oai_citation:0‡Scalable Capital Hilfe](https://help.scalable.capital/steuern-de12f868/wie-funktioniert-die-abf%C3%BChrung-der-abgeltungssteuer-d616ad21?utm_source=chatgpt.com)

   { land:"USA",
   standard:"30%",
   dba:"15% (mit W-8BEN)",
   de:"Für US-Dividenden gilt ohne gültiges W-8BEN i. d. R. 30% Quellensteuer. Mit korrekt hinterlegtem W-8BEN wird typischerweise der DBA-Satz von 15% angewendet. Die deutsche Abgeltungsteuer führt Scalable automatisch ab; die anrechenbare US-Quellensteuer wird im Rahmen der deutschen Besteuerung berücksichtigt. Eine Rückforderung ist meist nur nötig, wenn zu viel (z. B. 30% statt 15%) einbehalten wurde."}, //  [oai_citation:1‡de.scalable.capital](https://de.scalable.capital/assets/kcbf79ije7q7/3p8akTjsF4CUDdr7sQvFRS/ed449b9903137fb5e259f2ae17adc6f7/Scalable_Capital_-_Ausfuellhilfe_fuer_das_US-Formular_W-8BEN.pdf?utm_source=chatgpt.com)

   { land:"Kanada",
   standard:"25%",
   dba:"15%",
   de:"Kanada behält ohne DBA-Ermäßigung grundsätzlich 25% Non-Resident Tax ein. Nach DBA Kanada–Deutschland sind Dividenden für den in Deutschland Ansässigen auf max. 15% begrenzt (Portfolio-/Privatanleger-Fall). Scalable führt die deutsche Abgeltungsteuer automatisch ab; ein Über-DBA-Anteil wäre (falls er überhaupt anfällt) nur per Rückforderung in Kanada zu klären."}, //  [oai_citation:2‡canada.ca](https://www.canada.ca/en/revenue-agency/services/forms-publications/publications/t4058/non-residents-income-tax.html?utm_source=chatgpt.com)

   {land:"Mexiko",
   standard:"10%",
   dba:"15% (Privatanleger-Fall; 5% nur für qualifizierte Gesellschaften ≥10%)",
   de:"Mexiko erhebt auf Dividenden an Nichtansässige typischerweise 10% Quellensteuer. Das DBA Deutschland–Mexiko begrenzt Dividenden zwar grundsätzlich auf 15% (Privatanleger), aber weil der mexikanische Standardsatz schon darunter liegt, gibt es hier normalerweise keinen „Über-DBA“-Teil zum Zurückfordern. Scalable führt die deutsche Abgeltungsteuer automatisch ab; Anrechnung nur im Rahmen der deutschen Regeln."}, //  [oai_citation:3‡PwC Steuerübersichten](https://taxsummaries.pwc.com/mexico/corporate/withholding-taxes?utm_source=chatgpt.com)
 
   { land:"Brasilien",
   standard:"10% (seit 01/2026 auf Dividenden/Profite an Ausländer; zuvor i. d. R. 0%)",
   dba:"– (kein DBA/DTT Deutschland–Brasilien)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. In Brasilien fällt (seit 01/2026) i. d. R. 10% Quellensteuer auf ins Ausland ausgeschüttete Dividenden/Profite an; eine DBA-Reduktion gibt es mangels DBA nicht. Anrechnung in DE nur im Rahmen der deutschen Anrechnungsregeln und nur, soweit tatsächlich Quellensteuer einbehalten wurde."}, //  [oai_citation:0‡mayerbrown.com](https://www.mayerbrown.com/en/insights/publications/2025/12/enactment-of-law-no-15270-2025-which-establishes-dividend-taxation-expands-the-exemption-threshold-and-introduces-a-minimum-tax-on-high-incomes?utm_source=chatgpt.com)

   { land:"Vereinigtes Königreich (UK)",
   standard:"0% (normale UK-Aktien-Dividenden); 20% bei REIT/PAIF-‚Property Income Distributions‘",
   dba:"0% (normale Dividenden); bei REIT/PAIF ggf. Ermäßigung/Erstattung nach DBA möglich",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Bei normalen UK-Dividenden gibt es i. d. R. keine UK-Quellensteuer → keine Anrechnung/Rückforderung. Achtung Sonderfall: UK-REIT/PAIF-Ausschüttungen können mit UK-WHT (typisch 20%) kommen; hier kann je nach DBA/Status ggf. Erstattung/Reduktion relevant sein."}, //  [oai_citation:1‡PwC Steuerübersichten](https://taxsummaries.pwc.com/united-kingdom/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Irland",
   standard:"25% Dividend Withholding Tax (DWT) – kann für qualifizierte Nicht-Residenten oft vollständig befreit werden (Erklärung/Intermediär nötig)",
   dba:"15% (Obergrenze, falls überhaupt einbehalten wird; praktisch oft 0% bei korrekter Non-Resident-Befreiung)",
   de:"Scalable: DE-Steuer automatisch. Irland hat grundsätzlich 25% DWT, aber Nicht-Residenten aus ‚relevant territories‘ (u. a. DE) können bei korrekter Non-Resident-Erklärung (z. B. via Intermediär/Agent, Form V2A-Logik) häufig brutto (0% DWT) erhalten. Wenn dennoch einbehalten wird, ist der DBA-Gedanke typischerweise max. 15% – ein darüber hinausgehender Einbehalt wäre ggf. per Rückforderung in Irland zu klären."}, //  [oai_citation:2‡PwC Steuerübersichten](https://taxsummaries.pwc.com/ireland/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Frankreich",
   standard:"12,8% (Privatanleger/Individuals)",
   dba:"15% (DBA-Obergrenze; effektiv meist 12,8% weil Standard darunter)",
   de:"Scalable: DE-Steuer automatisch. Frankreich behält bei Privatanlegern i. d. R. 12,8% Quellensteuer ein; das liegt unter der typischen DBA-Obergrenze (15%). Rückforderung ist in der Praxis eher ein Thema, wenn ausnahmsweise mehr als 12,8% einbehalten wurde oder besondere Konstellationen vorliegen."}, //  [oai_citation:3‡PwC Steuerübersichten](https://taxsummaries.pwc.com/france/corporate/withholding-taxes?utm_source=chatgpt.com)
 
   { land:"Niederlande",
   standard:"15% Dividenden-Quellensteuer",
   dba:"15% (Privatanleger/Portfolio-Dividenden; praktisch i. d. R. keine Reduktion nötig, weil Standard = DBA)",
   de:"Scalable: DE-Steuer automatisch. Niederlande behalten typischerweise 15% auf Dividenden ein; diese 15% sind in DE grundsätzlich anrechenbar → meist kein Rückforderungsrest."}, //  [oai_citation:0‡business.gov.nl](https://business.gov.nl/regulations/dividend-tax/?utm_source=chatgpt.com)

   { land:"Belgien",
   standard:"30% Dividenden-Quellensteuer",
   dba:"15% (typischer DBA-Satz für Privatanleger/Portfolio-Dividenden)",
   de:"Scalable: DE-Steuer automatisch. Belgien behält standardmäßig 30% ein; in DE ist i. d. R. nur bis zum DBA-Satz (typisch 15%) anrechenbar. Der darüber hinausgehende Teil (typisch 15%-Punkte) wäre – falls du ihn reduzieren willst – nur über Erstattung/Refund in Belgien zu bekommen."}, //  [oai_citation:1‡Bird & Bird](https://www.twobirds.com/en/insights/2025/belgium/belgium-increase-of-the-withholding-tax-on-dividends--does-this-reform-really-undermine-the-attracti?utm_source=chatgpt.com)

   { land:"Luxemburg",
   standard:"15% Dividenden-Quellensteuer",
   dba:"15% (Privatanleger; 5% nur für qualifizierte Gesellschaften ≥10%)",
   de:"Scalable: DE-Steuer automatisch. Luxemburg hat als Standardsatz 15%; für Privatanleger entspricht das i. d. R. auch dem DBA-Satz → in DE grundsätzlich anrechenbar, meist kein Rückforderungsrest."}, //  [oai_citation:2‡Clearstream](https://www.clearstream.com/clearstream-en/res-library/market-coverage/equities-double-taxation-treaties-concluded-by-luxembourg-and-currently-in-force-1313108?utm_source=chatgpt.com)

   { land:"Schweiz",
   standard:"35% Quellensteuer (Verrechnungssteuer) auf Dividenden",
   dba:"15% (Restbelastung nach DBA; typischer Refund-Anteil ~20%-Punkte)",
   de:"Scalable: DE-Steuer automatisch. Schweiz behält 35% ein; in DE sind i. d. R. 15% anrechenbar, der Rest (typisch 20%-Punkte) ist häufig per Rückforderung in der Schweiz erstattbar. Für die CH-Rückforderung wird oft ein ‚Tax Voucher‘ benötigt; bei Scalable ist ein Tax Voucher laut Unterlagen mit 25 € pro Auftrag pro Kunde bepreist (falls benötigt)."}, //  [oai_citation:3‡ESTV](https://www.estv.admin.ch/en/anticipatory-tax?utm_source=chatgpt.com)
 
   { land:"Österreich",
   standard:"27,5% Quellensteuer auf Dividenden (KESt)",
   dba:"15% (Privatanleger/Portfolio-Dividenden)",
   de:"Scalable: DE-Steuer automatisch. Österreich behält grundsätzlich 27,5% ein; in Deutschland ist i. d. R. nur bis 15% anrechenbar. Der Überhang (typisch 12,5%-Punkte) ist – wenn du ihn zurückholen willst – nur über Rückforderung in Österreich möglich."}, //  [oai_citation:0‡Bundesministerium für Finanzen](https://www.bmf.gv.at/en/topics/taxation/double-taxation-agreements/relief-from-austrian-withholding-taxes-under-dtc.html?utm_source=chatgpt.com)

   { land:"Italien",
   standard:"26% Quellensteuer auf Dividenden (Standard)",
   dba:"15% (Privatanleger/Portfolio-Dividenden, typischer DBA-Satz)",
   de:"Scalable: DE-Steuer automatisch. Italien behält standardmäßig 26% ein; in DE ist i. d. R. bis 15% anrechenbar. Der Rest (typisch 11%-Punkte) wäre ggf. nur per Rückforderung in Italien zu holen."}, //  [oai_citation:1‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/italy/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Spanien",
   standard:"19% Quellensteuer auf Dividenden (Non-Resident Standard)",
   dba:"15% (Privatanleger/Portfolio-Dividenden nach DBA DE–ES)",
   de:"Scalable: DE-Steuer automatisch. Spanien behält i. d. R. 19% ein; in DE ist i. d. R. bis 15% anrechenbar. Die Differenz (typisch 4%-Punkte) ist ggf. per Rückforderung in Spanien möglich."}, //  [oai_citation:2‡Dentons](https://www.dentons.com/en/services-and-solutions/global-tax-guide-to-doing-business-in/spain?utm_source=chatgpt.com) 

   { land:"Portugal",
   standard:"28% Quellensteuer auf Dividenden (Non-Resident Individuals)",
   dba:"15% (Privatanleger/Portfolio-Dividenden nach DBA DE–PT)",
   de:"Scalable: DE-Steuer automatisch. Portugal behält für nichtansässige Privatpersonen typischerweise 28% ein; in DE ist i. d. R. nur bis 15% anrechenbar. Der Überhang (typisch 13%-Punkte) wäre ggf. nur per Rückforderung in Portugal zu klären."}, //  [oai_citation:3‡Caiado Guerreiro](https://www.caiadoguerreiro.com/en/taxation-of-dividends-between-companies-and-shareholders-resident-abroad/?utm_source=chatgpt.com)
  
   { land:"Dänemark",
   standard:"27% Dividenden-Quellensteuer (für Nichtansässige grundsätzlich; Reduktion nach DBA möglich)",
   dba:"15% (typischer DBA-Satz für Privatanleger/Portfolio-Dividenden)",
   de:"Scalable: DE-Steuer automatisch. Dänemark behält i. d. R. 27% ein; in DE ist typischerweise nur bis zum DBA-Satz (15%) anrechenbar. Der Überhang (typisch 12%-Punkte) ist – wenn du ihn zurückholen willst – nur über Rückforderung/Entlastungsverfahren in Dänemark möglich."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/denmark/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Schweden",
   standard:"30% Quellensteuer auf Dividenden an Nichtansässige",
   dba:"15% (nach DBA, sofern anwendbar)",
   de:"Scalable: DE-Steuer automatisch. Schweden behält für Nichtansässige normalerweise 30% ein; mit DBA kann der Satz reduziert sein (typisch 15%). In DE ist i. d. R. nur bis 15% anrechenbar; darüber hinausgehende Quellensteuer wäre ggf. per Rückforderung in Schweden zu klären."}, //  [oai_citation:1‡skatteverket.se](https://www.skatteverket.se/servicelankar/otherlanguages/englishengelska/businessesandemployers/nonestablishedforeignbusinesses/swedishwithholdingtaxondividends.4.34a801ea1041d54f9e28000452.html?utm_source=chatgpt.com)

   { land:"Norwegen",
   standard:"25% Quellensteuer auf Dividenden an ausländische Aktionäre",
   dba:"15% (Deutschland; 0% nur für qualifizierte Beteiligungen/Unternehmen)",
   de:"Scalable: DE-Steuer automatisch. Norwegen behält grundsätzlich 25% ein; nach DBA mit Deutschland gilt für Privatanleger typischerweise 15%. In DE i. d. R. nur bis 15% anrechenbar; der Überhang (typisch 10%-Punkte) wäre ggf. per Rückforderung in Norwegen zu holen."}, //  [oai_citation:2‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/norway/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Finnland",
   standard:"30% Quellensteuer auf Dividenden an Nichtansässige (35% bei nominee-registered, falls Begünstigter nicht identifizierbar)",
   dba:"oft 15% (je nach DBA; für Deutschland typischerweise 15%)", 
   de:"Scalable: DE-Steuer automatisch. Finnland behält bei Nichtansässigen typischerweise 30% ein (in Sonderfällen 35%); das DBA begrenzt häufig auf 15%. In DE ist i. d. R. nur bis 15% anrechenbar; ein Überhang wäre ggf. per Rückforderung in Finnland zu klären."}, //  [oai_citation:3‡vero.fi](https://www.vero.fi/en/individuals/tax-cards-and-tax-returns/moving_away_from_finland/paying_dividends_interest_and_royalties/?utm_source=chatgpt.com)

   { land:"Polen",
   standard:"19% Quellensteuer auf Dividenden (Standard, Non-Resident)",
   dba:"15% (DBA DE–PL: 15% „in allen anderen Fällen“; 5% nur für qualifizierte Gesellschaften ≥10%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Polen behält i. d. R. 19% ein; in Deutschland ist typischerweise nur bis 15% anrechenbar. Der Überhang (typisch 4%-Punkte) ist – wenn du ihn zurückholen willst – nur über Rückforderung/Entlastungsverfahren in Polen möglich."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/poland/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Tschechien",
   standard:"15% Quellensteuer auf Dividenden (Standard)",
   dba:"15% (Privatanleger-Fall; niedrigere Sätze betreffen typischerweise nur qualifizierte Gesellschaften/Beteiligungen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Tschechien behält i. d. R. 15% ein; diese 15% sind in DE grundsätzlich anrechenbar → meist kein Rückforderungsrest."}, //  [oai_citation:1‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/czech-republic/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Ungarn",
   standard:"15% Quellensteuer/Income Tax auf Dividenden (Standard)",
   dba:"15% (Privatanleger-Fall; niedrigere Sätze betreffen typischerweise nur qualifizierte Gesellschaften/Beteiligungen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Ungarn behält typischerweise 15% ein; diese 15% sind in DE grundsätzlich anrechenbar → meist kein Rückforderungsrest (sofern tatsächlich einbehalten)."}, //  [oai_citation:2‡Clearstream](https://www.clearstream.com/clearstream-en/res-library/market-coverage/equities-double-taxation-treaties-concluded-by-hungary-and-currently-in-force-1278696?utm_source=chatgpt.com)

   { land:"Griechenland",
   standard:"5% Quellensteuer auf Dividenden (Standard)",
   dba:"meist 10–15% (DBA-Obergrenze ist i. d. R. höher, praktisch aber irrelevant, weil GR-Standard bereits 5% ist)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Griechenland behält i. d. R. 5% ein; diese 5% sind in DE grundsätzlich anrechenbar → normalerweise kein Rückforderungsrest."}, //  [oai_citation:3‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/greece/individual/income-determination?utm_source=chatgpt.com)
  
   { land:"Türkei",
   standard:"15% Quellensteuer auf Dividenden (Standard, Non-Resident)",
   dba:"15% (Privatanleger/Portfolio-Dividenden; 5% nur für qualifizierte Gesellschaften mit hoher Beteiligung)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. In der Türkei beträgt die Dividenden-Quellensteuer für Nichtansässige grundsätzlich 15%. Für Privatanleger ist der DBA-Satz i. d. R. ebenfalls 15% → normalerweise kein Rückforderungsrest; relevant wird Rückforderung eher nur bei Fehlabzug/Abweichungen."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/turkey/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Russland",
   standard:"15% Quellensteuer auf Dividenden an Nichtansässige (nach russischem Recht; operative Abwicklung kann stark eingeschränkt sein)",
   dba:"– (DTA/DBA DE–RU von Russland seit 08/2023 für wesentliche Artikel ausgesetzt; Treaty-Entlastung praktisch i. d. R. nicht verlässlich)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt, soweit Zahlungen/Abwicklung überhaupt stattfinden. Die Anrechnung in DE hängt davon ab, ob tatsächlich Quellensteuer einbehalten wurde und ob belastbare Nachweise/Tax-Voucher vorhanden sind. Rückforderung/Entlastung in Russland ist praktisch oft schwierig (und kann je nach Wertpapier/Lagerstelle/Sanktionen faktisch nicht durchführbar sein)."}, //  [oai_citation:1‡Jarnias Cyril](https://www.jarniascyril.com/expatriation/guide-moving-to-russia-expat/russia-non-resident-taxation-filing-obligations/?utm_source=chatgpt.com)

   { land:"China",
   standard:"20% (Privatanleger/Individuals nach IIT-Logik; ohne Treaty-Entlastung)",
   dba:"10% (DBA DE–CN begrenzt Dividenden typischerweise auf 10%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Bei China-Dividenden ist der entscheidende Punkt, ob über die Verwahrkette/Treaty-Prozesse der DBA-Satz (typisch 10%) tatsächlich angewendet wird; ohne wirksame Treaty-Anwendung kann (bei Individuals) eine höhere Belastung auftreten. In DE ist die Quellensteuer grundsätzlich nur im Rahmen der deutschen Anrechnungsgrenzen anrechenbar."}, //  [oai_citation:2‡Lorenz & Partners](https://www.lorenz-partners.com/dividend-tax-german/?utm_source=chatgpt.com)
 
   { land:"Hongkong",
   standard:"0% (keine Quellensteuer auf Dividenden)",
   dba:"0% (praktisch, da keine WHT erhoben wird)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Hongkong erhebt aktuell keine Quellensteuer auf Dividenden → keine ausländische Quellensteuer, daher keine Anrechnung/Rückforderung nötig."}, //  [oai_citation:3‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/hong-kong-sar/corporate/withholding-taxes?utm_source=chatgpt.com)
  
   { land:"Singapur",
   standard:"0% (keine Quellensteuer auf Dividenden)",
   dba:"0% (praktisch, da keine WHT erhoben wird)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Singapur erhebt keine Quellensteuer auf Dividenden → keine ausländische Quellensteuer, daher keine Anrechnung/Rückforderung nötig."}, //  [oai_citation:0‡Default](https://www.iras.gov.sg/taxes/withholding-tax/payments-to-non-resident-company/payments-that-are-not-subject-to-withholding-tax?utm_source=chatgpt.com)

   { land:"Taiwan",
   standard:"21% Quellensteuer auf Dividenden an Nichtansässige (Standard)",
   dba:"10% (nach DE–Taiwan-Abkommen; Treaty-Entlastung erfordert i. d. R. Nachweise/Prozess in der Verwahrkette)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Ohne Treaty-Entlastung wird bei Taiwan-Dividenden typischerweise 21% einbehalten. Das DE–Taiwan-Abkommen begrenzt Dividenden grundsätzlich auf 10%; wenn über die Verwahrkette keine Treaty-Entlastung greift, bleibt der höhere Einbehalt bestehen und der Überhang wäre nur über Erstattungsverfahren/Entlastung in Taiwan lösbar."}, //  [oai_citation:1‡Ministerium für Landwirtschaft](https://www.mof.gov.tw/eng/singlehtml/264?cntId=82776&utm_source=chatgpt.com)

   { land:"Japan",
   standard:"typisch 15,315% auf Dividenden aus börsennotierten Aktien (Portfolio-Privatanleger; inkl. 2,1% Surtax auf den nationalen Anteil); in Sonderfällen auch ~20,42%",
   dba:"meist 15% (DBA-Obergrenze für Portfolio-Dividenden; ob/wie der kleine Zuschlagsanteil reduziert wird, hängt vom konkreten Entlastungsverfahren ab)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. In Japan wird bei Portfolio-Dividenden häufig ~15,315% einbehalten (typischer Börsenfall). In DE ist die Quellensteuer grundsätzlich nur bis zur Anrechnungsgrenze anrechenbar; ein eventueller Überhang wäre – falls relevant – nur über japanische Entlastung/Refund-Prozesse zu klären."}, //  [oai_citation:2‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/japan/corporate/income-determination?utm_source=chatgpt.com)

   { land:"Südkorea",
   standard:"22% Quellensteuer auf Dividenden an Nichtansässige (20% national + 10% Local Surtax auf die WHT = effektiv 22%)",
   dba:"15% (typischer DBA-Satz für Portfolio-Privatanleger; niedrigere Sätze nur für qualifizierte Beteiligungen/Unternehmen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Südkorea behält bei Nichtansässigen typischerweise effektiv 22% ein; in DE ist i. d. R. nur bis zum DBA-Satz (typisch 15%) anrechenbar. Der Überhang (typisch 7%-Punkte) wäre – wenn du ihn zurückholen willst – nur über Entlastungs-/Erstattungsverfahren in Korea möglich."}, //  [oai_citation:3‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/republic-of-korea/corporate/withholding-taxes?utm_source=chatgpt.com)
  
   { land:"Indien",
   standard:"20% Quellensteuer/TDS auf Dividenden an Nichtansässige (+ ggf. Zuschläge/Surcharge & Cess) – wenn kein Treaty-Satz angewendet wird",
   dba:"10% (DBA Indien–Deutschland, Art. 10: max. 10% wenn Empfänger beneficial owner)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Bei Indien ist ohne Treaty-Anwendung häufig 20% (+ Zuschläge/Cess) Einbehalt möglich. Nach DBA Indien–Deutschland sind Dividenden grundsätzlich auf 10% begrenzt; ob das in der Verwahrkette direkt als 10% durchläuft, hängt von den indischen/Intermediär-Prozessen und Nachweisen ab. In DE ist Quellensteuer i. d. R. nur bis zur Anrechnungsgrenze (typisch DBA-Satz) anrechenbar; ein Überhang wäre ggf. nur über Entlastung/Erstattung in Indien zu klären."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/india/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Indonesien",
   standard:"20% Quellensteuer auf Dividenden an Nichtansässige (ohne DBA)",
   dba:"15% (DBA Indonesien–Deutschland: Portfolio-Dividenden 15%; niedrigere Sätze nur für qualifizierte Beteiligungen/Unternehmen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Indonesien behält ohne Treaty i. d. R. 20% ein. Für DE-Privatanleger begrenzt das DBA die Dividenden-Quellensteuer typischerweise auf 15%; in Deutschland ist entsprechend i. d. R. nur bis 15% anrechenbar. Ein eventueller Überhang (z. B. wenn 20% einbehalten wurden) wäre nur über Erstattung/Entlastung in Indonesien zu klären."}, //  [oai_citation:1‡tax2win.in](https://tax2win.in/guide/dtaa-between-india-and-germany?utm_source=chatgpt.com)

   { land:"Malaysia",
   standard:"0% (keine Quellensteuer auf Dividenden)",
   dba:"0% (praktisch, da keine Dividenden-WHT erhoben wird)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Malaysia erhebt aktuell keine Quellensteuer auf Dividenden → keine ausländische Quellensteuer, daher keine Anrechnung/Rückforderung nötig."}, //  [oai_citation:2‡hasil.gov.my](https://www.hasil.gov.my/en/international/double-taxation-avoidance-agreement-dtadtaa/withholding-tax-rates/?utm_source=chatgpt.com)

   { land:"Thailand",
   standard:"10% Quellensteuer auf Dividenden",
   dba:"15% (DBA-Obergrenze; praktisch meist irrelevant, weil TH-Standard bereits 10% ist)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Thailand behält bei Dividenden typischerweise 10% ein; diese 10% sind in DE grundsätzlich anrechenbar (im Rahmen der deutschen Anrechnungsgrenzen). Rückforderung ist normalerweise kein Thema, weil die Quellensteuer nicht über einer typischen DBA-Obergrenze liegt."}, //  [oai_citation:3‡set.or.th](https://www.set.or.th/en/market/information/tax?utm_source=chatgpt.com)
   
   { land:"Vietnam",
   standard:"5% (Dividenden an Privatpersonen; für Corporate-Empfänger i. d. R. 0%)",
   dba:"–/praktisch selten relevant (Standard 5% liegt i. d. R. bereits unter typischen DBA-Obergrenzen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Vietnam besteuert Dividendenausschüttungen an Privatpersonen typischerweise mit 5% (PIT auf Investment Income). Wenn überhaupt Quellensteuer anfällt, ist sie in DE nur im Rahmen der Anrechnungsgrenzen anrechenbar; bei 5% entsteht normalerweise kein Rückforderungsrest."}, //  [oai_citation:0‡Andersen in Vietnam](https://vn.andersen.com/wp-content/uploads/2025/03/Andersen-in-Vietnam-Tax-Booklet_2025.pdf?utm_source=chatgpt.com)

   { land:"Philippinen", 
   standard:"25% (Dividenden an Nichtansässige nach Grundregel; in der Praxis über DBA reduzierbar)",
   dba:"15% (Privatanleger/„all other cases“ im DBA DE–PH; 5%/10% nur für qualifizierte Unternehmen mit hoher Beteiligung)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Ohne DBA-Entlastung wird in den Philippinen häufig ein höherer Satz einbehalten; nach DBA DE–PH sind Dividenden für Privatanleger typischerweise auf 15% begrenzt. In DE ist i. d. R. nur bis 15% anrechenbar; ein darüber hinausgehender Einbehalt wäre ggf. nur per Rückforderung/Entlastungsverfahren in den Philippinen lösbar."}, //  [oai_citation:1‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/philippines/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Australien",
   standard:"30% auf unfranked Dividenden (sofern keine Treaty-Reduktion greift); 0% auf franked Dividenden",
   dba:"15% (Privatanleger/„all other dividends“ im DBA AU–DE; 5% nur für Unternehmen ≥10% Beteiligung)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Franked Dividenden sind für Nichtansässige i. d. R. quellensteuerfrei (0%). Unfranked Dividenden unterliegen grundsätzlich WHT und können nach DBA AU–DE typischerweise auf 15% begrenzt sein (Privatanleger-Fall). In DE ist Quellensteuer nur im Rahmen der Anrechnungsgrenzen anrechenbar; Überhänge wären ggf. nur über Entlastung/Refund zu klären."}, //  [oai_citation:2‡ato.gov.au](https://www.ato.gov.au/forms-and-instructions/you-and-your-shares-2021/dividends-paid-or-credited-to-non-resident-shareholders?utm_source=chatgpt.com)

   { land:"Neuseeland", 
   standard:"30% NRWT auf Dividenden (ohne DBA/ohne korrekte DTA-Anwendung; Sonderregeln bei imputed dividends möglich)",
   dba:"15% (Privatanleger/Standard-DTA-Logik; 5% nur für qualifizierte Unternehmen ≥10%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Neuseeland wendet bei Dividenden ohne Treaty-Anwendung typischerweise 30% NRWT an. Unter DBA/DTA ist für Privatanleger regelmäßig eine Begrenzung (typisch 15%) vorgesehen; in DE ist i. d. R. nur bis zur DBA-Anrechnungsgrenze anrechenbar. Ein Überhang (z. B. 30% statt 15%) wäre ggf. nur über Entlastung/Refund in NZ zu klären."}, //  [oai_citation:3‡ird.govt.nz](https://www.ird.govt.nz/income-tax/withholding-taxes/non-resident-withholding-tax-nrwt/deduct-nrwt-at-the-right-rate/nrwt-rates-for-dta-countries?utm_source=chatgpt.com)
  
   { land:"Israel",
   standard:"25% (Privatanleger); 30% bei „substantial shareholder“ (typisch ≥10%)",
   dba:"10% (DBA DE–IL; 5% nur für Gesellschaften ≥10% Beteiligung; REIT-/Immobilien-ähnliche Ausschüttungen teils 15%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Israel behält bei Dividenden an ausländische Privatpersonen i. d. R. 25% ein (30% bei „substantial shareholder“). Nach dem DBA DE–IL liegt die Quellensteuer-Obergrenze für Privatanleger typischerweise bei 10% (wenn Treaty-Entlastung in der Verwahrkette greift); ein darüber hinausgehender Einbehalt wäre ggf. nur über Entlastung/Erstattung in Israel zu klären."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/israel/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Saudi-Arabien",
   standard:"5% Quellensteuer auf Dividenden",
   dba:"– (kein allgemeines DBA DE–Saudi für Dividenden; nur sehr begrenztes DBA für Luftfahrt/Arbeitnehmer existiert)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Saudi-Arabien erhebt auf Dividenden an Nichtansässige grundsätzlich 5% Quellensteuer. Da es mit Deutschland kein allgemeines DBA für Dividenden gibt, läuft das in der Praxis i. d. R. ohne DBA-Reduktion."}, //  [oai_citation:1‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/saudi-arabia/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"VAE (UAE)",
   standard:"0% Quellensteuer (derzeit; WHT-Satz ist gesetzlich auf 0% gesetzt)",
   dba:"0% (praktisch, weil UAE-WHT = 0%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Die VAE erheben derzeit 0% Quellensteuer auf relevante UAE-Einkünfte an Nichtansässige → keine ausländische Quellensteuer, daher keine Anrechnung/Rückforderung nötig."}, //  [oai_citation:2‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/united-arab-emirates/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Südafrika",
   standard:"20% Dividends Tax (Quellensteuer auf Dividenden an Nichtansässige)",
   dba:"15% (Privatanleger/„other beneficial owners“ nach DBA; niedrigere Sätze nur für qualifizierte Unternehmen/Beteiligungen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Südafrika behält grundsätzlich 20% ein; nach DBA ist für Privatanleger typischerweise 15% vorgesehen. In DE ist i. d. R. nur bis 15% anrechenbar; der Überhang (typisch 5%-Punkte) wäre – wenn du ihn zurückholen willst – nur über Entlastung/Erstattung in Südafrika möglich."}, //  [oai_citation:3‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/south-africa/corporate/withholding-taxes?utm_source=chatgpt.com)

];

const FTS_DATA = [
  {
    land: "Deutschland",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe wie z. B. in Frankreich/Italien.",
    note: "Scalable: i. d. R. keine FTS; nur Börsen-/Handelsplatzkosten/Spreads sind etwas anderes."
  },
  {
    land: "USA",
    steuer: "– (keine FTS; teils regulatorische Gebühren möglich)",
    wann: "Keine FTS auf Aktienkäufe; teils kleine regulatorische/SEC-bezogene Fees (nicht FTS) v. a. bei Verkäufen.",
    note: "Scalable: falls Gebühren anfallen, stehen sie in der Abrechnung (keine echte FTS)."
  },
  {
    land: "Kanada",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe/Verkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Mexiko",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Börsentransaktionen.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Brasilien",
    steuer: "i. d. R. keine klassische FTS (produkt-/strukturabhängig möglich)",
    wann: "Keine typische EU-ähnliche Aktienkauf-FTS; einzelne Abgaben können je Produkt/Route vorkommen.",
    note: "Scalable: abhängig von Produkt/Abwicklung; meist keine ausgewiesene FTS."
  },
  {
    land: "Vereinigtes Königreich (UK)",
    steuer: "0,5% Stamp Duty / SDRT (typisch, auf Käufe UK-Aktien)",
    wann: "Beim Kauf vieler UK-aktienähnlicher Titel (nicht auf Verkäufe); Ausnahmen je Instrument/Handelsweg.",
    note: "Scalable: wenn betroffen, erscheint es typischerweise als Steuer/Abgabe in der Abrechnung."
  },
  {
    land: "Irland",
    steuer: "1% Irish Stamp Duty (typisch, auf Käufe irischer Aktien)",
    wann: "Beim Kauf vieler irischer Aktien (nicht auf Verkäufe); Ausnahmen möglich.",
    note: "Scalable: wenn betroffen, wird es i. d. R. automatisch belastet."
  },
  {
    land: "Frankreich",
    steuer: "0,3% (typisch; französische Aktien-FTT)",
    wann: "Beim Kauf bestimmter französischer Aktien großer Unternehmen (schwellen-/listenbasiert).",
    note: "Scalable: wenn betroffen, wird es i. d. R. über die Abwicklung berechnet und ausgewiesen."
  },
  {
    land: "Niederlande",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Belgien",
    steuer: "Börsensteuer (TOB) – produktabhängig, teils gedeckelt",
    wann: "Je nach Wertpapier-Typ (Aktie/ETF/Fonds/Anleihe etc.) bei Kauf und/oder Verkauf; mit Höchstbeträgen.",
    note: "Scalable: hängt stark von Produkt & Abwicklung ab; Belgien ist besonders regel-/produktabhängig."
  },
  {
    land: "Luxemburg",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Schweiz",
    steuer: "Umsatzabgabe (Stempelsteuer) – nur falls CH-Effektenhändler beteiligt",
    wann: "Kann anfallen, wenn ein Schweizer Effektenhändler als Intermediär gilt; ansonsten oft nicht.",
    note: "Scalable: in DE-Depotstruktur häufig nicht relevant; abhängig von Verwahr-/Intermediär-Kette."
  },
  {
    land: "Österreich",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Italien",
    steuer: "0,1% / 0,2% (typisch; je nach Handelsplatz) + ggf. Derivate-FTT",
    wann: "Beim Kauf bestimmter italienischer Aktien; Derivate separat nach eigenen Tabellen/Regeln.",
    note: "Scalable: Aktien-Teil i. d. R. automatisch; Derivate nur relevant, wenn du diese handelst."
  },
  {
    land: "Spanien",
    steuer: "0,2% (typisch; spanische Aktien-FTT)",
    wann: "Beim Kauf bestimmter spanischer Aktien großer Unternehmen (listen-/schwellenbasiert).",
    note: "Scalable: wenn betroffen, wird es typischerweise automatisch berücksichtigt."
  },
  {
    land: "Portugal",
    steuer: "– (keine allgemeine Aktien-FTS)",
    wann: "Keine typische, landesweite Aktienkauf-FTS wie FR/IT/ES.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Dänemark",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Schweden",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Norwegen",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Finnland",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Polen",
    steuer: "– (keine typische Börsen-FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer wie in FR/IT/ES.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Tschechien",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Ungarn",
    steuer: "– (keine allgemeine Börsen-FTS auf Aktienkäufe)",
    wann: "Keine typische Aktienkauf-FTS wie FR/IT.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Griechenland",
    steuer: "– / ggf. Börsenabgaben je Markt möglich (nicht standardisierte FTS)",
    wann: "Keine klassische, allgemeine Aktienkauf-FTS wie FR/IT/ES.",
    note: "Scalable: i. d. R. keine FTS; im Zweifel Abrechnung prüfen."
  },
  {
    land: "Türkei",
    steuer: "– (keine allgemeine Aktien-FTS; teils Gebühren je Markt möglich)",
    wann: "Keine EU-ähnliche Aktienkauf-FTS als Standard.",
    note: "Scalable: i. d. R. keine FTS; abhängig von Produkt/Handelsweg."
  },
  {
    land: "Russland",
    steuer: "– (keine allgemein verlässliche FTS; Markt/Abwicklung stark eingeschränkt möglich)",
    wann: "Keine typische, stabile FTS-Logik für Privatanleger; Abwicklung kann eingeschränkt sein.",
    note: "Scalable: praktische Handelbarkeit/Abrechnung abhängig von Sanktionen/Handelsmöglichkeit."
  },
  {
    land: "China",
    steuer: "0,1% Stempelsteuer (typisch; auf Aktien-Transaktionen, i. d. R. Verkaufseite A-Shares)",
    wann: "Typisch als Stamp Duty auf bestimmte Börsentransfers (häufig auf Verkäufe; marktabhängig).",
    note: "Scalable: abhängig von Markt (A/H/ADR) und Abwicklung; erscheint ggf. als Stamp Duty."
  },
  {
    land: "Hongkong",
    steuer: "0,1% Stamp Duty je Seite (typisch)",
    wann: "Bei Kauf und Verkauf von HK-Aktien (jeweils auf den Transaktionswert; Rundungsregeln möglich).",
    note: "Scalable: wenn betroffen, erscheint es typischerweise als Stamp Duty."
  },
  {
    land: "Singapur",
    steuer: "– (keine allgemeine FTS/Stamp Duty auf Börsenaktienkäufe)",
    wann: "Keine typische Finanztransaktionssteuer auf börsliche Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Taiwan",
    steuer: "0,3% Securities Transaction Tax (typisch; oft Verkaufseite bei Aktien)",
    wann: "Typisch als STT auf Aktien-Transaktionen (häufig auf Verkäufe; je Produkt ggf. andere Sätze).",
    note: "Scalable: abhängig von Instrument/Markt; erscheint ggf. als Transaction Tax."
  },
  {
    land: "Japan",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe/Verkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Südkorea",
    steuer: "Securities Transaction Tax (STT) auf Verkäufe (Sätze je Markt/Produkt variieren)",
    wann: "Typisch auf Verkaufstransaktionen; Sätze unterscheiden sich (KOSPI/KOSDAQ/ETFs etc.).",
    note: "Scalable: abhängig von Markt/Produkt; wird ggf. in der Abrechnung ausgewiesen."
  },
  {
    land: "Indien",
    steuer: "Securities Transaction Tax (STT) (Sätze je Produkt/Seite variieren)",
    wann: "Auf Börsentransaktionen; je nach Instrument (Aktien, Optionen, Futures) und Kauf/Verkauf unterschiedlich.",
    note: "Scalable: nur relevant, wenn du indische Börsenprodukte handelst; erscheint ggf. als STT."
  },
  {
    land: "Indonesien",
    steuer: "Börsenabgaben/Levy möglich (keine „klassische“ FTS wie FR/IT)",
    wann: "Je nach Handelsplatz/Markt können Abgaben/Levy in Gebühren stecken.",
    note: "Scalable: abhängig vom Handelsweg; i. d. R. keine separate „FTS“-Position."
  },
  {
    land: "Malaysia",
    steuer: "Stamp Duty auf Contract Notes (typisch; gedeckelt, modellabhängig)",
    wann: "Bei Börsentransaktionen (häufig als Stempelsteuer auf Kontraktnoten; Caps möglich).",
    note: "Scalable: abhängig von Abwicklung/Markt; kann als Stamp Duty erscheinen."
  },
  {
    land: "Thailand",
    steuer: "– (keine allgemeine Aktien-FTS als Standard)",
    wann: "Keine typische Finanztransaktionssteuer auf Aktienkäufe wie in FR/IT.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Vietnam",
    steuer: "0,1% auf Verkäufe (typisch; marktabhängig)",
    wann: "Häufig als Abgabe auf Verkaufstransaktionen am Aktienmarkt (Regeln können je Markt variieren).",
    note: "Scalable: abhängig von Marktzugang/Produkt; erscheint ggf. als Transaction Tax/Fee."
  },
  {
    land: "Philippinen",
    steuer: "0,6% Stock Transaction Tax (typisch; auf Verkäufe börsennotierter Aktien)",
    wann: "Typisch auf Verkauf von an der lokalen Börse gehandelten Aktien.",
    note: "Scalable: abhängig von Marktzugang; erscheint ggf. als Stock Transaction Tax."
  },
  {
    land: "Australien",
    steuer: "– (keine allgemeine Aktien-Stamp Duty auf Börsenkäufe; historisch abgeschafft)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe an der Börse.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Neuseeland",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe/Verkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Israel",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe wie FR/IT.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Saudi-Arabien",
    steuer: "– (keine allgemeine FTS als Standard)",
    wann: "Keine typische Finanztransaktionssteuer auf Aktienkäufe wie in FR/IT/ES.",
    note: "Scalable: i. d. R. keine FTS; abhängig von Produkt/Markt."
  },
  {
    land: "VAE (UAE)",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Südafrika",
    steuer: "0,25% Securities Transfer Tax (typisch; auf Käufe/Transfers)",
    wann: "Typisch bei Kauf/Übertragung südafrikanischer Wertpapiere (Aktien/ähnliche).",
    note: "Scalable: wenn betroffen, wird es i. d. R. automatisch belastet und ausgewiesen."
  }
];


    // --- Seiten Navigation ---
  function goPage(page){
     closeNutzenOverlay(); // <-- WICHTIG: verhindert "unsichtbares Overlay blockt Klicks"
  const home = document.getElementById("page-home");
  const cagr = document.getElementById("page-cagr");
  const etf  = document.getElementById("page-etf");
  const finanztas = document.getElementById("page-finanztransaktionssteuer");
  const fair = document.getElementById("page-fairprice");
  const fcfp = document.getElementById("page-fcfpayout");
  const icr = document.getElementById("page-icr");
  const checks = document.getElementById("page-checks");
  const nutzen = document.getElementById("page-nutzen");
  const vol = document.getElementById("page-volatility");
  const fx = document.getElementById("page-fx");





  if (home) home.style.display = (page === "home") ? "block" : "none";
  if (cagr) cagr.style.display = (page === "cagr") ? "block" : "none";
  if (etf)  etf.style.display  = (page === "etf")  ? "block" : "none";
  if (finanztas) finanztas.style.display = (page === "finanztransaktionssteuer") ? "block" : "none";
  if (fair) fair.style.display = (page === "fairprice") ? "block" : "none";
  if (fcfp) fcfp.style.display = (page === "fcfpayout") ? "block" : "none";
  if (icr) icr.style.display = (page === "icr") ? "block" : "none";
  if (checks) checks.style.display = (page === "checks") ? "block" : "none";
  if (nutzen) nutzen.style.display = (page === "nutzen") ? "block" : "none";
if(page === "nutzen"){
  if(!nutzenBound){
    bindNutzenUI();
    nutzenBound = true;
  }
  nutzenUpdateYearVisibility();
}
  if (vol) vol.style.display = (page === "volatility") ? "block" : "none";
  if (fx) fx.style.display = (page === "fx") ? "block" : "none";

  if(page === "fx"){
  if(!fxBound){
    bindFxUI();
    fxBound = true;
  }
}


if(page === "etf") {
  renderWhtTable(document.getElementById("whtSearch")?.value || "");
  if(!whtSearchBound){
    bindWhtSearch();
    whtSearchBound = true;
  }
}

if(page === "finanztransaktionssteuer") {
  renderFtsTable(document.getElementById("ftsSearch")?.value || "");
  if(!ftsSearchBound){
    bindFtsSearch();
    ftsSearchBound = true;
  }
}
     

}
 document.addEventListener("DOMContentLoaded", () => goPage("home"));


function renderWhtTable(filterText = ""){
  const tbody = document.querySelector("#whtTable tbody");
  if(!tbody) return;

  const q = String(filterText || "").trim().toLowerCase();

  const rows = WHT_DATA.filter(r => {
    if(!q) return true;
    const hay = `${r.land} ${r.standard} ${r.dba} ${r.de}`.toLowerCase();
    return hay.includes(q);
  });

  tbody.innerHTML = rows.map(r => `
    <tr>
      <td>${r.land}</td>
      <td>${r.standard}</td>
      <td>${r.dba}</td>
      <td>${r.de}</td>
    </tr>
  `).join("");

  if(rows.length === 0){
    tbody.innerHTML = `<tr><td colspan="4" class="small">Keine Treffer.</td></tr>`;
  }
}



function renderFtsTable(filterText = ""){
  const tbody = document.querySelector("#ftsTable tbody");
  if(!tbody) return;

  const q = String(filterText || "").trim().toLowerCase();

  const rows = FTS_DATA.filter(r => {
    if(!q) return true;
    const hay = `${r.land} ${r.steuer} ${r.wann} ${r.note}`.toLowerCase();
    return hay.includes(q);
  });

  tbody.innerHTML = rows.map(r => `
    <tr>
      <td>${r.land}</td>
      <td>${r.steuer}</td>
      <td>${r.wann}</td>
      <td>${r.note}</td>
    </tr>
  `).join("");

  if(rows.length === 0){
    tbody.innerHTML = `<tr><td colspan="4" class="small">Keine Treffer.</td></tr>`;
  }
}

 

function bindWhtSearch(){
  const input = document.getElementById("whtSearch");
  if(!input) return;

  input.addEventListener("input", () => {
    renderWhtTable(input.value);
  });

  input.addEventListener("keydown", (e) => {
    if(e.key === "Enter") e.preventDefault();
  });
}

 
function bindFtsSearch(){
  const input = document.getElementById("ftsSearch");
  if(!input) return;

  input.addEventListener("input", () => {
    renderFtsTable(input.value);
  });

  input.addEventListener("keydown", (e) => {
    if(e.key === "Enter") e.preventDefault();
  });
}




  // --- Helpers (DE/EN Zahlformate) ---
function parseNumberSmart(raw){
  if(raw == null) return NaN;
  let s = String(raw).trim();
  if(!s) return NaN;

  s = s.replace(/\s+/g, "");

  // --- Suffix (K/M/B/T) erkennen ---
  // Beispiele: 12,106M | 13,75B | 550,11M | 1.2T | 120k
  let mult = 1;
  const m = s.match(/^(.*?)([kKmMbBtT])$/);
  if(m){
    s = m[1];
    const suf = m[2].toUpperCase();
    mult = (suf === "K") ? 1e3
         : (suf === "M") ? 1e6
         : (suf === "B") ? 1e9
         : (suf === "T") ? 1e12
         : 1;
  }

  // Prozentzeichen entfernen, falls mal drin
  s = s.replace(/%/g, "");

  const hasComma = s.includes(",");
  const hasDot = s.includes(".");

  // de-DE Tausenderpunkte ohne Komma (z.B. "1.234.567")
  if(hasDot && !hasComma && /^\d{1,3}(\.\d{3})+(\.\d+)?$/.test(s)){
    s = s.replace(/\./g, "");
    const n = Number(s);
    return Number.isFinite(n) ? n * mult : NaN;
  }

  if(hasComma && hasDot){
    const lastComma = s.lastIndexOf(",");
    const lastDot = s.lastIndexOf(".");
    if(lastComma > lastDot){
      s = s.replace(/\./g, "");
      s = s.replace(",", ".");
    } else {
      s = s.replace(/,/g, "");
    }
  } else if(hasComma && !hasDot){
    if(/^\d{1,3}(,\d{3})+$/.test(s)) s = s.replace(/,/g, "");
    else s = s.replace(",", ".");
  } else {
    s = s.replace(/,/g, "");
  }

  const n = Number(s);
  return Number.isFinite(n) ? n * mult : NaN;
}

function parse52wRange(raw){
  // akzeptiert: "21,03-32,07" | "21.03 - 32.07" | "21,03 - 32,07"
  if(raw == null) return { low: NaN, high: NaN };
  let s = String(raw).trim();
  if(!s) return { low: NaN, high: NaN };

  // normalize: replace en dash etc.
  s = s.replace(/–/g, "-");

  const parts = s.split(/\s*[-–\/]\s*/).map(x=>nzNum(x)).filter(n=>Number.isFinite(n));
  if(parts.length < 2) return { low: NaN, high: NaN };

  const a = parseNumberSmart(parts[0]);
  const b = parseNumberSmart(parts[1]);
  if(!Number.isFinite(a) || !Number.isFinite(b)) return { low: NaN, high: NaN };

  return { low: Math.min(a,b), high: Math.max(a,b) };
}


 // Speziell für Prozent-Eingaben (Operative Marge):
// - "12,106" => 12.106
// - "12.106" => 12.106  (ein einzelner Punkt = Dezimalpunkt)
// - "1.234.567" => 1234567 (mehrere Punkte = Tausender)
function parsePercentSmart(raw){
  if(raw == null) return NaN;
  let s = String(raw).trim();
  if(!s) return NaN;

  s = s.replace(/\s+/g, "").replace(/%/g, "");

  const dotCount = (s.match(/\./g) || []).length;
  const hasComma = s.includes(",");

  // Wenn Komma vorhanden: Komma = Dezimal, Punkte = Tausender
  if(hasComma){
    s = s.replace(/\./g, "");
    s = s.replace(",", ".");
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  // Wenn genau EIN Punkt vorhanden: als Dezimalpunkt behandeln (typisch bei Margen)
  if(dotCount === 1){
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  // Wenn mehrere Punkte: Tausendertrennzeichen
  if(dotCount > 1){
    s = s.replace(/\./g, "");
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  // Kein Komma/kein Punkt
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}


  function fmtPct(x){
    if(!Number.isFinite(x)) return "–";
    return (x*100).toFixed(2).replace(".", ",") + " %";
  }
  function fmtNum(x){
    if(!Number.isFinite(x)) return "–";
    return x.toLocaleString("de-DE", {maximumFractionDigits: 2});
  }

  function cagr(start, end, years){
    return Math.pow(end / start, 1 / years) - 1;
  }

  function showErr(msg){
    const el = document.getElementById("err");
    el.style.display = "block";
    el.textContent = msg;
  }
  function hideErr(){
    const el = document.getElementById("err");
    el.style.display = "none";
    el.textContent = "";
  }

  function showInlineErr(id, msg){
  const el = document.getElementById(id);
  if(!el) return;
  el.style.display = "block";
  el.textContent = msg; 
}
function hideInlineErr(id){
  const el = document.getElementById(id);
  if(!el) return;
  el.style.display = "none";
  el.textContent = "";
}

function calcICR(ebit, interestExpense){
  const e = ebit;
  const iAbs = Math.abs(interestExpense); // Interest Expense kann negativ gelistet sein

  if(!Number.isFinite(e)) return { ok:false, err:"Bitte EBIT korrekt eingeben." };
  if(!Number.isFinite(iAbs)) return { ok:false, err:"Bitte Zinsaufwand korrekt eingeben." };

  if(iAbs === 0){
    return { ok:false, err:"Zinsaufwand ist 0 → ICR ist nicht sinnvoll (theoretisch unendlich)." };
  }

  const icr = e / iAbs;

  // Wenn EBIT negativ ist, ist Zinsdeckung faktisch schlecht (trotz Rechnung).
  return { ok:true, icr, e, iAbs };
}

function bindICRUI(){
  const btn = document.getElementById("icr_calc");
  if(!btn) return;

  btn.addEventListener("click", () => {
    hideInlineErr("icr_err");

    const ebit = parseNumberSmart(document.getElementById("icr_ebit")?.value);
    const intE = parseNumberSmart(document.getElementById("icr_interest")?.value);

    const res = calcICR(ebit, intE);
    if(!res.ok) return showInlineErr("icr_err", res.err);

    const out = document.getElementById("icr_out");
    if(!out) return;

    const warn = (res.e < 0)
      ? `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: EBIT ist negativ → Zinsdeckung ist praktisch kritisch.</div>`
      : "";

    out.innerHTML = `
      <div class="kpi"><span>EBIT</span><span><b>${fmtNum(res.e)}</b></span></div>
      <div class="kpi"><span>Zinsaufwand (|…|)</span><span><b>${fmtNum(res.iAbs)}</b></span></div>
      <div class="kpi"><span><b>Zinsdeckung (ICR)</b></span><span><b>${fmtNum(res.icr)}</b></span></div>
      ${warn}
    `;
    out.style.display = "block";
  });

  // Enter = berechnen
  ["icr_ebit","icr_interest"].forEach(id => {
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("keydown", (e) => {
if(e.key === "Enter" && !e.shiftKey){
  e.preventDefault();
  btn.click();
}
    });
  });
}

document.addEventListener("DOMContentLoaded", bindICRUI);

function calcFcfPayout(divTotal, fcf){
  const divAbs = Math.abs(divTotal); // ok: Dividends Paid oft negativ
  const f = fcf;                    // NICHT abs!

  if(!Number.isFinite(divAbs)) return { ok:false, err:"Dividenden bitte korrekt eingeben." };
  if(!Number.isFinite(f)) return { ok:false, err:"FCF bitte korrekt eingeben." };
  if(f <= 0) return { ok:false, err:"FCF ist ≤ 0 → Payout nicht sinnvoll / nicht gedeckt." };

  const ratio = (divAbs / f) * 100;
  return { ok:true, ratio, divAbs, fcf: f };
}

function bindFcfPayoutUI(){
  const btnA = document.getElementById("fcf_calcA");
  const btnB = document.getElementById("fcf_calcB");

  const enterIds = ["fcf_divTotal","fcf_fcfA","fcf_dps","fcf_shares","fcf_fcfB"];

  if(btnA){
    btnA.addEventListener("click", () => {
      hideInlineErr("fcf_errA");

      const divT = parseNumberSmart(document.getElementById("fcf_divTotal")?.value);
      const fcf  = parseNumberSmart(document.getElementById("fcf_fcfA")?.value);

      const res = calcFcfPayout(divT, fcf);
      if(!res.ok) return showInlineErr("fcf_errA", res.err);

      const out = document.getElementById("fcf_outA");
      out.innerHTML = `
        <div class="kpi"><span>Dividenden gesamt</span><span><b>${fmtNum(res.divAbs)}</b></span></div>
        <div class="kpi"><span>FCF</span><span><b>${fmtNum(res.fcf)}</b></span></div>
        <div class="kpi"><span><b>FCF-Payout</b></span><span><b>${res.ratio.toFixed(2).replace(".", ",")} %</b></span></div>
      `;
      out.style.display = "block";
    });
  }

  if(btnB){
    btnB.addEventListener("click", () => {
      hideInlineErr("fcf_errB");

      const dps    = parseNumberSmart(document.getElementById("fcf_dps")?.value);
      const shares = parseNumberSmart(document.getElementById("fcf_shares")?.value);
      const fcf    = parseNumberSmart(document.getElementById("fcf_fcfB")?.value);

      if(!Number.isFinite(dps)) return showInlineErr("fcf_errB", "Bitte Dividende je Aktie korrekt eingeben.");
      if(!Number.isFinite(shares) || shares <= 0) return showInlineErr("fcf_errB", "Bitte Aktienanzahl korrekt (> 0) eingeben.");

      const divTotal = dps * shares;
      const res = calcFcfPayout(divTotal, fcf);
      if(!res.ok) return showInlineErr("fcf_errB", res.err);

      const out = document.getElementById("fcf_outB");
      out.innerHTML = `
        <div class="kpi"><span>DPS</span><span><b>${fmtNum(dps)}</b></span></div>
        <div class="kpi"><span>Shares</span><span><b>${fmtNum(shares)}</b></span></div>
        <div class="kpi"><span>Dividenden gesamt (berechnet)</span><span><b>${fmtNum(res.divAbs)}</b></span></div>
        <div class="kpi"><span>FCF</span><span><b>${fmtNum(res.fcf)}</b></span></div>
        <div class="kpi"><span><b>FCF-Payout</b></span><span><b>${res.ratio.toFixed(2).replace(".", ",")} %</b></span></div>
      `;
      out.style.display = "block";
    });
  }

enterIds.forEach(id => {
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener("keydown", (e) => {
    if(e.key === "Enter" && !e.shiftKey){
      e.preventDefault();
      // Option A Felder
      if(["fcf_divTotal","fcf_fcfA"].includes(id) && btnA) btnA.click();
      // Option B Felder
      if(["fcf_dps","fcf_shares","fcf_fcfB"].includes(id) && btnB) btnB.click();
    }
  });
});
}

document.addEventListener("DOMContentLoaded", bindFcfPayoutUI);




function calcPeTarget(){
  hideInlineErr("fp_peErr");

  const eps = parseNumberSmart(document.getElementById("fp_epsA")?.value);
  const pt  = parseNumberSmart(document.getElementById("fp_priceTarget")?.value);

  if(!Number.isFinite(eps)) return showInlineErr("fp_peErr", "Bitte EPS korrekt eingeben.");
  if(eps === 0) return showInlineErr("fp_peErr", "EPS darf nicht 0 sein.");
  if(!Number.isFinite(pt) || pt <= 0) return showInlineErr("fp_peErr", "Bitte Price Target korrekt (> 0) eingeben.");

  const pe = pt / eps;

  const out = document.getElementById("fp_peOut");
  if(!out) return;

  const warn = (eps < 0)
    ? `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: EPS ist negativ → KGV ist i. d. R. nicht sinnvoll (Turnaround/anderes Modell).</div>`
    : "";

  out.innerHTML = `
    <div class="kpi"><span>EPS</span><span><b>${fmtNum(eps)}</b></span></div>
    <div class="kpi"><span>Price Target</span><span><b>${fmtNum(pt)}</b></span></div>
    <div class="kpi"><span><b>KGV Target</b></span><span><b>${fmtNum(pe)}</b></span></div>
    ${warn}
    <div class="small" style="margin-top:6px">Tipp: Du kannst dieses KGV rechts übernehmen.</div>
  `;
  out.style.display = "block";

  // Komfort: übernehme KGV in Rechner B
  const peB = document.getElementById("fp_peTarget");
  if(peB) peB.value = String(Math.round(pe * 100) / 100).replace(".", ",");
}


function calcFairPriceStandalone(){
  hideInlineErr("fp_fairErr");

  const eps = parseNumberSmart(document.getElementById("fp_epsB")?.value);
  const pe  = parseNumberSmart(document.getElementById("fp_peTarget")?.value);

  if(!Number.isFinite(eps)) return showInlineErr("fp_fairErr", "Bitte EPS korrekt eingeben.");
  if(!Number.isFinite(pe) || pe <= 0) return showInlineErr("fp_fairErr", "Bitte KGV Target korrekt (> 0) eingeben.");

  const fair = eps * pe;

  const out = document.getElementById("fp_fairOut");
  if(!out) return;

  const warn = (eps < 0)
    ? `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: EPS ist negativ → Fair-Price via KGV ist i. d. R. nicht sinnvoll.</div>`
    : "";

  out.innerHTML = `
    <div class="kpi"><span>EPS</span><span><b>${fmtNum(eps)}</b></span></div>
    <div class="kpi"><span>KGV Target</span><span><b>${fmtNum(pe)}</b></span></div>
    <div class="kpi"><span><b>Fairer Preis</b></span><span><b>${fmtNum(fair)}</b></span></div>
    ${warn}
  `;
  out.style.display = "block";
}

function bindFairPriceUI(){
  const btnPe   = document.getElementById("fp_calcPe");
  const btnFair = document.getElementById("fp_calcFair");

  if(btnPe) btnPe.addEventListener("click", calcPeTarget);
  if(btnFair) btnFair.addEventListener("click", calcFairPriceStandalone);

  // Enter = berechnen
  const a = ["fp_epsA","fp_priceTarget"].map(id => document.getElementById(id)).filter(Boolean);
  const b = ["fp_epsB","fp_peTarget"].map(id => document.getElementById(id)).filter(Boolean);

  a.forEach(el => el.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcPeTarget(); } }));
  b.forEach(el => el.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcFairPriceStandalone(); } }));
}

document.addEventListener("DOMContentLoaded", bindFairPriceUI);

  function applyModeUI(){
  const mode = document.getElementById("mode")?.value;

  const yearInputsWrap = document.getElementById("yearInputs")?.parentElement; // der Wrapper <div style="margin-top:14px">
  const priceBox = document.getElementById("price5yBox");

  // Years-Select Wrapper (das div, wo "Anzahl Jahre" drin ist)
  const yearsSelect = document.getElementById("years");
  const yearsSelectWrap = yearsSelect ? yearsSelect.closest("div") : null;

  if(mode === "price5y"){
    if(yearInputsWrap) yearInputsWrap.style.display = "none";
    if(yearsSelectWrap) yearsSelectWrap.style.display = "none";
    if(priceBox) priceBox.style.display = "block";
  } else {
    if(yearInputsWrap) yearInputsWrap.style.display = "block";
    if(yearsSelectWrap) yearsSelectWrap.style.display = "block";
    if(priceBox) priceBox.style.display = "none";
    buildYearInputs(true); // beim normalen UI-Refresh Werte behalten
  }

  bindEnterToCalculate(); // Enter-Binding nach UI-Umschalten erneuern
}

// --- Bewertung: KGV Target + Fairer Preis ---








  // --- Dynamic Inputs ---
function buildYearInputs(keepValues = true){
  const n = Number(document.getElementById("years").value);
  const box = document.getElementById("yearInputs");

  const prev = keepValues
    ? [...box.querySelectorAll("input")].map(i => i.value)
    : [];

  box.innerHTML = "";

  for(let i=1;i<=n;i++){
    const wrap = document.createElement("div");
    const lab = document.createElement("label");
    lab.textContent = `Jahr ${i}`;
    lab.style.display = "block";
    lab.style.marginBottom = "6px";

    const inp = document.createElement("input");
    inp.id = "y" + i;
    inp.placeholder = (i===1) ? "Start" : (i===n ? "Ende" : "");
    inp.inputMode = "decimal";
    inp.value = keepValues ? (prev[i-1] ?? "") : "";

    wrap.appendChild(lab);
    wrap.appendChild(inp);
    box.appendChild(wrap);
  }
}

  

  function bindEnterToCalculate(){
  const calcBtn = document.getElementById("calc");

  // alle Inputs/Selects, die Enter auslösen sollen
 const fields = document.querySelectorAll("#yearInputs input, #mode, #years, #pStart, #pEnd, #pYears");

  fields.forEach(el => {
    el.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        calcBtn.click();     // rechnet
      }
     });
   });
 }

if (document.getElementById("years")) {
  document.getElementById("years").addEventListener("change", () => buildYearInputs(true));
  buildYearInputs();
  bindEnterToCalculate();
  applyModeUI();
}
document.getElementById("mode").addEventListener("change", () => {
  hideErr();
  const out = document.getElementById("out");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  buildYearInputs(false); // << löscht die Jahreswerte beim Moduswechsel
  applyModeUI();
});


  // --- Compute ---
  document.getElementById("calc").addEventListener("click", ()=>{
    hideErr();
    const out = document.getElementById("out");
    out.style.display = "none";
    out.innerHTML = "";

    const n = Number(document.getElementById("years").value);
    const mode = document.getElementById("mode").value;
    const label =
   (mode === "revenue") ? "Umsatz" :
   (mode === "eps") ? "EPS" :
   (mode === "opmargin") ? "Operative Marge" :
   (mode === "dividend") ? "Dividende" :

   "Kurs";

    // values
  const vals = [];
for(let i=1;i<=n;i++){
  const raw = document.getElementById("y"+i).value;
  const v = (mode === "opmargin") ? parsePercentSmart(raw) : parseNumberSmart(raw);
  vals.push(v);
}
    

// --- Sondermodus: Kurs CAGR (fix 4 Jahre) ---
if(mode === "price5y"){
  const pStart = parseNumberSmart(document.getElementById("pStart").value);
  const pEnd   = parseNumberSmart(document.getElementById("pEnd").value);

  const pYearsRaw = parseNumberSmart(document.getElementById("pYears").value);
const pYears = Math.round(pYearsRaw);

if(!Number.isFinite(pYearsRaw)) return showErr("Bitte Jahre korrekt eingeben.");
if(pYears < 1 || pYears > 4) return showErr("Jahre müssen zwischen 1 und 4 liegen.");
  


  // UI-Wert sicher setzen (falls Browser cached o.ä.)
  
  const pYearsEl = document.getElementById("pYears");
  if (pYearsEl) pYearsEl.value = String(pYears);

  if(!Number.isFinite(pStart) || pStart <= 0) return showErr("Bitte Kurs vor ~4 Jahren korrekt (> 0) eingeben.");
  if(!Number.isFinite(pEnd)   || pEnd <= 0)   return showErr("Bitte Kurs heute korrekt (> 0) eingeben.");

  const g = cagr(pStart, pEnd, pYears);
  const rel = (pEnd / pStart) - 1;
  const abs = pEnd - pStart;

  let html = "";
  html += `<div class="kpi"><span><b>Kurs CAGR (${pYears} Jahre)</b></span><span><b>${fmtPct(g)}</b></span></div>`;
  html += `<div class="kpi highlight"><span><b>Gesamtwachstum</b></span><span><b>${fmtPct(rel)}</b></span></div>`;
  html += `<div class="kpi"><span>Absolute Veränderung</span><span>${fmtNum(abs)}</span></div>`;
  html += `<div class="kpi"><span>Kurs (Start → Ende)</span><span>${fmtNum(pStart)} → ${fmtNum(pEnd)}</span></div>`;

  out.innerHTML = html;
  out.style.display = "block";
  return;
}

    // validate: all filled + finite
    for(let i=0;i<n;i++){
      if(!Number.isFinite(vals[i])){
        return showErr(`Bitte Wert für Jahr ${i+1} korrekt eingeben.`);
      }
    }

    // CAGR needs start > 0 and end > 0
const start = vals[0];
const end = vals[n-1];

// --- Sondermodus: Operative Marge (Eingabe in %) ---
// Regeln:
// - CAGR nur sinnvoll, wenn Start% > 0 und Ende% > 0
// - Sonst: Veränderung in Prozentpunkten (pp)
if(mode === "opmargin"){
  const valsPct = vals.slice();              // z.B. 12,5 = 12,5%
  const valsRatio = valsPct.map(v => v/100); // für CAGR-Rechnung als Anteil

  const startPct = valsPct[0];
  const endPct   = valsPct[n-1];
  const startR   = valsRatio[0];
  const endR     = valsRatio[n-1];

  const yearsSpan = n - 1;

  // CAGR nur wenn Start & Ende > 0
  let g = NaN;
  let cagrOk = false;
  if(startPct > 0 && endPct > 0){
    g = cagr(startR, endR, yearsSpan);
    cagrOk = true;
  }

  // Veränderung in Prozentpunkten
  const deltaPP = endPct - startPct;
  const ppPerYear = deltaPP / yearsSpan;

  // YoY in pp
  const yoyPP = [];
  for(let i=1;i<n;i++){
    yoyPP.push(valsPct[i] - valsPct[i-1]);
  }

  // render
  let html = "";
  if(cagrOk){
    html += `<div class="kpi"><span><b>${label} CAGR (${yearsSpan} Jahre)</b></span><span><b>${fmtPct(g)}</b></span></div>`;
  } else {
    html += `<div class="kpi"><span><b>${label} CAGR (${yearsSpan} Jahre)</b></span><span><b>–</b></span></div>`;
    html += `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: Operative Marge ist in Jahr 1 oder Jahr ${n} ≤ 0 → CAGR ist i. d. R. nicht sinnvoll. Stattdessen: Veränderung (pp).</div>`;
  }

  html += `<div class="kpi"><span>Veränderung (gesamt)</span><span><b>${fmtNum(deltaPP)} pp</b></span></div>`;
  html += `<div class="kpi"><span>Veränderung pro Jahr</span><span><b>${fmtNum(ppPerYear)} pp/Jahr</b></span></div>`;
  html += `<div class="kpi"><span>Jahr 1 / Jahr ${n}</span><span>${fmtNum(startPct)} % → ${fmtNum(endPct)} %</span></div>`;

  html += `<table>
    <thead>
      <tr>
        <th>Jahr</th>
        <th>${label} (%)</th>
        <th>Δ ggü. Vorjahr (pp)</th>
      </tr>
    </thead>
    <tbody>
  `;

  for(let i=0;i<n;i++){
    const dpp = (i===0) ? "–" : `${fmtNum(yoyPP[i-1])} pp`;
    html += `<tr>
      <td>Jahr ${i+1}</td>
      <td>${fmtNum(valsPct[i])} %</td>
      <td>${dpp}</td>
    </tr>`;
  }

  html += `</tbody></table>`;

  out.innerHTML = html;
  out.style.display = "block";
  return; // wichtig: verhindert, dass die "normale" CAGR-Logik unten weiterläuft
}

// Für Umsatz/Dividende bleibt die harte Regel (keine negativen/0 Startwerte)
if(mode !== "eps"){
  if(start <= 0) return showErr(`Jahr 1 (${label}) muss > 0 sein, sonst ist CAGR nicht sinnvoll.`);
  if(end < 0) return showErr(`Letztes Jahr (${label}) darf nicht negativ sein.`);
}

// Für EPS: negative Werte sind erlaubt.
// CAGR ist aber nur sinnvoll, wenn Start und Ende > 0 (klassische CAGR-Definition).

 
// YoY
const yoy = [];
for(let i=1;i<n;i++){
  const prev = vals[i-1];
  const cur = vals[i];
  if(prev === 0){
    yoy.push(NaN);
  } else {
    yoy.push((cur / prev) - 1);
  }
}

    const yearsSpan = n - 1; // Jahr1->JahrN

     let g = NaN;              // CAGR (nur wenn sinnvoll) 
     let cagrOk = false;
 
     if(mode !== "eps"){
     g = cagr(start, end, yearsSpan);
     cagrOk = true;
} else {
  // EPS: CAGR nur wenn Start & Ende > 0
  if(start > 0 && end > 0){
    g = cagr(start, end, yearsSpan);
    cagrOk = true;
  }
}

     // Ø YoY (geometrisch), nur wenn alle Jahre gültig und > -100%
    let geoAvgYoy = NaN;
    let ok = true;
    let factor = 1;

    for (let i = 1; i < n; i++) {
    const prev = vals[i-1];
    const cur  = vals[i];

     if (!(prev > 0) || !(cur >= 0)) { ok = false; break; }
    factor *= (cur / prev);
   }

    if (ok) {
    geoAvgYoy = Math.pow(factor, 1/(n-1)) - 1;
 }

    // total growth
    let rel = NaN;
if(start !== 0){
  rel = (end / start) - 1; // bei EPS mit negativem Start interpretierbar, aber ok als Mathe-Wert
}
    const abs = end - start;

    // render
    let html = "";
    if(cagrOk){
  html += `<div class="kpi"><span><b>${label} CAGR (${yearsSpan} Jahre)</b></span><span><b>${fmtPct(g)}</b></span></div>`;
} else if(mode === "eps"){
  html += `<div class="kpi"><span><b>EPS CAGR (${yearsSpan} Jahre)</b></span><span><b>–</b></span></div>`;
  html += `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: EPS ist in Jahr 1 oder Jahr ${n} ≤ 0 → CAGR ist i. d. R. nicht sinnvoll. Stattdessen: EPS-Veränderung.</div>`;
}
if(mode === "eps"){
  const delta = end - start;
  const perYear = delta / yearsSpan;
  html += `<div class="kpi"><span>EPS Veränderung (gesamt)</span><span>${fmtNum(delta)}</span></div>`;
  html += `<div class="kpi"><span>EPS Veränderung pro Jahr</span><span>${fmtNum(perYear)}</span></div>`;
}
    html += `<div class="kpi highlight"><span><b>Gesamtwachstum (Jahr 1 → Jahr ${n})</b></span><span><b>${fmtPct(rel)}</b></span></div>`;
    html += `<div class="kpi"><span>Absolute Veränderung</span><span>${fmtNum(abs)}</span></div>`;
    html += `<div class="kpi"><span>Jahr 1 / Jahr ${n}</span><span>${fmtNum(start)} → ${fmtNum(end)}</span></div>`;
    html += `<div class="kpi"><span>Ø Jahr-zu-Jahr Wachstum (geo)</span><span>${fmtPct(geoAvgYoy)}</span></div>`;

    html += `<table>
      <thead>
        <tr>
          <th>Jahr</th>
          <th>${label}</th>
          <th>Wachstum ggü. Vorjahr</th>
        </tr>
      </thead>
      <tbody>
    `;

    for(let i=0;i<n;i++){
      const growth = (i===0) ? "–" : (Number.isFinite(yoy[i-1]) ? fmtPct(yoy[i-1]) : "– (Vorjahr ≤ 0)");
      html += `<tr>
        <td>Jahr ${i+1}</td>
        <td>${fmtNum(vals[i])}</td>
        <td>${growth}</td>
      </tr>`;
    }

    html += `</tbody></table>`;

    out.innerHTML = html;
    out.style.display = "block";
  });





  function calcProfitCheck(){
  hideInlineErr("chk_profitErr");
  const out = document.getElementById("chk_profitOut");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  const ni = parseNumberSmart(document.getElementById("chk_netIncome")?.value);
  if(!Number.isFinite(ni)) return showInlineErr("chk_profitErr","Bitte Net Income korrekt eingeben.");

  const ok = ni > 0;

  out.innerHTML = `
    <div class="kpi"><span>Net Income</span><span><b>${fmtNum(ni)}</b></span></div>
    <div class="kpi"><span><b>Profitabel?</b></span><span><b>${ok ? "✅ ja" : "❌ nein"}</b></span></div>
    ${ni === 0 ? `<div class="small" style="margin-top:6px;color:#666">Hinweis: 0 ist weder Gewinn noch Verlust.</div>` : ""}
  `;
  out.style.display = "block";
}

function calcFcfCheck(){
  hideInlineErr("chk_fcfErr");
  const out = document.getElementById("chk_fcfOut");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  const fcf = parseNumberSmart(document.getElementById("chk_fcf")?.value);
  if(!Number.isFinite(fcf)) return showInlineErr("chk_fcfErr","Bitte FCF korrekt eingeben.");

  const ok = fcf > 0;

  out.innerHTML = `
    <div class="kpi"><span>FCF</span><span><b>${fmtNum(fcf)}</b></span></div>
    <div class="kpi"><span><b>FCF positiv?</b></span><span><b>${ok ? "✅ ja" : "❌ nein"}</b></span></div>
    ${fcf === 0 ? `<div class="small" style="margin-top:6px;color:#666">Hinweis: 0 bedeutet kein freier Cashflow übrig.</div>` : ""}
  `;
  out.style.display = "block";
}


function calcFcfFromOcfCapex(){
  hideInlineErr("chk_fcfFromErr");
  const out = document.getElementById("chk_fcfFromOut");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  const ocf = parseNumberSmart(document.getElementById("chk_ocf")?.value);
  const capex = parseNumberSmart(document.getElementById("chk_capex")?.value);

  if(!Number.isFinite(ocf)) return showInlineErr("chk_fcfFromErr","Bitte OCF korrekt eingeben.");
  if(!Number.isFinite(capex)) return showInlineErr("chk_fcfFromErr","Bitte CapEx korrekt eingeben.");

  // Logik:
  // CapEx negativ (z.B. -500) => FCF = OCF + CapEx
  // CapEx positiv (z.B. 500)  => FCF = OCF - CapEx
  const fcf = (capex < 0) ? (ocf + capex) : (ocf - capex);

  out.innerHTML = `
    <div class="kpi"><span>OCF</span><span><b>${fmtNum(ocf)}</b></span></div>
    <div class="kpi"><span>CapEx</span><span><b>${fmtNum(capex)}</b></span></div>
    <div class="kpi highlight"><span><b>FCF (berechnet)</b></span><span><b>${fmtNum(fcf)}</b></span></div>
    <div class="small" style="margin-top:6px">Übernommen in „FCF (FY)“ → du kannst direkt „Prüfen“ klicken.</div>
  `;
  out.style.display = "block";

  // In den bestehenden FCF-Check übernehmen
  const fcfInput = document.getElementById("chk_fcf");
  if(fcfInput) fcfInput.value = String(Math.round(fcf * 100) / 100).replace(".", ",");

  // Optional: direkt checken
  // calcFcfCheck();
}


function calcFcfPayoutInChecks(){
  hideInlineErr("chk_fcfPayoutErr");
  const out = document.getElementById("chk_fcfPayoutOut");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  const divPaidRaw = parseNumberSmart(document.getElementById("chk_divPaid")?.value);
  const fcfRaw     = parseNumberSmart(document.getElementById("chk_fcfPayoutBase")?.value);

  if(!Number.isFinite(divPaidRaw)) return showInlineErr("chk_fcfPayoutErr","Bitte Dividends Paid korrekt eingeben.");
  if(!Number.isFinite(fcfRaw))     return showInlineErr("chk_fcfPayoutErr","Bitte FCF korrekt eingeben.");
  if(fcfRaw <= 0)                 return showInlineErr("chk_fcfPayoutErr","FCF ist ≤ 0 → Payout nicht sinnvoll / nicht gedeckt.");

  const divAbs = Math.abs(divPaidRaw);
  const payout = (divAbs / fcfRaw) * 100;

  out.innerHTML = `
    <div class="kpi"><span>Dividends Paid (|…|)</span><span><b>${fmtNum(divAbs)}</b></span></div>
    <div class="kpi"><span>FCF</span><span><b>${fmtNum(fcfRaw)}</b></span></div>
    <div class="kpi highlight"><span><b>FCF-Payout</b></span><span><b>${payout.toFixed(2).replace(".", ",")} %</b></span></div>
  `;
  out.style.display = "block";
}

document.addEventListener("DOMContentLoaded", bindChecksUI);

function bindChecksUI(){
  const b1 = document.getElementById("chk_profitBtn");
  const b2 = document.getElementById("chk_fcfBtn");
  const b3 = document.getElementById("chk_fcfFromBtn");
  const b4 = document.getElementById("chk_fcfPayoutBtn");

  if(b1) b1.addEventListener("click", calcProfitCheck);
  if(b2) b2.addEventListener("click", calcFcfCheck);
  if(b3) b3.addEventListener("click", calcFcfFromOcfCapex);
  if(b4) b4.addEventListener("click", calcFcfPayoutInChecks);
  

  const i1 = document.getElementById("chk_netIncome");
  const i2 = document.getElementById("chk_fcf");
  const i3 = document.getElementById("chk_ocf");
  const i4 = document.getElementById("chk_capex");

  if(i1) i1.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcProfitCheck(); }});
  if(i2) i2.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcFcfCheck(); }});
  if(i3) i3.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcFcfFromOcfCapex(); }});
  if(i4) i4.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcFcfFromOcfCapex(); }});
}

document.addEventListener("DOMContentLoaded", bindChecksUI);



function bindShiftEnterDelegation(selector){
  document.addEventListener("keydown", (e) => {
    if (!(e.key === "Enter" && e.shiftKey)) return;

    const el = e.target;
    if (!(el instanceof HTMLElement)) return;

    // nur für Felder, die zu deinem Selector passen
    if (!el.matches(selector)) return;

    e.preventDefault();

    // aktuelles Feld-Set live holen (wichtig bei dynamischen Inputs!)
    const fields = Array.from(document.querySelectorAll(selector))
      .filter(x => !x.disabled && x.offsetParent !== null);

    const idx = fields.indexOf(el);
    const next = fields[idx + 1];
    if (next) next.focus();
  }, true); // capture=true, damit es nicht von anderen Enter-Handlern "geschluckt" wird
}

document.addEventListener("DOMContentLoaded", () => {
  bindShiftEnterDelegation(
    "#yearInputs input, #pStart, #pEnd, #pYears, " +
    "#chk_netIncome, #chk_fcf, #chk_ocf, #chk_capex, " +
    "#chk_divPaid, #chk_fcfPayoutBase, " +
    "#icr_ebit, #icr_interest, " +
    "#fp_epsA, #fp_priceTarget, #fp_epsB, #fp_peTarget, " +
    "#fcf_divTotal, #fcf_fcfA, #fcf_dps, #fcf_shares, #fcf_fcfB, " +
     "#fx_amount, #fx_from, #fx_to, #fx_manualRate"
  );
});

// ---------- Volatilität

// ---------- VOLATILITÄT (Std-Abw.) ----------
function parseVolLines(raw){
  let s = String(raw ?? "").trim();
  if(!s) return [];

  // Zeilen normalisieren
  s = s.replace(/\r/g, "\n");
  const lines = s.split("\n").map(x => x.trim()).filter(Boolean);

  const out = [];
  for(const line of lines){
    // Header-Zeilen überspringen
    const low = line.toLowerCase();
    if(low.includes("date") && (low.includes("close") || low.includes("adj"))) continue;

    // 1) bevorzugt Tab-splitting (Excel/Copy-Paste)
    let parts = line.includes("\t") ? line.split("\t") : null;

    // 2) fallback: mehrere Spaces
    if(!parts){
      parts = line.split(/\s{2,}|\s+\t|\t+\s+/).filter(Boolean);
      if(parts.length < 6){
        // noch robuster: alles nach "Volume" / etc. per single-space
        parts = line.split(/\s+/).filter(Boolean);
      }
    }

    // StockAnalysis: Date hat Komma -> meist als 3 Tokens wenn per single-space
    // Wir versuchen, ein Datum zu rekonstruieren:
    // Varianten:
    // A) parts[0] == "Feb", parts[1]=="20,", parts[2]=="2026"
    // B) parts[0] == "Feb 20, 2026" (wenn Tab)
    let dateStr = parts[0];

    if(/^[A-Za-z]{3,}$/.test(parts[0]) && parts.length >= 3 && parts[1].includes(",") && /^\d{4}$/.test(parts[2])){
      dateStr = `${parts[0]} ${parts[1]} ${parts[2]}`;
      parts = [dateStr, ...parts.slice(3)];
    }

    // Wenn es ein Tab-Paste war, ist date meist komplett in parts[0]
    // Numerische Felder: Open, High, Low, Close, Adj Close, Change%, Volume
    // Wir brauchen nur Close/AdjClose. Typisch sind mindestens 6 Zahlen.
    const dt = new Date(dateStr);
    if(!Number.isFinite(dt.getTime())) continue;

    // Versuche Close und Adj Close anhand typischer Position:
    // Nach Date kommen meist: Open High Low Close AdjClose Change% Volume
    // => closeIndex 3, adjIndex 4 (0-based in "parts" nach dem Datum)
    const open  = parseNumberSmart(parts[1]);
    const high  = parseNumberSmart(parts[2]);
    const lowP  = parseNumberSmart(parts[3]);
    const close = parseNumberSmart(parts[4]);
    const adj   = parseNumberSmart(parts[5]); // kann NaN sein, falls nicht vorhanden

    // Wenn Tab-Paste exakt ist, passt das. Wenn nicht, fallback: nimm die letzten 3-4 numerischen Spalten
    let closeUse = close;
    let adjUse = adj;

    // Fallback-Heuristik: finde alle parsebaren Zahlen (ohne Prozent)
    if(!Number.isFinite(closeUse)){
      const nums = parts
        .map(p => String(p).replace("%",""))
        .map(p => parseNumberSmart(p))
        .filter(n => Number.isFinite(n));

      // Bei StockAnalysis sind die ersten 5 nums typischerweise O/H/L/C/Adj
      if(nums.length >= 4) closeUse = nums[3];
      if(nums.length >= 5) adjUse = nums[4];
    }

    out.push({
      date: dt,
      dateStr,
      close: closeUse,
      adjClose: adjUse
    });
  }

  return out;
}

function stdevSample(arr){
  const n = arr.length;
  if(n < 2) return NaN;
  let mean = 0;
  for(const x of arr) mean += x;
  mean /= n;

  let ss = 0;
  for(const x of arr){
    const d = x - mean;
    ss += d*d;
  }
  return Math.sqrt(ss / (n - 1));
}

function mean(arr){
  if(!arr.length) return NaN;
  let s=0; for(const x of arr) s+=x;
  return s/arr.length;
}

function bindVolUI(){
  const ta = document.getElementById("vol_big");
  const btn = document.getElementById("vol_calcBtn");
  const clr = document.getElementById("vol_clearBtn");
  const err = document.getElementById("vol_err");
  const out = document.getElementById("vol_out");

  if(!btn || !ta || !out || !err) return;

  function showVolErr(m){
    err.style.display="block";
    err.textContent=m;
  }
  function hideVolErr(){
    err.style.display="none";
    err.textContent="";
  }

  function getRetType(){
    const r = document.querySelector('input[name="vol_retType"]:checked');
    return r ? r.value : "simple";
  }

  btn.addEventListener("click", () => {
    hideVolErr();
    out.style.display="none";
    out.innerHTML="";

    const rows = parseVolLines(ta.value);
    if(rows.length < 3) return showVolErr("Zu wenig Daten erkannt. Bitte mehrere Tage einfügen (mind. 3 Zeilen).");

    // Preis wählen: Adj Close wenn vorhanden und >0, sonst Close
    const usable = rows
      .map(r => ({
        date: r.date,
        px: (Number.isFinite(r.adjClose) && r.adjClose > 0) ? r.adjClose : r.close
      }))
      .filter(r => Number.isFinite(r.px) && r.px > 0);

    if(usable.length < 3) return showVolErr("Konnte keine gültigen Close/Adj Close Preise erkennen.");

    // Sortiere nach Datum aufsteigend
    usable.sort((a,b)=>a.date - b.date);

    // Returns berechnen
    const retType = getRetType();
    const rets = [];
    for(let i=1;i<usable.length;i++){
      const p0 = usable[i-1].px;
      const p1 = usable[i].px;
      if(p0 <= 0 || p1 <= 0) continue;
      const r = (retType === "log") ? Math.log(p1/p0) : (p1/p0 - 1);
      if(Number.isFinite(r)) rets.push(r);
    }

    if(rets.length < 2) return showVolErr("Zu wenige gültige Returns (nach Filterung).");

    const sd = stdevSample(rets);
    const mu = mean(rets);
    const minR = Math.min(...rets);
    const maxR = Math.max(...rets);

    const annualize = document.getElementById("vol_annualize")?.value === "yes";
    const factor = annualize ? Math.sqrt(252) : 1;
    const sdAdj = sd * factor;

    const fmtPctLocal = (x) => (x*100).toFixed(2).replace(".", ",") + " %";
    const from = usable[0].date.toLocaleDateString("de-DE");
    const to   = usable[usable.length-1].date.toLocaleDateString("de-DE");

    out.innerHTML = `
      <div class="kpi"><span>Zeitraum</span><span><b>${from} → ${to}</b></span></div>
      <div class="kpi"><span>Zeilen (Preise)</span><span><b>${usable.length}</b></span></div>
      <div class="kpi"><span>Returns</span><span><b>${rets.length}</b></span></div>

      <div class="kpi highlight"><span><b>Volatilität (Std-Abw.)</b></span><span><b>${fmtPctLocal(sdAdj)}</b></span></div>

      <div class="kpi"><span>Ø täglicher Return</span><span>${fmtPctLocal(mu)}</span></div>
      <div class="kpi"><span>Min / Max Return</span><span>${fmtPctLocal(minR)} / ${fmtPctLocal(maxR)}</span></div>

      <div class="small" style="margin-top:8px">
        Return-Typ: <b>${retType === "log" ? "Log Returns" : "Simple Returns"}</b><br/>
        Annualisierung: <b>${annualize ? "Ja (× √252)" : "Nein (täglich)"}</b>
      </div>
    `;
    out.style.display = "block";
  });

  if(clr){
    clr.addEventListener("click", () => {
      ta.value = "";
      hideVolErr();
      out.style.display = "none";
      out.innerHTML = "";
    });
  }
}

document.addEventListener("DOMContentLoaded", bindVolUI);

  // Enter im Textarea soll normal Zeilenumbruch machen (kein Berechnen).





// ---------- Euro - Dollar ----------
const FX_OFFLINE_DEFAULT = 0.92; // 1 USD = 0,92 EUR (kannst du ändern)

// LocalStorage Keys (damit "standardmäßig offline", aber mit Cache)
const FX_LS_RATE_KEY = "fx_usd_eur_rate";
const FX_LS_TIME_KEY = "fx_usd_eur_rate_ts";

// Frankfurter API (ECB-Daten, werktags). Wir holen USD->EUR.
const FX_API = "https://api.frankfurter.app/latest?from=USD&to=EUR";

// --- Helper ---
function fxNowMs(){ return Date.now(); }
function fxIsFresh(tsMs, maxAgeHours=24){
  if(!Number.isFinite(tsMs)) return false;
  return (fxNowMs() - tsMs) <= maxAgeHours*60*60*1000;
}
function fxFmtRate(x){
  if(!Number.isFinite(x)) return "–";
  return x.toLocaleString("de-DE",{minimumFractionDigits:4, maximumFractionDigits:6});
}
function fxFmtMoney(x, ccy){
  if(!Number.isFinite(x)) return "–";
  // ohne Intl-Währungsformat (weil du eh DE/EN mischst) – schlicht:
  return `${x.toLocaleString("de-DE",{maximumFractionDigits:2})} ${ccy}`;
}

// Rate lesen: Cache -> Default
function fxGetStoredRate(){
  const r = Number(localStorage.getItem(FX_LS_RATE_KEY));
  const ts = Number(localStorage.getItem(FX_LS_TIME_KEY));
  if(Number.isFinite(r) && r>0) return { rate:r, ts };
  return { rate: FX_OFFLINE_DEFAULT, ts: NaN };
}
function fxStoreRate(rate){
  if(!Number.isFinite(rate) || rate<=0) return;
  localStorage.setItem(FX_LS_RATE_KEY, String(rate));
  localStorage.setItem(FX_LS_TIME_KEY, String(fxNowMs()));
}

// Aktuelle Rate für UI konstruieren abhängig von From/To
// Basis ist immer usdEur = 1 USD in EUR
function fxGetEffectiveRate(from, to, usdEur){
  if(from === to) return 1;
  // Wenn von USD nach EUR: usdEur
  if(from === "USD" && to === "EUR") return usdEur;
  // Wenn von EUR nach USD: inverse
  if(from === "EUR" && to === "USD") return 1 / usdEur;
  // Fallback
  return NaN;
}

async function fxFetchFrankfurterUsdEur(){
  const res = await fetch(FX_API, { cache:"no-store" });
  if(!res.ok) throw new Error("HTTP " + res.status);
  const data = await res.json();
  const rate = data?.rates?.EUR;
  const date = data?.date; // yyyy-mm-dd (Tageskurs)
  if(!Number.isFinite(rate) || rate<=0) throw new Error("Rate fehlt/ungültig");
  return { rate, date };
}

function bindFxUI(){

  console.log("bindFxUI start", {
  amount: !!document.getElementById("fx_amount"),
  from: !!document.getElementById("fx_from"),
  to: !!document.getElementById("fx_to"),
  calc: !!document.getElementById("fx_calcBtn"),
  rateBox: !!document.getElementById("fx_rateBox")
});
  const amountEl = document.getElementById("fx_amount");
  const fromEl   = document.getElementById("fx_from");
  const toEl     = document.getElementById("fx_to");
  const swapBtn  = document.getElementById("fx_swapBtn");
  const refreshBtn = document.getElementById("fx_refreshBtn");
  const manualEl = document.getElementById("fx_manualRate");
  const calcBtn  = document.getElementById("fx_calcBtn");
  const errEl    = document.getElementById("fx_err");
  const outEl    = document.getElementById("fx_out");
  const rateBox  = document.getElementById("fx_rateBox");

  if(!amountEl || !fromEl || !toEl || !swapBtn || !refreshBtn || !manualEl || !calcBtn || !errEl || !outEl || !rateBox) return;

  function showFxErr(msg){
    errEl.style.display="block";
    errEl.textContent=msg;
  }
  function hideFxErr(){
    errEl.style.display="none";
    errEl.textContent="";
  }
  function setRateBox(text){
    rateBox.innerHTML = text;
  }

  // 1) Init: Offline Default + ggf. Cache anzeigen
  const stored = fxGetStoredRate();
  let usdEur = stored.rate; // 1 USD in EUR
  let ts = stored.ts;

  // Manual field standardmäßig NICHT überschreiben, wenn User schon was eingetippt hat
  function syncManualPlaceholder(){
    const from = fromEl.value;
    const to   = toEl.value;
    const rEff = fxGetEffectiveRate(from, to, usdEur);
    // Wir setzen den Input nur, wenn er leer ist (damit "offline standardmäßig")
    if(!manualEl.value){
      manualEl.value = String(Math.round(rEff*1000000)/1000000).replace(".", ",");
    }
  }

  function renderRateStatus(extraNote=""){
    const from = fromEl.value, to = toEl.value;
    const eff = fxGetEffectiveRate(from, to, usdEur);
    const ageTxt = Number.isFinite(ts)
      ? ` (Cache: ${new Date(ts).toLocaleString("de-DE")})`
      : " (Offline-Default)";

    setRateBox(`
      <div><b>Basis:</b> 1 USD = ${fxFmtRate(usdEur)} EUR${ageTxt}</div>
      <div><b>Aktiv:</b> 1 ${from} = ${fxFmtRate(eff)} ${to}</div>
      ${extraNote ? `<div class="vol-muted" style="margin-top:6px">${extraNote}</div>` : ""}
    `);
  }

  syncManualPlaceholder();
  renderRateStatus(fxIsFresh(ts,24) ? "" : "Hinweis: Cache älter/leer → aktuell wird der Offline-Default genutzt (bis du aktualisierst).");

  // 2) Convert
  function fxConvert(){
    hideFxErr();
    outEl.style.display="none";
    outEl.innerHTML="";

    const amt = parseNumberSmart(amountEl.value);
    if(!Number.isFinite(amt)) return showFxErr("Bitte Betrag korrekt eingeben.");

    const from = fromEl.value;
    const to   = toEl.value;
    if(from === to){
      outEl.innerHTML = `<div class="kpi highlight"><span><b>Ergebnis</b></span><span><b>${fxFmtMoney(amt,to)}</b></span></div>`;
      outEl.style.display="block";
      return;
    }

    // Manual Rate: wenn vorhanden, nimmt Vorrang (genau wie du es wolltest)
    let rateManual = parseNumberSmart(manualEl.value);
    const hasManual = Number.isFinite(rateManual) && rateManual > 0;

    const rate = hasManual ? rateManual : fxGetEffectiveRate(from, to, usdEur);
    if(!Number.isFinite(rate) || rate<=0) return showFxErr("Kurs ist ungültig. Bitte Kurs eintragen oder aktualisieren.");

    const result = amt * rate;

    const src = hasManual ? "Manuell" : (Number.isFinite(ts) ? "Cache/Frankfurter" : "Offline-Default");
    outEl.innerHTML = `
      <div class="kpi"><span>Quelle</span><span><b>${src}</b></span></div>
      <div class="kpi"><span>Kurs</span><span><b>1 ${from} = ${fxFmtRate(rate)} ${to}</b></span></div>
      <div class="kpi highlight"><span><b>Ergebnis</b></span><span><b>${fxFmtMoney(result,to)}</b></span></div>
    `;
    outEl.style.display="block";
  }

  // 3) Refresh (Frankfurter) – optional, nur per Button (=> standardmäßig offline)
  async function fxRefresh(){
    hideFxErr();
    setRateBox(`Lade Kurs von Frankfurter…`);

    try{
      const { rate, date } = await fxFetchFrankfurterUsdEur();
      usdEur = rate;
      fxStoreRate(rate);
      ts = Number(localStorage.getItem(FX_LS_TIME_KEY)) || fxNowMs();

      // Manual-Feld nur überschreiben, wenn leer ODER wenn es exakt der bisherige Auto-Wert war
      // (damit User-Manuell nicht "kaputt" geht)
      const from = fromEl.value, to = toEl.value;
      const eff = fxGetEffectiveRate(from,to,usdEur);

      if(!manualEl.value){
        manualEl.value = String(Math.round(eff*1000000)/1000000).replace(".", ",");
      }

      renderRateStatus(`Stand (Frankfurter/ECB): ${date} (werktags).`);
    }catch(e){
      const fallback = fxGetStoredRate();
      usdEur = fallback.rate;
      ts = fallback.ts;
      renderRateStatus("Konnte online nicht laden → nutze Offline/Cache.");
      showFxErr("Kurs konnte nicht aktualisiert werden (offline?).");
    }
  }

  // 4) Swap
  function fxSwap(){
    const a = fromEl.value;
    fromEl.value = toEl.value;
    toEl.value = a;

    // Manual placeholder neu setzen (nur wenn leer)
    syncManualPlaceholder();
    renderRateStatus();
  }

  // Events
  calcBtn.addEventListener("click", fxConvert);
  refreshBtn.addEventListener("click", fxRefresh);
  swapBtn.addEventListener("click", fxSwap);

  // Wenn User From/To ändert: Rate-Box + (optional) Auto-Manual setzen, wenn leer
  fromEl.addEventListener("change", () => { syncManualPlaceholder(); renderRateStatus(); });
  toEl.addEventListener("change",   () => { syncManualPlaceholder(); renderRateStatus(); });

  // Enter = umrechnen
  [amountEl, manualEl].forEach(el=>{
    el.addEventListener("keydown",(e)=>{
      if(e.key==="Enter" && !e.shiftKey){
        e.preventDefault();
        fxConvert();
      }
    });
  });
}







// ---------- NUTZEN CHECK (55 Spalten + 1 großes Feld) ----------

// 55 Headers (wie von dir gewünscht)
const NUTZEN_HEADERS = [
  // --- Financials ---
  "Revenue (FY)",
  "Revenue Growth 1Y (CAGR)",
  "Revenue Growth 2Y (CAGR)",
  "Revenue Growth 3Y (CAGR)",
  "Revenue Growth 4Y (CAGR)",
  "Revenue Growth 1Y (YoY)",

  "EPS (Diluted, FY)",
  "EPS Growth 1Y (CAGR)",
  "EPS Growth 2Y (CAGR)",
  "EPS Growth 3Y (CAGR)",
  "EPS Growth 4Y (CAGR)",

  "Operating Margin pp 1Y (CAGR)",
  "Operating Margin pp 2Y (CAGR)",
  "Operating Margin pp 3Y (CAGR)",
  "Operating Margin pp 4Y (CAGR)",
  "Operating Margin 1Y",

  "Beta",
  "52 Week Range",
  "Volatilität annualisiert (Std-Abw.) 1Y",
  "Volatilität annualisiert (Std-Abw.) 5Y",
  "Volatilität annualisiert (Std-Abw.) 10Y",

  "FCF 1Y",
  "FCF-Margin",
  "Debt/ FCF",
  "Net Dept/ EBITDA",
  "EBITDA 1Y",
  "EBIDTA Margin 1Y",
  "Interest Expense 1Y",
  "Zinsdeckung (ICR)",
  "ROIC",
  "ROCE",
  "FCF Yield 1Y",
  "Net Income 1Y",
  "Net income positiv (ja/nein)",
  "FCF Positiv (ja/nein)",

  // --- Dividenden ---
  "Dividende (p.a)",
  "Div- Frequency",
  "Div.-Rendite aktuell (%)",
  "Shares out",
  "Repurchase of Common stock",

  "Dividende (DPS) 1Y (CAGR)",
  "Dividende (DPS) 2Y (CAGR)",
  "Dividende (DPS) 3Y (CAGR)",
  "Dividende (DPS) 4Y (CAGR)",
  "Payout Ratio 1Y",
  "FCF-Payout",
  "Dividend Growth Years",
  "Dividend growth",

  // --- Bewertung ---
  "Kurs aktuell",
  "Kurs 1Y (CAGR)",
  "Kurs 2Y (CAGR)",
  "Kurs 3Y (CAGR)",
  "Kurs 4Y (CAGR)",
  "Marktkapitalisierung",
  "KGV (PE Ratio) 1Y",
  "KGV Target",
  "Fairer Preis"
];

// Welche Header gehören zu welcher CAGR-Jahr-Gruppe?



function nutzenYearMeta(header){
  let m;

  // CAGR
  m = header.match(/^Revenue Growth (\d)Y \(CAGR\)$/);
  if(m) return { type:"cagr", group:"rev", year:Number(m[1]) };

  m = header.match(/^EPS Growth (\d)Y \(CAGR\)$/);
  if(m) return { type:"cagr", group:"eps", year:Number(m[1]) };

  m = header.match(/^Operating Margin pp (\d)Y \(CAGR\)$/);
  if(m) return { type:"cagr", group:"opm", year:Number(m[1]) };

  m = header.match(/^Dividende \(DPS\) (\d)Y \(CAGR\)$/);
  if(m) return { type:"cagr", group:"dps", year:Number(m[1]) };

  m = header.match(/^Kurs (\d)Y \(CAGR\)$/);
  if(m) return { type:"cagr", group:"kurs", year:Number(m[1]) };

  // Vol
  m = header.match(/^Volatilität annualisiert \(Std-Abw\.\) (\d+)Y$/);
  if(m) return { type:"vol", group:"vol", year:Number(m[1]) };

  return null;
}



function nutzenGetSelectedCagrYear(){
  const sel = document.getElementById("nutzen_cagrYears");
  const y = sel ? Number(sel.value) : 4;
  return [1,2,3,4].includes(y) ? y : 4;
}

function nutzenGetSelectedVolYear(){
  const sel = document.getElementById("nutzen_volYears");
  const y = sel ? Number(sel.value) : 1;
  return [1,5,10].includes(y) ? y : 1;
}

function nutzenUpdateYearVisibility(){
  const cagrY = nutzenGetSelectedCagrYear();
  const volY  = nutzenGetSelectedVolYear();

  const headRow = document.getElementById("nutzenHeadRow");
  const valRow  = document.getElementById("nutzenValueRow");
  if(!headRow || !valRow) return;

  const headCells = Array.from(headRow.children);
  const valCells  = Array.from(valRow.children);

  for(let i=0;i<NUTZEN_HEADERS.length;i++){
    const th = headCells[i];
    const td = valCells[i];
    if(!th || !td) continue;

    const t = th.dataset.yearType;          // "cagr" | "vol" | undefined
    const y = Number(th.dataset.yearValue); // 1/2/3/4/5/10

    if(!t){
      th.style.display = "";
      td.style.display = "";
      continue;
    }

    if(t === "cagr"){
      const show = (y === cagrY);
      th.style.display = show ? "" : "none";
      td.style.display = show ? "" : "none";
      continue;
    }

    if(t === "vol"){
      const show = (y === volY);
      th.style.display = show ? "" : "none";
      td.style.display = show ? "" : "none";
      continue;
    }
  }
}


// Table initial bauen (Header + eine Value-Row mit 55 Zellen)
function buildNutzenTable(){
  const headRow = document.getElementById("nutzenHeadRow");
  const valRow  = document.getElementById("nutzenValueRow");
  const bigCell = document.getElementById("nutzenBigCell");
  if(!headRow || !valRow) return;

  // colspan sicher setzen
  if(bigCell) bigCell.colSpan = NUTZEN_HEADERS.length;

  headRow.innerHTML = "";
  valRow.innerHTML = "";

  NUTZEN_HEADERS.forEach((h, idx) => {
    const th = document.createElement("th");
    th.textContent = h;
    th.className = "nutzenCell";
    th.dataset.idx = String(idx);

const meta = nutzenYearMeta(h);


if(meta){
  th.dataset.yearType = meta.type;      // "cagr" oder "vol"
  th.dataset.yearGroup = meta.group;    // z.B. "rev" oder "vol"
  th.dataset.yearValue = String(meta.year); // 1/2/3/4/10
}

    headRow.appendChild(th);

    const td = document.createElement("td");
    td.className = "nutzenCell";
    td.dataset.idx = String(idx);
    td.textContent = ""; // leer initial

if(meta){
  td.dataset.yearType  = meta.type;
  td.dataset.yearGroup = meta.group || "";
  td.dataset.yearValue = String(meta.year);
}

    valRow.appendChild(td);
  });
}

// Text in Tokens splitten: Tab (Excel) / ; / Zeilenumbruch
function splitNutzenTokens(raw){
  let s = String(raw ?? "");
  if(!s.trim()) return [];

  s = s.replace(/\r/g, "\n");

  // Wichtig: Bei Excel ist TAB das sichere Trennzeichen.
  // Leere Felder MÜSSEN erhalten bleiben, sonst verrutschen die Spalten!
  if(s.includes("\t")){
    return s.split("\t").map(x => x.trim()); // KEIN filter() !
  }

  // Semikolon-Export: auch hier leere Felder behalten
  if(s.includes(";")){
    return s.split(";").map(x => x.trim()); // KEIN filter() !
  }

  // Fallback: Zeilenweise (hier ignorieren wir echte Leerzeilen)
 // Fallback: Wenn alles in 1 Zeile steht und keine Tabs/; vorhanden sind,
// splitte auf 2+ Spaces (typisch Web-Kopien)
const lines = s.split("\n").map(x => x.trim()).filter(x => x.length>0);

if(lines.length === 1 && /\s{2,}/.test(lines[0])){
  return lines[0].split(/\s{2,}/).map(x => x.trim());
}

// sonst: jede Zeile = 1 Token
return lines;
}



function nutzenGetVisibleIndices(){
  const cagrY = nutzenGetSelectedCagrYear();
  const volY  = nutzenGetSelectedVolYear();

  const idxs = [];
  for(let i=0;i<NUTZEN_HEADERS.length;i++){
    const meta = nutzenYearMeta(NUTZEN_HEADERS[i]);

    if(!meta) { idxs.push(i); continue; }
    if(meta.type === "cagr" && meta.year === cagrY) { idxs.push(i); continue; }
    if(meta.type === "vol"  && meta.year === volY)  { idxs.push(i); continue; }
  }
  return idxs;
}



function nutzenFillValues(tokens){
  const valRow = document.getElementById("nutzenValueRow");
  if(!valRow) return;

  const tds = Array.from(valRow.querySelectorAll("td"));

  // alles erstmal leeren
  for(const td of tds) td.textContent = "";

  const totalCols = tds.length; // 55
  const visibleIdxs = nutzenGetVisibleIndices();

  // Fall A: User liefert exakt 55 Werte -> 1:1
  if(tokens.length >= totalCols){
    for(let i=0;i<totalCols;i++){
      tds[i].textContent = tokens[i] ?? "";
    }
    return;
  }

  // Fall B: User kopiert nur sichtbare Spalten (sehr häufig!)
  // -> Tokens auf sichtbare Indizes mappen, Rest bleibt leer
  for(let j=0;j<visibleIdxs.length;j++){
    const colIndex = visibleIdxs[j];
    tds[colIndex].textContent = tokens[j] ?? "";
  }
}

function nutzenUpdateBigMirror(){
  const ta = document.getElementById("nutzen_big");
  const mirror = document.getElementById("nutzen_bigMirror");
  if(!ta || !mirror) return;
  mirror.textContent = ta.value || "";
}

// Zeigt nur die CAGR-Spalten für das ausgewählte Jahr (1–4)
function nutzenUpdateYearVisibility(){
  const sel = document.getElementById("nutzen_cagrYears");
  if(!sel) return;
  const y = Number(sel.value);

  // Header + Value Zellen synchron aus-/einblenden
  const headRow = document.getElementById("nutzenHeadRow");
  const valRow  = document.getElementById("nutzenValueRow");
  if(!headRow || !valRow) return;

  const headCells = Array.from(headRow.children);
  const valCells  = Array.from(valRow.children);

  for(let i=0;i<NUTZEN_HEADERS.length;i++){
    const th = headCells[i];
    const td = valCells[i];
    if(!th || !td) continue;

    const isCagr = th.dataset.cagrYear && th.dataset.cagrGroup;
    if(!isCagr){
      th.style.display = "";
      td.style.display = "";
      continue;
    }

    const year = Number(th.dataset.cagrYear);
    const show = (year === y);

    th.style.display = show ? "" : "none";
    td.style.display = show ? "" : "none";
  }
}

// UI-Bindings für Nutzen
function bindNutzenUI(){
  // 1) Tabelle bauen (einmalig)
  buildNutzenTable();

  // 2) UI einmal binden (wichtig: NICHT in Klick-Handlern!)
  bindNutzenStressUI();
  bindNutzenOverlayUI();
  bindOverlayActionsUI();

  // 3) Rollenbox initial rendern
  renderNutzenRolesBox();

  // 4) Parse Button
  const parseBtn = document.getElementById("nutzen_parseBtn");
  if(parseBtn){
    parseBtn.addEventListener("click", () => {
      const raw = document.getElementById("nutzen_big")?.value ?? "";
      const tokens = splitNutzenTokens(raw);
      nutzenFillValues(tokens);
      nutzenUpdateYearVisibility();

      // Rollen + Auto-UI (Stress/Fair/Actions) aktualisieren
      renderNutzenRolesBox();
    });
  }

  // 5) Clear Button
  const clrBtn = document.getElementById("nutzen_clearBtn");
  if(clrBtn){
    clrBtn.addEventListener("click", () => {
      const ta2 = document.getElementById("nutzen_big");
      if(ta2) ta2.value = "";
      nutzenUpdateBigMirror();
      nutzenFillValues([]);
      nutzenUpdateYearVisibility();
      renderNutzenRolesBox();
    });
  }

  // 6) CAGR Years Select
  const sel = document.getElementById("nutzen_cagrYears");
  if(sel){
    sel.addEventListener("change", () => {
      nutzenUpdateYearVisibility();
      // optional: wenn du nach Wechsel sofort neu rendern willst:
      // renderNutzenRolesBox();
    });
  }

  const selVol = document.getElementById("nutzen_volYears");
if(selVol){
  selVol.addEventListener("change", () => {
    nutzenUpdateYearVisibility();
    // optional:
    // renderNutzenRolesBox();
  });
}

  // Initial: richtige Sichtbarkeit
  nutzenUpdateYearVisibility();
}



/* ===============================
   OVERLAY: Rollen / Stress / Range
   =============================== */

function nutzenGetTableMap(){
  // Map: Header -> Zelleninhalt (Text)
  const valRow = document.getElementById("nutzenValueRow");
  if(!valRow) return {};

  const cells = Array.from(valRow.querySelectorAll("td"));
  const map = {};
  for(let i=0;i<NUTZEN_HEADERS.length;i++){
    map[NUTZEN_HEADERS[i]] = (cells[i]?.textContent ?? "").trim();
  }
  return map;
}

function nutzenOverlaySetStress(mode){
  const pill = document.getElementById("nutzenOverlayStressPill");
  const txt  = document.getElementById("nutzenOverlayStressText");
  if(!pill || !txt) return;

  pill.classList.remove("statusGreen","statusYellow","statusRed");

  if(mode === "green"){
    pill.classList.add("statusGreen");
    txt.textContent = "Grün (manuell)";
  } else if(mode === "yellow"){
    pill.classList.add("statusYellow");
    txt.textContent = "Gelb (manuell)";
  } else if(mode === "red"){
    pill.classList.add("statusRed");
    txt.textContent = "Rot (manuell)";
  } else {
    txt.textContent = "– (noch nicht berechnet)";
  }
}

/* ===============================
   STRESS FLAG (Nutzen Seite) – UI only
   =============================== */

// Setzt die Pill auf der Nutzen-Seite (keine Logik, nur Anzeige)
function nutzenSetStressUI(mode){
  const pill = document.getElementById("nutzenStressPill");
  const txt  = document.getElementById("nutzenStressText");
  if(!pill || !txt) return;

  pill.classList.remove("statusGreen","statusYellow","statusRed");

  if(mode === "green"){
    pill.classList.add("statusGreen");
    txt.textContent = "Grün (manuell)";
  } else if(mode === "yellow"){
    pill.classList.add("statusYellow");
    txt.textContent = "Gelb (manuell)";
  } else if(mode === "red"){
    pill.classList.add("statusRed");
    txt.textContent = "Rot (manuell)";
  } else {
    txt.textContent = "– (noch nicht berechnet)";
  }
}

// Hält Nutzen-Seite und Overlay in Sync (UI only)
function nutzenSyncStress(mode){
  // 1) Nutzen-Seite setzen
  nutzenSetStressUI(mode);

  // 2) Overlay setzen (deine vorhandene Funktion)
  nutzenOverlaySetStress(mode);

  // 3) Selects synchronisieren (falls vorhanden)
  const selMain = document.getElementById("nutzenStressSelect");
  const selOv   = document.getElementById("nutzenOverlayStressSelect");

  if(selMain && selMain.value !== mode) selMain.value = mode;
  if(selOv   && selOv.value   !== mode) selOv.value = mode;

  // Placeholder-Text (optional)
  const whyMain = document.getElementById("nutzenStressWhy");
  const whyOv   = document.getElementById("nutzenOverlayStressWhy");

  const whyTxt = (mode === "auto")
    ? "Noch keine Begründung hinterlegt."
    : "Manuell gesetzt (UI-Test) – Regeln kommen später.";

  if(whyMain) whyMain.textContent = whyTxt;
  if(whyOv)   whyOv.textContent   = whyTxt;
}

function bindNutzenStressUI(){
  const selMain = document.getElementById("nutzenStressSelect");
  const selOv   = document.getElementById("nutzenOverlayStressSelect");

  // default
  nutzenSyncStress("auto");

  if(selMain){
    selMain.addEventListener("change", () => {
      const v = selMain.value;
      nutzenSyncStress((v==="green"||v==="yellow"||v==="red") ? v : "auto");
    });
  }

  if(selOv){
    selOv.addEventListener("change", () => {
      const v = selOv.value;
      nutzenSyncStress((v==="green"||v==="yellow"||v==="red") ? v : "auto");
    });
  }
}





function nutzenOverlayFillRangeBase(){
  const tbody = document.getElementById("nutzenOverlayRangeBase");
  if(!tbody) return;

  const ev = nutzenEvaluateAll(); // nutzt deine echte Berechnung
  const m = ev.map;

  const p52 = nzParse52w(m["52 Week Range"]);
  const baseRows = [
    ["Kurs aktuell", m["Kurs aktuell"] || "–"],
    ["Fairer Preis", m["Fairer Preis"] || (Number.isFinite(ev.fair)? ev.fair.toFixed(2):"–")],
    ["KGV Target", m["KGV Target"] || "–"],
    ["KGV (PE Ratio) 1Y", m["KGV (PE Ratio) 1Y"] || "–"],
    ["Beta", m["Beta"] || "–"],
    ["52W Low", Number.isFinite(p52.low) ? nzFmtPrice(p52.low) : "–"],
    ["52W High", Number.isFinite(p52.high) ? nzFmtPrice(p52.high) : "–"],
    ["Volatilität 1Y", m["Volatilität annualisiert (Std-Abw.) 1Y"] || "–"],
    ["Stress (Auto)", (ev.stress?.mode || "–").toUpperCase()],
  ];

  // Kauf-Ranges berechnen
  const bandsRes = nutzenComputeBuyBands(ev);

  let bandsRows = [];
  let explainTxt = "";

  if(bandsRes.ok){
    const b = bandsRes.bands;

    const price = (mult)=> (mult===Infinity) ? Infinity : (ev.fair * mult);

    const rowBand = (label, lo, hi) => {
      const loP = (lo===0) ? 0 : price(lo);
      const hiP = price(hi);

      const rangeStr =
        (hi === Infinity)
          ? `> ${nzFmtPrice(loP)}`
          : `${nzFmtPrice(loP)} – ${nzFmtPrice(hiP)}`;

      const multStr =
        (hi === Infinity)
          ? `> ${(lo*100).toFixed(0)}% von Fair`
          : `${(lo*100).toFixed(0)}–${(hi*100).toFixed(0)}% von Fair`;

      return [label, `${rangeStr}  (${multStr})`];
    };

    bandsRows = [
      ["— Kauf-Ranges (auto) —", ""],
      rowBand("Nachkaufen (Strong Buy)", b.strongBuy.lo, b.strongBuy.hi),
      rowBand("Kaufen (Buy)",            b.buy.lo,       b.buy.hi),
      rowBand("Halten (Hold)",           b.hold.lo,      b.hold.hi),
      rowBand("Teuer (Wait/Trim)",       b.expensive.lo, b.expensive.hi),
      rowBand("Sehr teuer",              b.veryExp.lo,   b.veryExp.hi),
    ];

    explainTxt = bandsRes.explain;
  } else {
    bandsRows = [
      ["— Kauf-Ranges (auto) —", ""],
      ["Hinweis", "Fair Value fehlt → keine Ranges berechenbar."]
    ];
    explainTxt = bandsRes.explain || "";
  }

  // Render
  const esc = (x)=> String(x).replace(/</g,"&lt;").replace(/>/g,"&gt;");
  const allRows = [...baseRows, ...bandsRows];

  tbody.innerHTML = allRows.map(r => `
    <tr>
      <td>${esc(r[0])}</td>
      <td><b>${esc(r[1])}</b></td>
    </tr>
  `).join("");

  // Erklärungstext (falls du ein Feld dafür hast)
  const explainEl = document.getElementById("nutzenOverlayRangeExplain");
  if(explainEl){
    explainEl.textContent = explainTxt;
  } else {
    // fallback: als zusätzliche Zeile unten
    if(explainTxt){
      tbody.innerHTML += `
        <tr>
          <td>Begründung</td>
          <td><span class="muted">${esc(explainTxt)}</span></td>
        </tr>
      `;
    }
  }
}








function closeNutzenOverlay(){
  const ov = document.getElementById("nutzenOverlay");
  const bd = document.getElementById("nutzenOverlayBackdrop");
  if(!ov || !bd) return;

  bd.style.display = "none";
  ov.style.display = "none";
  ov.setAttribute("aria-hidden","true");
}


// Wichtig: wird erst gebunden, wenn Nutzen-UI gebunden ist
// -> wir rufen es am Ende von bindNutzenUI() auf


/* ===============================
   ROLLEN-KATALOG (nur UI)
   =============================== */

// Alle Rollen, die du genannt hast (ohne Vergabe-Logik)
const NUTZEN_ROLE_CATALOG = [
  "Dividenden-Aristokrat",
  "Dividenden-Wachstum",
  "High Dividend",
  "Value",
  "Wachstum",
  "Quality",
  "GARP (Wachstum, preis ist nicht teuer)",
  "Turnaround",
  "Zykliker",
  "Spekulation",
  "Krisenfall",
  "Small Cap",
  "Mid Cap",
  "Large Cap",
  "Defensiv",
  "Stabil defensiv"
];



function roleBadgeHtml(st){
  if(st === "on")  return `<span class="roleBadge ok">✅ aktiv</span>`;
  if(st === "warn") return `<span class="roleBadge mid">⚠️ aktiv</span>`;
  if(st === "off") return `<span class="roleBadge bad">❌ nicht</span>`;
  return `<span class="roleBadge">… offen</span>`;
}


/* ===============================
   OVERLAY: Fairer Preis / Kaufen / Nachkaufen – UI only
   =============================== */

function ovGetEl(id){ return document.getElementById(id); }

function ovRenderActionsSummary(){
  const fp = ovGetEl("ov_fairPrice")?.value;
  const cp = ovGetEl("ov_currentPrice")?.value;
  const buy = ovGetEl("ov_buySelect")?.value || "auto";
  const add = ovGetEl("ov_addSelect")?.value || "auto";
  const out = ovGetEl("ov_actionSummary");
  if(!out) return;

  const tBuy = (buy==="auto") ? "Kaufen: Auto" : (buy==="yes" ? "Kaufen: Ja" : buy==="maybe" ? "Kaufen: Vielleicht" : "Kaufen: Nein");
  const tAdd = (add==="auto") ? "Nachkaufen: Auto" : (add==="yes" ? "Nachkaufen: Ja" : add==="maybe" ? "Nachkaufen: Vielleicht" : "Nachkaufen: Nein");

  const tFP = fp ? `Fairer Preis: ${fp}` : "Fairer Preis: –";
  const tCP = cp ? `Kurs: ${cp}` : "Kurs: –";

  out.textContent = `${tFP} | ${tCP} | ${tBuy} | ${tAdd}`;
}




/* =========================================
   1) HELPERS: Parsing / Utilities
   ========================================= */

function nzStr(x){ return (x ?? "").toString().trim(); }

function nzNum(raw){
  // akzeptiert "1.234,56", "1234.56", "12%", "–"
  let s = nzStr(raw);
  if(!s || s === "–" || s === "-" ) return NaN;
  s = s.replace(/\s/g,"");
  // Prozent raus (separat gibt es nzPct)
  s = s.replace("%","");
  // deutsche Zahl -> Punkt als Tausender, Komma als Dezimal
  // wenn beides vorkommt, sehr wahrscheinlich DE-Format
  if(s.includes(",") && s.includes(".")){
    s = s.replace(/\./g,"").replace(",",".");
  } else if(s.includes(",")){
    s = s.replace(",",".");
  }
  // K/M/B/T Shortcuts (optional)
  const m = s.match(/^(-?\d+(?:\.\d+)?)([kKmMbBtT])$/);
  if(m){
    const v = Number(m[1]);
    const u = m[2].toLowerCase();
    const mul = (u==="k")?1e3:(u==="m")?1e6:(u==="b")?1e9:1e12;
    return v * mul;
  }
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}

function nzPct(raw){
  // "12,3%" => 12.3 (Prozentpunkte)
  const n = nzNum(raw);
  return Number.isFinite(n) ? n : NaN;
}

function nzYesNo(raw){
  const s = nzStr(raw).toLowerCase();
  if(["ja","yes","true","1","y"].includes(s)) return true;
  if(["nein","no","false","0","n"].includes(s)) return false;
  return null; // unbekannt
}

function nzRangePct(raw){
  // "52 Week Range" kann sein: "100 - 200" oder "100–200" oder "100 / 200"
  const s = nzStr(raw);
  if(!s) return NaN;
  const parts = s.split(/[-–\/]/).map(x=>nzNum(x)).filter(n=>Number.isFinite(n));
  if(parts.length < 2) return NaN;
  const lo = Math.min(parts[0], parts[1]);
  const hi = Math.max(parts[0], parts[1]);
  if(lo <= 0) return NaN;
  return (hi - lo) / lo; // z.B. 0.50 = 50%
}

function nzClamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

function nzSelectedCagrYear(){
  const sel = document.getElementById("nutzen_cagrYears");
  const y = sel ? Number(sel.value) : 4;
  return [1,2,3,4].includes(y) ? y : 4;
}

/* =========================================
   2) CORE: Evaluate (Roles + Stress + Fair + Actions)
   ========================================= */

function nutzenComputeFairPrice(m){
  // 1) wenn Fairer Preis befüllt -> nehmen
  const fairGiven = nzNum(m["Fairer Preis"]);
  if(Number.isFinite(fairGiven) && fairGiven > 0) return fairGiven;

  // 2) sonst EPS * KGV Target (wenn möglich)
  const eps = nzNum(m["EPS (Diluted, FY)"]);
  const peT = nzNum(m["KGV Target"]);
  if(Number.isFinite(eps) && eps > 0 && Number.isFinite(peT) && peT > 0){
    return eps * peT;
  }
  return NaN;
}

function nutzenComputeActions(m, fair){
  const current = nzNum(m["Kurs aktuell"]);
  if(!Number.isFinite(current) || current <= 0 || !Number.isFinite(fair) || fair <= 0){
    return { buy:"auto", add:"auto", why:["Zu wenig Daten (Kurs/Fair fehlen)."] };
  }
  const discount = (fair - current) / fair; // 0.20 => 20% unter fair

  // simple, robuste Heuristik
  // buy: >=15% unter fair => Ja, 5-15% => Vielleicht, sonst Nein
  let buy = "no";
  if(discount >= 0.15) buy = "yes";
  else if(discount >= 0.05) buy = "maybe";

  // add (nachkaufen): tieferer Discount
  let add = "no";
  if(discount >= 0.25) add = "yes";
  else if(discount >= 0.12) add = "maybe";

  return {
    buy, add,
    why: [
      `Fair ≈ ${fair.toFixed(2)} | Kurs ≈ ${current.toFixed(2)} | Discount ≈ ${(discount*100).toFixed(1)}%`
    ]
  };
}


function nzParse52w(raw){
  // liefert {low, high} oder {low:NaN, high:NaN}
  const s = nzStr(raw);
  if(!s) return { low: NaN, high: NaN };

  const parts = s.split(/\s*[-–\/]\s*/).map(x => x.trim());
  if(parts.length < 2) return { low: NaN, high: NaN };

  const a = nzNum(parts[0]);
  const b = nzNum(parts[1]);
  if(!Number.isFinite(a) || !Number.isFinite(b)) return { low: NaN, high: NaN };

  return { low: Math.min(a, b), high: Math.max(a, b) };
}

function nzFmtPrice(x){
  return Number.isFinite(x) ? x.toFixed(2) : "–";
}

/**
 * Kauf-Bands:
 * - Baseline: Strong Buy <= 0.75*Fair, Buy 0.75–0.90, Hold 0.90–1.10, Teuer 1.10–1.25, Sehr teuer >1.25
 * - Dynamisch: bei Stress/Vol werden die Buy-Zonen "strenger" (mehr Sicherheitsmarge)
 */
function nutzenComputeBuyBands(ev){
  const fair = ev?.fair;
  if(!Number.isFinite(fair) || fair <= 0){
    return {
      ok:false,
      bands:null,
      explain:"Keine Kauf-Ranges: Fair Value fehlt (oder ist 0)."
    };
  }

  const vol = nzPct(ev.map?.["Volatilität annualisiert (Std-Abw.) 1Y"]);
  const stress = (ev?.stress?.mode || "green"); // green/yellow/red

  // ---- Baseline Multiples ----
  let strongBuyMax = 0.75;
  let buyMax       = 0.90;
  let holdMax      = 1.10;
  let expensiveMax = 1.25;

  // ---- Risiko-Anpassung (warum):
  // Höhere Unsicherheit (gelb/rot) oder hohe Volatilität -> größere Sicherheitsmarge -> Buy-Zonen tiefer.
  // Niedrige Unsicherheit -> leicht weniger strenge Marge möglich.
  let shift = 0; // wie stark wir nach unten verschieben

  if(stress === "red") shift += 0.08;
  else if(stress === "yellow") shift += 0.04;

  if(Number.isFinite(vol)){
    if(vol >= 60) shift += 0.06;
    else if(vol >= 45) shift += 0.04;
    else if(vol <= 30 && stress === "green") shift -= 0.02; // stabiler => minimal weniger streng
  }

  // Clamp: nicht zu extrem
  shift = nzClamp(shift, -0.03, 0.18);

  strongBuyMax = nzClamp(strongBuyMax - shift, 0.55, 0.85);
  buyMax       = nzClamp(buyMax       - shift, strongBuyMax + 0.05, 0.98);

  // Hold/Expensive lassen wir bewusst stabil:
  // Warum: Über Fair werden die Signale ohnehin schwächer, zu viel Dynamik macht's unruhig.
  // Optional könntest du bei rot auch holdMax leicht senken – ich lasse es erstmal simpel/robust.

  const bands = {
    strongBuy: { lo: 0,              hi: strongBuyMax },
    buy:       { lo: strongBuyMax,   hi: buyMax },
    hold:      { lo: buyMax,         hi: holdMax },
    expensive: { lo: holdMax,        hi: expensiveMax },
    veryExp:   { lo: expensiveMax,   hi: Infinity }
  };

  const explain =
    `Baseline (Fair-Multiples): Nachkaufen ≤0,75×, Kaufen 0,75–0,90×, Halten 0,90–1,10×, Teuer 1,10–1,25×.\n` +
    `Anpassung: shift=${(shift*100).toFixed(0)}%-Pkt (Stress=${stress}${Number.isFinite(vol)?`, Vol=${vol.toFixed(1)}%`:""}). ` +
    `Mehr Risiko ⇒ größere Sicherheitsmarge ⇒ Buy-Zonen tiefer.`;

  return { ok:true, bands, explain };
}



/* ===========================
   Extra helpers (neu)
   =========================== */

function nzLower(raw){ return nzStr(raw).toLowerCase(); }

function nzIsRegularDividend(freqRaw){
  // akzeptiert: "quarterly", "quartalsweise", "monthly", "jährlich" etc.
  const s = nzLower(freqRaw);
  if(!s) return false;
  // "stabil regelmäßig" ist nicht messbar -> wir nehmen typische Muster
  return (
    s.includes("quart") || s.includes("quarter") ||
    s.includes("monat") || s.includes("month") ||
    s.includes("halb")  || s.includes("semi")  ||
    s.includes("jähr")  || s.includes("year")  ||
    s.includes("annual")
  );
}

function nzIsPeUsable(pe){
  return Number.isFinite(pe) && pe > 0 && pe < 2000; // sehr grob, aber verhindert Quatsch
}







/* =========================================
   STRESS / KRISENFALL (ersetzt deine Funktion)
   ========================================= */

function nutzenComputeStress(m){
  const triggers = [];

  const netIncomePos = nzYesNo(m["Net income positiv (ja/nein)"]);
  const fcfPos       = nzYesNo(m["FCF Positiv (ja/nein)"]);

  const icr          = nzNum(m["Zinsdeckung (ICR)"]);
  const netDebtEbitda= nzNum(m["Net Dept/ EBITDA"]);
  const debtFcf      = nzNum(m["Debt/ FCF"]);

  const opm1y        = nzPct(m["Operating Margin 1Y"]);
  const fcfMargin    = nzPct(m["FCF-Margin"]);

  const vol          = nzPct(m["Volatilität annualisiert (Std-Abw.) 1Y"]);
  const beta         = nzNum(m["Beta"]);
  const revYoy       = nzPct(m["Revenue Growth 1Y (YoY)"]);

  const roic         = nzPct(m["ROIC"]);
  const roce         = nzPct(m["ROCE"]);


  // helpers
  const icrBad1   = Number.isFinite(icr) && icr > 0 && icr < 1;
  const icr1to6   = Number.isFinite(icr) && icr >= 1 && icr < 6;

  const ndeHigh25to4 = Number.isFinite(netDebtEbitda) && netDebtEbitda > 2.5 && netDebtEbitda <= 4;
  const ndeOver5     = Number.isFinite(netDebtEbitda) && netDebtEbitda > 5;
  const ndeNotSane   = !Number.isFinite(netDebtEbitda); // "nicht sinnvoll" / fehlt

  const debtFcf6to12 = Number.isFinite(debtFcf) && debtFcf > 6 && debtFcf <= 12;
  const debtFcfOver12= Number.isFinite(debtFcf) && debtFcf > 12;
  const debtFcfNotSane = !Number.isFinite(debtFcf)  || debtFcf <= 0;; // "nicht sinnvoll" / fehlt

  const opm0to10  = Number.isFinite(opm1y) && opm1y >= 0 && opm1y <= 10;
  const opmNeg    = Number.isFinite(opm1y) && opm1y < 0;

  const vol35to60 = Number.isFinite(vol) && vol >= 35 && vol < 60;
  const vol60plus = Number.isFinite(vol) && vol >= 60;

  const beta13to18= Number.isFinite(beta) && beta >= 1.3 && beta < 1.8;
  const beta18plus= Number.isFinite(beta) && beta >= 1.8;

  const revNeg    = Number.isFinite(revYoy) && revYoy < 0;
  const revVeryNeg= Number.isFinite(revYoy) && revYoy <= -5;

  const fcfWeakMargin = (fcfPos === true) && Number.isFinite(fcfMargin) && fcfMargin < 5;

  // ------------------------
  // ROT (Krisenfall)
  // ------------------------
  // Basis: NetIncome negativ + FCF negativ + mind. 1 harter Trigger
  const hardRed =
    icrBad1 ||
    ndeOver5 || ndeNotSane ||
    debtFcfOver12 || debtFcfNotSane ||
    opmNeg;

  const isRedBase = (netIncomePos === false) && (fcfPos === false) && hardRed;

  // optional Rot-Plus (nur als Trigger-Hinweis)
  const isRedPlus = isRedBase && revVeryNeg && vol60plus;

  if(isRedBase){
    if(netIncomePos === false) triggers.push("Net Income negativ");
    if(fcfPos === false) triggers.push("FCF negativ");
    if(icrBad1) triggers.push("ICR < 1");
    if(ndeOver5) triggers.push("Net Debt/EBITDA > 5");
    if(ndeNotSane) triggers.push("Net Debt/EBITDA nicht sinnvoll/fehlt");
    if(debtFcfOver12) triggers.push("Debt/FCF > 12 (extrem)");
    if(debtFcfNotSane) triggers.push("Debt/FCF nicht sinnvoll/fehlt");
    if(opmNeg) triggers.push("Operating Margin < 0%");
    if(isRedPlus) triggers.push("Rot-Plus: Revenue YoY ≤ -5% & Vol ≥ 60%");
    return { mode:"red", triggers };
  }

  // ------------------------
  // GRÜN (alle Kernkriterien erfüllt)
  // ------------------------
  const greenCore =
    (netIncomePos === true) &&
    (fcfPos === true) &&
    (Number.isFinite(icr) && icr >= 6) &&
    (Number.isFinite(netDebtEbitda) && netDebtEbitda <= 2.5) &&
    (Number.isFinite(debtFcf) && debtFcf <= 6) &&
    (Number.isFinite(opm1y) && opm1y > 10) &&
    (Number.isFinite(vol) && vol <= 35) &&
    (Number.isFinite(beta) && beta <= 1.3);

  const greenOptionalQuality =
    (Number.isFinite(roic) && roic >= 10) || (Number.isFinite(roce) && roce >= 12);

  if(greenCore){
    // optionaler Hinweis
    if(greenOptionalQuality) triggers.push("Qualitäts-Plus: ROIC/ROCE ok");
    return { mode:"green", triggers };
  }

  // ------------------------
  // GELB (nicht Rot) + Trigger
  // ------------------------
  // mindestens 1 (besser 2) Trigger aus deiner Liste
  let yellowCount = 0;

  if(icr1to6){ triggers.push("ICR 1 bis < 6"); yellowCount++; }
  if(ndeHigh25to4){ triggers.push("Net Debt/EBITDA > 2,5 bis 4"); yellowCount++; }
  if(debtFcf6to12){ triggers.push("Debt/FCF > 6 bis 12"); yellowCount++; }
  if(debtFcfNotSane){ triggers.push("Debt/FCF nicht sinnvoll (FCF sehr klein/fehlt)"); yellowCount++; }
  if(opm0to10){ triggers.push("Operating Margin 0 bis 10%"); yellowCount++; }
  if(fcfWeakMargin){ triggers.push("FCF positiv, aber FCF-Marge < 5%"); yellowCount++; }
  if(vol35to60){ triggers.push("Volatilität 35% bis 60%"); yellowCount++; }
  if(beta13to18){ triggers.push("Beta 1,3 bis 1,8"); yellowCount++; }
  if(revNeg){ triggers.push("Revenue YoY < 0%"); yellowCount++; }

  if(yellowCount >= 1){
    return { mode:"yellow", triggers };
  }

  // ------------------------
  // Fallback: eher Grün wenn nichts auffällig, sonst Gelb
  // (hier: wenn Daten fehlen, lieber Gelb)
  // ------------------------
  const missingCore =
    (netIncomePos === null) || (fcfPos === null) ||
    !Number.isFinite(icr) || !Number.isFinite(netDebtEbitda) || !Number.isFinite(debtFcf);

  if(missingCore){
    return { mode:"yellow", triggers:["Zu wenig Daten für eindeutiges Grün/Rot."] };
  }

  return { mode:"green", triggers:["Keine Stress-Trigger erkannt."] };
}







/* =========================================
   ROLES (ersetzt deine Funktion)
   ========================================= */

function nutzenComputeRoles(m){
  const y = nzSelectedCagrYear();

  function fmtPct(x){ return Number.isFinite(x) ? `${x.toFixed(1)}%` : "–"; }
  function fmtNum(x){ return Number.isFinite(x) ? `${x.toFixed(2)}` : "–"; }
  function okLine(ok, txt){ return `${ok ? "✅" : "❌"} ${txt}`; }
  function unkLine(txt){ return `… ${txt}`; }


  function chk(label, ok, missing=false){
  return { label, ok, missing };
}

function buildWhy(checks){
  // Checklist für ON/OFF: zeigt immer alle Punkte
  return checks.map(c => {
    const icon = c.missing ? "…" : (c.ok ? "✅" : "❌");
    return `${icon} ${c.label}`;
  });
}

// true/false/fehlend sauber unterscheiden
function okOrMissing(isOk, isMissing){
  if(isMissing) return { ok:false, missing:true };
  return { ok: !!isOk, missing:false };
}


function has(x){ return Number.isFinite(x); } // nur Kurzform

  // Wachstumsfelder (für Wachstum/GARP etc. nimm IMMER 4Y nach deiner Vorgabe)
  const revCagr4 = nzPct(m["Revenue Growth 4Y (CAGR)"]);
  const epsCagr4 = nzPct(m["EPS Growth 4Y (CAGR)"]);
  const revYoy   = nzPct(m["Revenue Growth 1Y (YoY)"]);

  const dpsCagr4 = nzPct(m["Dividende (DPS) 4Y (CAGR)"]);
  const divYears = nzNum(m["Dividend Growth Years"]);
  const divYield = nzPct(m["Div.-Rendite aktuell (%)"]);
  const payout   = nzPct(m["Payout Ratio 1Y"]);
  const fcfPayout = nzPct(m["FCF-Payout"]);
  const divFreq  = nzStr(m["Div- Frequency"]);
  const divGrowthTxt = nzLower(m["Dividend growth"]); // falls dort "cut" / "negativ" o.ä. steht

  const pe  = nzNum(m["KGV (PE Ratio) 1Y"]);
  const fair = nutzenComputeFairPrice(m);
  const current = nzNum(m["Kurs aktuell"]);

  const fcfYield = nzPct(m["FCF Yield 1Y"]);
  const fcfMargin = nzPct(m["FCF-Margin"]);
  const opm1y = nzPct(m["Operating Margin 1Y"]);
  const opmCagr4 = nzPct(m["Operating Margin pp 4Y (CAGR)"]);

  const roic = nzPct(m["ROIC"]);
  const roce = nzPct(m["ROCE"]);

  const debtFcf = nzNum(m["Debt/ FCF"]);
  const netDebtEbitda = nzNum(m["Net Dept/ EBITDA"]);
  const icr = nzNum(m["Zinsdeckung (ICR)"]);

  const beta = nzNum(m["Beta"]);
  const vol  = nzPct(m["Volatilität annualisiert (Std-Abw.) 1Y"]);
  const rangePct = nzRangePct(m["52 Week Range"]);

  const netIncomePos = nzYesNo(m["Net income positiv (ja/nein)"]);
  const fcfPos = nzYesNo(m["FCF Positiv (ja/nein)"]);

  const mcap = nzNum(m["Marktkapitalisierung"]);

  const peUsable = nzIsPeUsable(pe);

  // Margin of Safety (fair/current)
  const mosOk = (Number.isFinite(fair) && fair > 0 && Number.isFinite(current) && current > 0)
    ? (current <= 0.85 * fair) : false;
  const mosOk90 = (Number.isFinite(fair) && fair > 0 && Number.isFinite(current) && current > 0)
    ? (current <= 0.90 * fair) : false;

  // Dividend sanity (Yield-Trap Filter)
  const payoutOk = !Number.isFinite(payout) || payout <= 100; // wenn fehlt -> nicht blocken
  const fcfPayoutOk = !Number.isFinite(fcfPayout) || fcfPayout <= 80;
  const fcfMustBePos = (fcfPos !== false);

  const regularDiv = nzIsRegularDividend(divFreq);

  // Dividend growth text check (optional, wenn du da "negativ" reinschreibst)
  const divGrowthLooksBad = divGrowthTxt.includes("cut") || divGrowthTxt.includes("kürz") || divGrowthTxt.includes("negativ") || divGrowthTxt.includes("stop");

  // --- Rollen nach deinen Regeln ---

  // Dividenden-Aristokrat
  const isAristocrat =
    (Number.isFinite(divYears) && divYears >= 25) &&
    regularDiv &&
    (Number.isFinite(dpsCagr4) ? dpsCagr4 > 0 : true) &&
    (Number.isFinite(payout) ? (payout >= 30 && payout <= 70) : true) &&
    (Number.isFinite(fcfPayout) ? fcfPayout <= 80 : true) &&
    (fcfPos !== false) &&
    (netIncomePos !== false) &&
    (Number.isFinite(debtFcf) ? debtFcf < 8 : true) &&
    (Number.isFinite(icr) ? icr > 4 : true) &&
    (Number.isFinite(beta) ? beta < 1.2 : true);

  // Dividenden-Wachstum
  const isDivGrowth =
    (Number.isFinite(divYears) && divYears >= 5) &&
    (Number.isFinite(dpsCagr4) && dpsCagr4 >= 5) &&
    !divGrowthLooksBad &&
    (Number.isFinite(payout) ? (payout >= 25 && payout <= 60) : true) &&
    (Number.isFinite(fcfPayout) ? fcfPayout <= 70 : true) &&
    (fcfPos !== false) &&
    (netIncomePos !== false) &&
    (Number.isFinite(revCagr4) ? revCagr4 >= 3 : true) &&
    (Number.isFinite(epsCagr4) ? epsCagr4 >= 5 : true) &&
    (Number.isFinite(debtFcf) ? debtFcf < 8 : true) &&
    (Number.isFinite(icr) ? icr > 4 : true);

  // High Dividend (+ Yield-Trap Filter)
  const isHighDividend =
    (Number.isFinite(divYield) && divYield >= 4) &&
    regularDiv &&
    payoutOk &&
    (Number.isFinite(payout) ? payout <= 80 : true) &&
    fcfPayoutOk &&
    fcfMustBePos &&
    (netIncomePos !== false) &&
    (Number.isFinite(debtFcf) ? debtFcf < 10 : true) &&
    (Number.isFinite(icr) ? icr > 3 : true);

  // Value
  const isValue =
    (
      (peUsable && pe <= 18) ||
      mosOk ||
      (Number.isFinite(fcfYield) && fcfYield >= 5)
    ) &&
    (fcfPos !== false) &&
    (netIncomePos !== false) &&
    (
      (Number.isFinite(roic) && roic >= 10) ||
      (Number.isFinite(roce) && roce >= 10)
    ) &&
    (Number.isFinite(netDebtEbitda) ? netDebtEbitda < 3 : true) &&
    (Number.isFinite(debtFcf) ? debtFcf < 8 : true) &&
    (Number.isFinite(opm1y) ? opm1y > 0 : true);

  // Wachstum
  const isGrowth =
    (Number.isFinite(revCagr4) && revCagr4 >= 10) &&
    (Number.isFinite(revYoy) ? revYoy >= 8 : true) &&
    (Number.isFinite(epsCagr4) ? epsCagr4 >= 12 : (netIncomePos !== false && fcfPos !== false)) &&
    (Number.isFinite(opm1y) ? opm1y > 0 : true) &&
    (fcfPos !== false) &&
    (Number.isFinite(fcfMargin) ? fcfMargin >= 5 : true) &&
    (
      (Number.isFinite(roic) && roic >= 10) ||
      (Number.isFinite(roce) && roce >= 10)
    );

  // Quality
  const isQuality =
    (
      (Number.isFinite(roic) && roic >= 12) &&
      (Number.isFinite(roce) ? roce >= 12 : true)
    ) &&
    (Number.isFinite(opm1y) ? opm1y >= 15 : true) &&
    (Number.isFinite(opmCagr4) ? opmCagr4 >= 0 : true) &&
    (fcfPos !== false) &&
    (Number.isFinite(fcfMargin) ? fcfMargin >= 10 : true) &&
    (netIncomePos !== false) &&
    (Number.isFinite(netDebtEbitda) ? netDebtEbitda <= 3 : true) &&
    (Number.isFinite(debtFcf) ? debtFcf <= 6 : true) &&
    (Number.isFinite(icr) ? icr > 6 : true) &&
    (Number.isFinite(beta) ? beta <= 1.2 : true);

  // GARP
  const isGarp =
    (Number.isFinite(revCagr4) && revCagr4 >= 8) &&
    (Number.isFinite(epsCagr4) && epsCagr4 >= 10) &&
    (Number.isFinite(opm1y) ? opm1y >= 10 : true) &&
    (
      (Number.isFinite(roic) && roic >= 10) ||
      (Number.isFinite(roce) && roce >= 10)
    ) &&
    (fcfPos !== false) &&
    (Number.isFinite(fcfMargin) ? fcfMargin >= 5 : true) &&
    (
      (peUsable ? pe <= 30 : true) ||
      mosOk90
    ) &&
    (Number.isFinite(netDebtEbitda) ? netDebtEbitda <= 3 : true) &&
    (Number.isFinite(icr) ? icr > 5 : true);


    // ===========================
// Turnaround Inputs (optional)
// ===========================

// Net Income / FCF Zeitreihe (wenn du sie in der Tabelle hast; sonst NaN)
const netIncome1 = nzNum(m["Net Income 1Y"]);
const netIncome2 = nzNum(m["Net Income 2Y"]);

const fcf1 = nzNum(m["FCF 1Y"]);
const fcf2 = nzNum(m["FCF 2Y"]);
const fcf3 = nzNum(m["FCF 3Y"]);
const fcf4 = nzNum(m["FCF 4Y"]);

const fcfMargin1 = nzPct(m["FCF-Margin 1Y"]);
const fcfMargin2 = nzPct(m["FCF-Margin 2Y"]);

// Operating Margin Vorjahr (du nutzt opmPrev im Trendvergleich)
const opmPrev = nzPct(m["Operating Margin 2Y"]);

// EPS (FY) und Vorjahr
const epsFY     = nzNum(m["EPS (Diluted, FY)"]);
const epsPrevFY = nzNum(m["EPS (Diluted, FY-1)"]);

// EPS YoY 1Y (wird in Turnaround schon gebraucht)
const epsYoy1 = nzPct(m["EPS Growth 1Y (YoY)"]);
const epsYoy2 = nzPct(m["EPS Growth 2Y (YoY)"]);
const epsYoy3 = nzPct(m["EPS Growth 3Y (YoY)"]);
const epsYoy4 = nzPct(m["EPS Growth 4Y (YoY)"]);

// ICR Vorjahr
const icrPrev = nzNum(m["Zinsdeckung (ICR) 2Y"]);

// Leverage Vorjahr (optional)
const ndePrev = nzNum(m["Net Dept/ EBITDA 2Y"]);
const dcfPrev = nzNum(m["Debt/ FCF 2Y"]);

// =====================
// Turnaround (neu)
// ====================



// Helper: Trend “hoch” (steigend) bei Zahlwerten
function trendUp(a, b){
  // a = aktueller, b = vorheriger
  if(!Number.isFinite(a) || !Number.isFinite(b)) return { ok:false, missing:true };
  return { ok: a > b, missing:false };
}

// Helper: “negativ -> weniger negativ” (z.B. -10 -> -2)
function lessNegative(a, b){
  if(!Number.isFinite(a) || !Number.isFinite(b)) return { ok:false, missing:true };
  // a aktueller, b vorher
  return { ok: (b < 0 && a < 0 && a > b), missing:false };
}

// Helper: “von negativ zu positiv”
function flippedToPositive(a, b){
  if(!Number.isFinite(a) || !Number.isFinite(b)) return { ok:false, missing:true };
  return { ok: (b < 0 && a > 0), missing:false };
}

// 52W Low/High (für “vom Tief erholt”)
const r52 = nzParse52w(m["52 Week Range"]);
const nearLow = (Number.isFinite(current) && Number.isFinite(r52.low) && Number.isFinite(r52.high))
  ? (current <= r52.low * 1.10)  // nahe Tief (≤ +10%)
  : null;
const reboundFromLow = (Number.isFinite(current) && Number.isFinite(r52.low))
  ? (current >= r52.low * 1.25)  // ≥ +25% vom Tief
  : null;

// --- Kernidee Turnaround nach deiner Definition ---e
// 1) Ausgangslage: NI oder FCF war “schlecht” (negativ) ODER ist aktuell noch schlecht
const wasBadNow =
  (netIncomePos === false) || (fcfPos === false);

// 2) “Drehung / Verbesserung” Signale (Trend)
const niFlip = flippedToPositive(netIncome1, netIncome2);        // - -> +
const niLessNeg = lessNegative(netIncome1, netIncome2);          // -10 -> -2
const fcfFlip = flippedToPositive(fcf1, fcf2);                   // - -> +
const fcfLessNeg = lessNegative(fcf1, fcf2);
const fcfMarginUp = trendUp(fcfMargin1, fcfMargin2);

const opmUp = trendUp(opm1y, opmPrev);                           // Marge steigt ggü. Vorjahr
const opmTurning = (Number.isFinite(opmCagr4) ? (opmCagr4 > 0) : null); // 4Y(CAGR) dreht positiv (oder weniger negativ → wenn du willst, kannst du hier auch "> -1" erlauben)
const revBackPos = (Number.isFinite(revYoy) ? (revYoy > 0) : null);

// EPS dreht: entweder YoY positiv ODER FY besser als FY-1 ODER FY > 0 nach negativ
const epsUp = trendUp(epsFY, epsPrevFY);
const epsBackPos = (Number.isFinite(epsYoy1) ? (epsYoy1 > 0) : null);

// ICR verbessert sich (Richtung >1–2)
const icrUp = trendUp(icr, icrPrev);
const icrNowOk = (Number.isFinite(icr) ? (icr >= 1.5) : null);

// Leverage “hoch aber sinkend”
const ndeDown = (Number.isFinite(netDebtEbitda) && Number.isFinite(ndePrev)) ? (netDebtEbitda < ndePrev) : null;
const dcfDown = (Number.isFinite(debtFcf) && Number.isFinite(dcfPrev)) ? (debtFcf < dcfPrev) : null;
const leverageHigh = (Number.isFinite(netDebtEbitda) ? netDebtEbitda > 3 : false) || (Number.isFinite(debtFcf) ? debtFcf > 8 : false);

// --- ECHT vs PROXY ---
// ECHT wenn wir wenigstens NI oder FCF oder OPM Trend vergleichen können:
const hasTrendData =
  !niFlip.missing || !niLessNeg.missing || !fcfFlip.missing || !fcfLessNeg.missing || !opmUp.missing || (opmTurning !== null) || (icrUp.missing === false);

// “Turnaround-Score”: du willst mehrere Signale gleichzeitig
let taSignals = 0;

function addSig(cond){
  if(cond === true) taSignals++;
}

addSig(niFlip.ok || niLessNeg.ok);
addSig(fcfFlip.ok || fcfLessNeg.ok);
addSig(fcfMarginUp.ok);
addSig(opmUp.ok || opmTurning === true);
addSig(revBackPos === true);
addSig(epsUp.ok || epsBackPos === true);
addSig(icrUp.ok || icrNowOk === true);
addSig( (ndeDown === true) || (dcfDown === true) );
addSig(reboundFromLow === true); // nur Signal, nicht Pflicht

// ECHT: “war schlecht” + mindestens 3 Turnaround-Signale (du kannst 2/4 wählen)
const isTurnaroundTrue =
  wasBadNow &&
  hasTrendData &&
  (taSignals >= 3) &&
  (revBackPos !== false); // wenn revYoy bekannt und negativ => eher kein Turnaround

// PROXY: wenn Trends fehlen -> strenger mit 1Y Signalen
// Proxy = NI/FCF schlecht + (Rev wieder >0) + (OPM >0 oder OPM4Y dreht) + (EPS/ICR nicht katastrophal) und idealerweise Kurs vom Tief erholt
const isTurnaroundProxy =
  wasBadNow &&
  !hasTrendData &&
  (revBackPos === true) &&
  ((Number.isFinite(opm1y) && opm1y > 0) || (opmTurning === true)) &&
  ((epsBackPos === true) || (Number.isFinite(epsFY) && epsFY > 0) || (icrNowOk === true)) &&
  (reboundFromLow !== false); // wenn bekannt und NICHT erholt -> eher kein

const isTurnaround = isTurnaroundTrue || isTurnaroundProxy;
const turnaroundNote = isTurnaroundTrue ? "Echt (Trend erkannt)" : (isTurnaroundProxy ? "Proxy (Trend fehlt)" : "");



// =====================
// Zykliker (neu)
// =====================

// --- 0) optional: mehrjährige Felder (wenn vorhanden) ---
// Wenn du diese Header NICHT hast, bleiben die Werte NaN und es läuft Proxy.
const revYoy1 = nzPct(m["Revenue Growth 1Y (YoY)"]);
const revYoy2 = nzPct(m["Revenue Growth 2Y (YoY)"]);
const revYoy3 = nzPct(m["Revenue Growth 3Y (YoY)"]);
const revYoy4 = nzPct(m["Revenue Growth 4Y (YoY)"]);



// Optional (wenn du sowas hast)
const opm1 = nzPct(m["Operating Margin 1Y"]);
const opm2 = nzPct(m["Operating Margin 2Y"]);
const opm3 = nzPct(m["Operating Margin 3Y"]);
const opm4 = nzPct(m["Operating Margin 4Y"]);


// --- 1) Helper: “stark schwankend” über mehrere Jahre ---
// Schwankend = mindestens 1x positiv UND 1x negativ in der Reihe
function hasPlusAndMinus(arr){
  const vals = arr.filter(v => Number.isFinite(v));
  if(vals.length < 2) return { ok:false, missing:true };
  const hasPos = vals.some(v => v > 0);
  const hasNeg = vals.some(v => v < 0);
  return { ok: hasPos && hasNeg, missing:false };
}

// “sehr volatil” = Range zwischen min/max groß (z.B. > 25 Prozentpunkte)
function rangeLarge(arr, pp){
  const vals = arr.filter(v => Number.isFinite(v));
  if(vals.length < 2) return { ok:false, missing:true };
  const lo = Math.min(...vals), hi = Math.max(...vals);
  return { ok: (hi - lo) >= pp, missing:false };
}

// --- 2) “Echter Zykliker” (wenn Zeitreihe da ist) ---
const revSwing = hasPlusAndMinus([revYoy1,revYoy2,revYoy3,revYoy4]);        // + und –
const epsSwing = hasPlusAndMinus([epsYoy1,epsYoy2,epsYoy3,epsYoy4]);        // + und –
const opmSwing = rangeLarge([opm1,opm2,opm3,opm4], 8);                      // Marge schwankt stark
const fcfSwing = hasPlusAndMinus([fcf1,fcf2,fcf3,fcf4]);                    // FCF dreht

const betaCyc = Number.isFinite(beta) && beta > 1.2;                        // oft >1,2
const betaStrong = Number.isFinite(beta) && beta > 1.5;                     // “oft >1,5”
const volCyc  = Number.isFinite(vol) && vol >= 35;                          // relativ hoch
const rangeBroad = Number.isFinite(rangePct) && rangePct >= 0.8;            // breite 52W-Range

// PE “trügerisch”: wir können nur markieren, wenn PE nicht nutzbar/negativ oder extrem
const peTricky = (!peUsable) || (peUsable && pe >= 45);

// ECHT = (Rev ODER EPS) zeigt +/– Wechsel UND Risiko/Range passt
const isCyclicalTrue =
  ( (revSwing.ok || epsSwing.ok) ) &&
  (betaCyc || volCyc || rangeBroad) &&
  (opmSwing.ok || fcfSwing.ok || peTricky);

// --- 3) Proxy-Zykliker (wenn Zeitreihe fehlt) ---
// Wenn wir Rev/EPS-Swing nicht prüfen können, nehmen wir “Zykliker-Profil”
const missingTimeSeries = revSwing.missing && epsSwing.missing;
const isCyclicalProxy =
  missingTimeSeries &&
  (betaCyc && volCyc && rangeBroad) &&
  ( (Number.isFinite(opm1) && opm1 < 12) || (fcfPos === false) || peTricky );

// Final
const isCyclical = isCyclicalTrue || isCyclicalProxy;
const cyclicalNote = isCyclicalTrue ? "Echt (Zeitreihe erkannt)" : (isCyclicalProxy ? "Proxy (Zeitreihe fehlt)" : "");


const volVeryHigh = Number.isFinite(vol) && vol >= 60;
const debtFcfNotSane = !Number.isFinite(debtFcf) || debtFcf <= 0;

// =====================
// Spekulation (neu)
// =====================

// 52W Range extrem breit: rangePct ist (high-low)/low
const rangeExtreme = Number.isFinite(rangePct) && rangePct >= 1.2; // >=120% Spanne

// Vol sehr hoch (45–60+)
const volHigh = Number.isFinite(vol) && vol >= 45;

// Beta hoch
const betaHigh = Number.isFinite(beta) && beta >= 1.8;

// Net income negativ (stark schwankend kann man ohne Zeitreihe nicht exakt messen)
const niBad = (netIncomePos === false);

// FCF negativ oder Marge sehr niedrig/negativ
const fcfBad = (fcfPos === false) || (Number.isFinite(fcfMargin) && fcfMargin < 3);
const fcfVeryBad = (fcfPos === false) || (Number.isFinite(fcfMargin) && fcfMargin < 0);

// Debt/FCF sehr hoch oder “nicht sinnvoll”
const debtFcfVeryHigh = (Number.isFinite(debtFcf) && debtFcf > 12) || debtFcfNotSane;

// PE sehr hoch oder negativ/nicht nutzbar
const peTooHigh = (Number.isFinite(pe) && pe >= 45);
const peNotUsable = !Number.isFinite(pe) || pe <= 0; // negativ/fehlend
const peSpec = peTooHigh || peNotUsable;

// Optional: Hype-Hinweis (nur, wenn du Kurs 4Y CAGR hast)
const priceCagr4 = nzPct(m["Kurs 4Y (CAGR)"]); // nur falls Feld existiert
const hypeMove = Number.isFinite(priceCagr4) && priceCagr4 >= 30; // “extrem” frei wählbar

// Fundamentaldaten “nicht stabil”: NI oder FCF schlecht
const fundamentalsBad = (niBad || fcfBad);

// --- Score Modell ---
// Idee: Spekulation, wenn (Risk-Vol/Beta/Range) + (Fundamentals/Valuation) zusammenkommen.
let specScore = 0;

// Risiko/Schwankung
if(volHigh) specScore++;
if(volVeryHigh) specScore++;      // extra Punkt
if(betaHigh) specScore++;
if(rangeExtreme) specScore++;

// Fundamentals
if(niBad) specScore++;
if(fcfBad) specScore++;
if(fcfVeryBad) specScore++;       // extra Punkt
if(debtFcfVeryHigh) specScore++;

// Bewertung/PE
if(peTooHigh) specScore++;
if(peNotUsable) specScore++;      // extra Punkt

// Harte Mindestbedingung: Mindestens 1 “Schwankungs”-Signal
const hasSwing = volHigh || betaHigh || rangeExtreme;

// Spekulation = Swing + Score >= 4
// (dadurch wird es nicht zu “leicht” getriggert)
const isSpec = hasSwing && (specScore >= 4);

// Optional: Hype nur als Hinweis in Why, nicht als Kriterium


  // Krisenfall 
// Stress weiter berechnen (für Ampel/Overlay), aber NICHT für Krisenfall-Rolle verwenden
const { mode: stressMode, triggers: stressTriggers } = nutzenComputeStress(m);

// --- Krisenfall (Rolle) = harte Kriterien ---
const interestExp = nzNum(m["Interest Expense 1Y"]); // Feld muss so heißen wie in deiner Tabelle!
const range52 = nzParse52w(m["52 Week Range"]);
const currentPrice = nzNum(m["Kurs aktuell"]);

// Nähe zum 52W-Tief (z.B. <= 15% über Low)
const near52wLow = (Number.isFinite(range52.low) && Number.isFinite(currentPrice) && range52.low > 0)
  ? (currentPrice <= range52.low * 1.15)
  : false;

// “hoch/steigend” bei Interest Expense kann man ohne Zeitreihe NICHT sauber erkennen.
// Daher: wenn InterestExpense vorhanden und >0 => Druckpunkt; wenn fehlt -> "unknown" (nicht blockend).
const interestPressure = Number.isFinite(interestExp) ? (interestExp > 0) : null;

// Debt/FCF “nicht sinnvoll” wenn fehlt oder <=0 oder extrem hoch

const debtFcfExtreme = (Number.isFinite(debtFcf) && debtFcf > 12) || debtFcfNotSane;

// NetDebt/EBITDA sehr hoch oder “nicht sinnvoll”
const ndeExtreme = (!Number.isFinite(netDebtEbitda)) || (netDebtEbitda > 5);

// Operating Margin stark negativ (z.B. < 0)
const opmVeryBad = Number.isFinite(opm1y) && opm1y < 0;

// Revenue YoY deutlich negativ (z.B. <= -5)
const revBad = Number.isFinite(revYoy) && revYoy <= -5;

// Volatilität sehr hoch (z.B. >= 60)


// ICR kritisch
const icrCritical = Number.isFinite(icr) && icr < 1;

// Basisbedingungen (müssen erfüllt sein)
const crisisBase =
  (netIncomePos === false) &&
  (fcfPos === false) &&
  icrCritical;

// Zusätzliche Krisen-Trigger (wir verlangen mehrere davon)
let crisisScore = 0;
if(ndeExtreme) crisisScore++;
if(debtFcfExtreme) crisisScore++;
if(opmVeryBad) crisisScore++;
if(revBad) crisisScore++;
if(near52wLow) crisisScore++;
if(volVeryHigh) crisisScore++;
if(interestPressure === true) crisisScore++; // optionaler Zusatz

// Krisenfall = Base + mindestens 2 zusätzliche Trigger
const isCrisis = crisisBase && (crisisScore >= 2);

  // Size
  const isSmall = Number.isFinite(mcap) && mcap > 0 && mcap < 2e9;
  const isMid   = Number.isFinite(mcap) && mcap >= 2e9 && mcap < 10e9;
  const isLarge = Number.isFinite(mcap) && mcap >= 10e9;

  // Defensiv / stabil defensiv
  const isDefensive =
    (Number.isFinite(beta) && beta <= 1.0) &&
    (Number.isFinite(vol) ? vol <= 30 : true) &&
    (Number.isFinite(rangePct) ? rangePct <= 0.6 : true);

  const isStableDef =
    (netIncomePos !== false) &&
    (fcfPos !== false) &&
    (Number.isFinite(opm1y) ? opm1y > 0 : true) &&
    (Number.isFinite(netDebtEbitda) ? netDebtEbitda <= 3 : true) &&
    (Number.isFinite(icr) ? icr > 6 : true) &&
    (Number.isFinite(debtFcf) ? debtFcf <= 6 : true) &&
    isDefensive;


  const status = {};

function healthLabel(pct, known){
  if(known <= 0) return "Health: – (zu wenig Daten)";
  if(pct >= 0.75) return "Health: stark";
  if(pct >= 0.60) return "Health: ok";
  return "Health: schwach";
}

function evalRole(baseChecks, healthChecks, healthMinPct=0.60){
  // Base: fehlende Werte blocken NICHT hart
  const baseOk = baseChecks.every(c => c.missing ? true : !!c.ok);

  // Health: nur bekannte Checks zählen
  const known = healthChecks.filter(c => !c.missing);
  const okCnt = known.filter(c => !!c.ok).length;
  const max   = known.length;
  const pct   = max > 0 ? okCnt / max : 0;

  let state = "off";
  if(baseOk){
    if(max === 0) state = "warn";              // Base ok, aber kaum Health-Daten
    else state = (pct >= healthMinPct) ? "on" : "warn";
  }

  return { state, baseOk, okCnt, max, pct };
}

function setRole(role, baseChecks, healthChecks, healthMinPct=0.60){
  const ev = evalRole(baseChecks, healthChecks, healthMinPct);

  const header =
    `BASE: ${ev.baseOk ? "✅ ok" : "❌ nicht"} | ` +
    `HEALTH: ${ev.max ? `${ev.okCnt}/${ev.max}` : "–"} (${healthLabel(ev.pct, ev.max)})`;

  status[role] = {
    state: ev.state, // "on" | "warn" | "off"
    why: [
      header,
      ...buildWhy(baseChecks).map(x => "BASE: " + x),
      ...buildWhy(healthChecks).map(x => "HEALTH: " + x),
    ]
  };
}

  // ========== CHECKLISTEN (Beispiele) ==========

  // Aristokrat Checkliste
const aristocratBase = [
  chk(`Dividend Growth Years ≥ 25 (aktuell: ${Number.isFinite(divYears)?divYears:"–"})`, Number.isFinite(divYears) && divYears >= 25, !Number.isFinite(divYears)),
  chk(`Dividende regelmäßig (Frequency: ${divFreq || "–"})`, !!regularDiv, !divFreq),
  chk(`Net Income positiv`, netIncomePos === true, netIncomePos === null),
  chk(`FCF positiv`, fcfPos === true, fcfPos === null),
];

const aristocratHealth = [
  chk(`DPS 4Y CAGR > 0% (aktuell: ${fmtPct(dpsCagr4)})`, Number.isFinite(dpsCagr4) ? dpsCagr4 > 0 : true, !Number.isFinite(dpsCagr4)),
  chk(`Payout 30–70% (aktuell: ${fmtPct(payout)})`, Number.isFinite(payout) ? (payout >= 30 && payout <= 70) : true, !Number.isFinite(payout)),
  chk(`FCF-Payout ≤ 80% (aktuell: ${fmtPct(fcfPayout)})`, Number.isFinite(fcfPayout) ? (fcfPayout <= 80) : true, !Number.isFinite(fcfPayout)),
  chk(`Debt/FCF < 8`, Number.isFinite(debtFcf) ? debtFcf < 8 : true, !Number.isFinite(debtFcf)),
  chk(`ICR > 4`, Number.isFinite(icr) ? icr > 4 : true, !Number.isFinite(icr)),
  chk(`Beta < 1.2`, Number.isFinite(beta) ? beta < 1.2 : true, !Number.isFinite(beta)),
];

  // Dividenden-Wachstum Checkliste
const divGrowthBase = [
  chk(`Dividend Growth Years ≥ 5`, Number.isFinite(divYears) && divYears >= 5, !Number.isFinite(divYears)),
  chk(`DPS 4Y CAGR ≥ 5%`, Number.isFinite(dpsCagr4) && dpsCagr4 >= 5, !Number.isFinite(dpsCagr4)),
  chk(`Keine Kürzung/Stop (Text)`, !divGrowthLooksBad, !divGrowthTxt),
  chk(`Net Income positiv`, netIncomePos === true, netIncomePos === null),
  chk(`FCF positiv`, fcfPos === true, fcfPos === null),
];

const divGrowthHealth = [
  chk(`Payout 25–60%`, Number.isFinite(payout) ? (payout >= 25 && payout <= 60) : true, !Number.isFinite(payout)),
  chk(`FCF-Payout ≤ 70%`, Number.isFinite(fcfPayout) ? (fcfPayout <= 70) : true, !Number.isFinite(fcfPayout)),
  chk(`Revenue 4Y CAGR ≥ 3%`, Number.isFinite(revCagr4) ? revCagr4 >= 3 : true, !Number.isFinite(revCagr4)),
  chk(`EPS 4Y CAGR ≥ 5%`, Number.isFinite(epsCagr4) ? epsCagr4 >= 5 : true, !Number.isFinite(epsCagr4)),
  chk(`Debt/FCF < 8`, Number.isFinite(debtFcf) ? debtFcf < 8 : true, !Number.isFinite(debtFcf)),
  chk(`ICR > 4`, Number.isFinite(icr) ? icr > 4 : true, !Number.isFinite(icr)),
];

  // High Dividend Checkliste
const highDivBase = [
  chk(`Div.-Rendite ≥ 4%`, Number.isFinite(divYield) && divYield >= 4, !Number.isFinite(divYield)),
  chk(`Dividende regelmäßig`, !!regularDiv, !divFreq),
  chk(`Net Income positiv`, netIncomePos === true, netIncomePos === null),
  chk(`FCF positiv`, fcfPos === true, fcfPos === null),
];

const highDivHealth = [
  chk(`Payout ≤ 80%`, Number.isFinite(payout) ? payout <= 80 : true, !Number.isFinite(payout)),
  chk(`FCF-Payout ≤ 80%`, Number.isFinite(fcfPayout) ? fcfPayout <= 80 : true, !Number.isFinite(fcfPayout)),
  chk(`Debt/FCF < 10`, Number.isFinite(debtFcf) ? debtFcf < 10 : true, !Number.isFinite(debtFcf)),
  chk(`ICR > 3`, Number.isFinite(icr) ? icr > 3 : true, !Number.isFinite(icr)),
  chk(`Kein Yield-Trap (PayoutOk/FCF)`, payoutOk && fcfPayoutOk && fcfMustBePos, false),
];

  // Value Checkliste (kurz, aber korrekt)
const valueBase = [
  chk(`Billig: KGV≤18 ODER MOS ODER FCF Yield≥5`, (peUsable && pe <= 18) || mosOk || (Number.isFinite(fcfYield) && fcfYield >= 5), false),
  chk(`Net Income positiv`, netIncomePos === true, netIncomePos === null),
  chk(`FCF positiv`, fcfPos === true, fcfPos === null),
];

const valueHealth = [
  chk(`ROIC/ROCE ≥ 10%`, (Number.isFinite(roic)&&roic>=10) || (Number.isFinite(roce)&&roce>=10), !(Number.isFinite(roic)||Number.isFinite(roce))),
  chk(`NetDebt/EBITDA < 3`, Number.isFinite(netDebtEbitda) ? netDebtEbitda < 3 : true, !Number.isFinite(netDebtEbitda)),
  chk(`Debt/FCF < 8`, Number.isFinite(debtFcf) ? debtFcf < 8 : true, !Number.isFinite(debtFcf)),
  chk(`Operating Margin > 0`, Number.isFinite(opm1y) ? opm1y > 0 : true, !Number.isFinite(opm1y)),
  chk(`Beta nicht hoch (≤1.3)`, Number.isFinite(beta) ? beta <= 1.3 : true, !Number.isFinite(beta)),
];

  // Wachstum (kurz)
const growthBase = [
  chk(`Revenue 4Y CAGR ≥ 10%`, Number.isFinite(revCagr4) && revCagr4 >= 10, !Number.isFinite(revCagr4)),
  chk(`FCF positiv`, fcfPos === true, fcfPos === null),
  chk(`Net Income positiv`, netIncomePos === true, netIncomePos === null),
];

const growthHealth = [
  chk(`Revenue YoY ≥ 8%`, Number.isFinite(revYoy) ? revYoy >= 8 : true, !Number.isFinite(revYoy)),
  chk(`EPS 4Y CAGR ≥ 12%`, Number.isFinite(epsCagr4) ? epsCagr4 >= 12 : true, !Number.isFinite(epsCagr4)),
  chk(`Operating Margin > 0%`, Number.isFinite(opm1y) ? opm1y > 0 : true, !Number.isFinite(opm1y)),
  chk(`FCF-Marge ≥ 5%`, Number.isFinite(fcfMargin) ? fcfMargin >= 5 : true, !Number.isFinite(fcfMargin)),
  chk(`ROIC/ROCE ≥ 10%`, (Number.isFinite(roic)&&roic>=10) || (Number.isFinite(roce)&&roce>=10), !(Number.isFinite(roic)||Number.isFinite(roce))),
];

  // Quality (kurz)
const qualityBase = [
  chk(`ROIC ≥ 12%`, Number.isFinite(roic) && roic >= 12, !Number.isFinite(roic)),
  chk(`Net Income positiv`, netIncomePos === true, netIncomePos === null),
  chk(`FCF positiv`, fcfPos === true, fcfPos === null),
];

const qualityHealth = [
  chk(`ROCE ≥ 12%`, Number.isFinite(roce) ? roce >= 12 : true, !Number.isFinite(roce)),
  chk(`Operating Margin ≥ 15%`, Number.isFinite(opm1y) ? opm1y >= 15 : true, !Number.isFinite(opm1y)),
  chk(`OPM-Trend ≥ 0 (4Y)` , Number.isFinite(opmCagr4) ? opmCagr4 >= 0 : true, !Number.isFinite(opmCagr4)),
  chk(`FCF-Marge ≥ 10%`, Number.isFinite(fcfMargin) ? fcfMargin >= 10 : true, !Number.isFinite(fcfMargin)),
  chk(`NetDebt/EBITDA ≤ 3`, Number.isFinite(netDebtEbitda) ? netDebtEbitda <= 3 : true, !Number.isFinite(netDebtEbitda)),
  chk(`Debt/FCF ≤ 6`, Number.isFinite(debtFcf) ? debtFcf <= 6 : true, !Number.isFinite(debtFcf)),
  chk(`ICR > 6`, Number.isFinite(icr) ? icr > 6 : true, !Number.isFinite(icr)),
  chk(`Beta ≤ 1.2`, Number.isFinite(beta) ? beta <= 1.2 : true, !Number.isFinite(beta)),
];

  // GARP (kurz)
const garpBase = [
  chk(`Revenue 4Y CAGR ≥ 8%`, Number.isFinite(revCagr4) && revCagr4 >= 8, !Number.isFinite(revCagr4)),
  chk(`EPS 4Y CAGR ≥ 10%`, Number.isFinite(epsCagr4) && epsCagr4 >= 10, !Number.isFinite(epsCagr4)),
  chk(`Preis ok: PE≤30 oder MOS≤0,9`, (peUsable && pe <= 30) || mosOk90, false),
];

const garpHealth = [
  chk(`Operating Margin ≥ 10%`, Number.isFinite(opm1y) ? opm1y >= 10 : true, !Number.isFinite(opm1y)),
  chk(`ROIC/ROCE ≥ 10%`, (Number.isFinite(roic)&&roic>=10) || (Number.isFinite(roce)&&roce>=10), !(Number.isFinite(roic)||Number.isFinite(roce))),
  chk(`FCF positiv`, fcfPos === true, fcfPos === null),
  chk(`FCF-Marge ≥ 5%`, Number.isFinite(fcfMargin) ? fcfMargin >= 5 : true, !Number.isFinite(fcfMargin)),
  chk(`NetDebt/EBITDA ≤ 3`, Number.isFinite(netDebtEbitda) ? netDebtEbitda <= 3 : true, !Number.isFinite(netDebtEbitda)),
  chk(`ICR > 5`, Number.isFinite(icr) ? icr > 5 : true, !Number.isFinite(icr)),
];

const turnBase = [
  chk(`Ausgangslage: NI oder FCF negativ`, wasBadNow, (netIncomePos===null && fcfPos===null)),
  chk(`Turnaround erkannt (Echt/Proxy)`, isTurnaround, false),
];

const turnHealth = [
  chk(`Signale ≥ 3 (aktuell: ${taSignals})`, Number.isFinite(taSignals) ? (taSignals >= 3) : false, !Number.isFinite(taSignals)),
  chk(`Revenue YoY nicht negativ`, (revBackPos !== false), (revBackPos===null)),
  chk(`ICR Richtung ok (≥1.5 oder steigend)`, (icrNowOk===true) || icrUp.ok, (!Number.isFinite(icr) && icrUp.missing)),
  chk(`Leverage sinkt (NDE oder Debt/FCF)`, (ndeDown===true) || (dcfDown===true), (ndeDown===null && dcfDown===null)),
  chk(`Kurs vom Tief erholt (Signal)`, reboundFromLow === true, reboundFromLow===null),
];

const cycBase = [
  chk(`Zykliker-Profil erkannt (Echt/Proxy)`, isCyclical, false),
];

const cycHealth = [
  chk(`Rev Swing (+/–)`, revSwing.ok, revSwing.missing),
  chk(`EPS Swing (+/–)`, epsSwing.ok, epsSwing.missing),
  chk(`OPM Swing groß`, opmSwing.ok, opmSwing.missing),
  chk(`Beta/Vol/Range passen`, (betaCyc || volCyc || rangeBroad), false),
];
  
const specBase = [
  chk(`Mindestens 1 Swing-Signal (Vol/Beta/Range)`, hasSwing, false),
  chk(`SpecScore ≥ 4 (aktuell: ${specScore})`, Number.isFinite(specScore) ? specScore >= 4 : false, !Number.isFinite(specScore)),
];

const specHealth = [
  chk(`Fundamentals schwach (NI oder FCF)`, fundamentalsBad, false),
  chk(`Debt/FCF extrem/unsinnig`, debtFcfVeryHigh, false),
  chk(`PE sehr hoch/negativ`, peSpec, false),
  chk(`Hype Move (Hinweis)`, hypeMove, !Number.isFinite(priceCagr4)),
];
  
const crisisBaseChecks = [
  chk(`Net Income negativ`, netIncomePos === false, netIncomePos === null),
  chk(`FCF negativ`, fcfPos === false, fcfPos === null),
  chk(`ICR < 1`, icrCritical, !Number.isFinite(icr)),
];

const crisisHealthChecks = [
  chk(`Score ≥ 2 (aktuell: ${crisisScore})`, Number.isFinite(crisisScore) ? crisisScore >= 2 : false, !Number.isFinite(crisisScore)),
  chk(`NetDebt/EBITDA extrem/fehlt`, ndeExtreme, false),
  chk(`Debt/FCF extrem/unsinnig`, debtFcfExtreme, false),
  chk(`Operating Margin < 0`, opmVeryBad, !Number.isFinite(opm1y)),
  chk(`Revenue YoY ≤ -5%`, revBad, !Number.isFinite(revYoy)),
  chk(`Nahe 52W Low`, near52wLow, !(Number.isFinite(range52.low)&&Number.isFinite(currentPrice))),
  chk(`Volatilität ≥ 60%`, volVeryHigh, !Number.isFinite(vol)),
  chk(`Interest Expense Druck`, interestPressure === true, interestPressure === null),
];
  const smallChecks = [ chk(`Market Cap < 2 Mrd`, Number.isFinite(mcap) && mcap < 2e9, !Number.isFinite(mcap)) ];
  const midChecks   = [ chk(`Market Cap 2–10 Mrd`, Number.isFinite(mcap) && mcap >= 2e9 && mcap < 10e9, !Number.isFinite(mcap)) ];
  const largeChecks = [ chk(`Market Cap > 10 Mrd`, Number.isFinite(mcap) && mcap >= 10e9, !Number.isFinite(mcap)) ];

const defBase = [
  chk(`Beta ≤ 1.0`, Number.isFinite(beta) && beta<=1.0, !Number.isFinite(beta)),
];

const defHealth = [
  chk(`Vol ≤ 30%`, Number.isFinite(vol) ? vol <= 30 : true, !Number.isFinite(vol)),
  chk(`52W Range ≤ 60%`, Number.isFinite(rangePct) ? rangePct <= 0.6 : true, !Number.isFinite(rangePct)),
];

const stabDefBase = [
  chk(`Defensiv erfüllt`, isDefensive, false),
  chk(`Net Income positiv`, netIncomePos === true, netIncomePos === null),
  chk(`FCF positiv`, fcfPos === true, fcfPos === null),
];

const stabDefHealth = [
  chk(`Operating Margin > 0`, Number.isFinite(opm1y) ? opm1y > 0 : true, !Number.isFinite(opm1y)),
  chk(`NetDebt/EBITDA ≤ 3`, Number.isFinite(netDebtEbitda) ? netDebtEbitda <= 3 : true, !Number.isFinite(netDebtEbitda)),
  chk(`Debt/FCF ≤ 6`, Number.isFinite(debtFcf) ? debtFcf <= 6 : true, !Number.isFinite(debtFcf)),
  chk(`ICR > 6`, Number.isFinite(icr) ? icr > 6 : true, !Number.isFinite(icr)),
];

  // ========== SETZEN ==========
setRole("Dividenden-Aristokrat", aristocratBase, aristocratHealth, 0.60);
setRole("Dividenden-Wachstum", divGrowthBase, divGrowthHealth, 0.60);
setRole("High Dividend", highDivBase, highDivHealth, 0.60);

setRole("Value", valueBase, valueHealth, 0.60);
setRole("Wachstum", growthBase, growthHealth, 0.60);
setRole("Quality", qualityBase, qualityHealth, 0.65); // Quality etwas strenger
setRole("GARP (Wachstum, preis ist nicht teuer)", garpBase, garpHealth, 0.60);

setRole("Turnaround", turnBase, turnHealth, 0.50);    // Turnaround: Health lockerer
setRole("Zykliker", cycBase, cycHealth, 0.50);
setRole("Spekulation", specBase, specHealth, 0.50);

setRole("Krisenfall", crisisBaseChecks, crisisHealthChecks, 0.50);

setRole("Defensiv", defBase, defHealth, 0.60);
setRole("Stabil defensiv", stabDefBase, stabDefHealth, 0.65);

// Size kannst du entweder lassen wie gehabt (ohne Health) oder auch als Base-only:
setRole("Small Cap", smallChecks, [], 0.0);
setRole("Mid Cap", midChecks, [], 0.0);
setRole("Large Cap", largeChecks, [], 0.0);

  // Safety
  for(const r of NUTZEN_ROLE_CATALOG){
    if(!status[r]) status[r] = { state:"off", why:["… noch keine Checkliste"] };
  }
  return status;
}









function nutzenEvaluateAll(){
  const m = nutzenGetTableMap();
  const fair = nutzenComputeFairPrice(m);
  const stress = nutzenComputeStress(m);
  const roles = nutzenComputeRoles(m);
  const actions = nutzenComputeActions(m, fair);

  return { map:m, fair, stress, roles, actions };
}








/* =========================================
   3) UI: Render using REAL evaluation
   ========================================= */

function nutzenApplyAutoToUI(ev){
  // Fairer Preis in Tabelle zurückschreiben, falls leer/NaN und wir etwas berechnen konnten
  if(Number.isFinite(ev.fair)){
    // schreibe nur, wenn Zelle leer ist
    const valRow = document.getElementById("nutzenValueRow");
    if(valRow){
      const cells = Array.from(valRow.querySelectorAll("td"));
      const idxFair = NUTZEN_HEADERS.indexOf("Fairer Preis");
      if(idxFair >= 0 && cells[idxFair]){
        if(!nzStr(cells[idxFair].textContent)) cells[idxFair].textContent = ev.fair.toFixed(2);
      }
    }
  }

  // Stress nur setzen, wenn auf "auto" (nicht manuell überschreiben)
  const selMain = document.getElementById("nutzenStressSelect");
  const selOv   = document.getElementById("nutzenOverlayStressSelect");
  const isAutoMain = !selMain || selMain.value === "auto";
  const isAutoOv   = !selOv   || selOv.value   === "auto";

  if(isAutoMain || isAutoOv){
    const mode = ev.stress.mode; // green/yellow/red
    nutzenSyncStress(mode);

    const whyTxt = ev.stress.triggers.length
      ? ("Auto-Trigger: " + ev.stress.triggers.join(" | "))
      : "Auto: keine Stress-Trigger erkannt.";
    const whyMain = document.getElementById("nutzenStressWhy");
    const whyOv   = document.getElementById("nutzenOverlayStressWhy");
    if(whyMain) whyMain.textContent = whyTxt;
    if(whyOv)   whyOv.textContent   = whyTxt;
  }

  // Overlay Actions Felder automatisch füllen (wenn leer)
  const fp = ovGetEl("ov_fairPrice");
  const cp = ovGetEl("ov_currentPrice");
  const buy = ovGetEl("ov_buySelect");
  const add = ovGetEl("ov_addSelect");

  if(fp && !nzStr(fp.value) && Number.isFinite(ev.fair)) fp.value = ev.fair.toFixed(2);

  const current = nzNum(ev.map["Kurs aktuell"]);
  if(cp && !nzStr(cp.value) && Number.isFinite(current)) cp.value = current.toFixed(2);

  if(buy && buy.value === "auto" && ev.actions.buy !== "auto") buy.value = ev.actions.buy;
  if(add && add.value === "auto" && ev.actions.add !== "auto") add.value = ev.actions.add;

  ovRenderActionsSummary();
}

function renderNutzenRolesBox(){
  const host = document.getElementById("nutzen_roles");
  if(!host) return;

  const ev = nutzenEvaluateAll();
  const statusMap = ev.roles;

  host.innerHTML = `
    <div class="out" style="margin-top:12px">
      <div class="kpi">
        <span><b>Rollen</b></span>
        <span class="small">Auto aus Kennzahlen</span>
      </div>

      <div class="roleGrid">
        ${NUTZEN_ROLE_CATALOG.map(role => {
          const st = statusMap[role]?.state || "unknown";
          const why = statusMap[role]?.why || [];
          const whyHtml = (why.length)
            ? `<ul class="roleChecks">${why.map(x => `<li class="muted">${String(x).replace(/</g,"&lt;").replace(/>/g,"&gt;")}</li>`).join("")}</ul>`
            : `<div class="roleMeta">–</div>`;

          return `
            <details class="roleDetails">
              <summary>
                <span class="sumRow">
                  <span>${role}</span>
                  ${roleBadgeHtml(st)}
                </span>
              </summary>
              ${whyHtml}
            </details>
          `;
        }).join("")}
      </div>
    </div>
  `;

  // nach Render: Auto-UI anwenden (Stress/Fair/Actions)
  nutzenApplyAutoToUI(ev);
}

function nutzenOverlayFillRoles(){
  const box = document.getElementById("nutzenOverlayRoles");
  const why = document.getElementById("nutzenOverlayRolesWhy");
  if(!box) return;

  const ev = nutzenEvaluateAll();
  const statusMap = ev.roles;

  box.innerHTML = NUTZEN_ROLE_CATALOG.map(role => {
    const st = statusMap[role]?.state || "unknown";
    const on = (st === "on");
    const off = !on;
    return `<span class="roleChip ${off ? "off" : ""}">${on ? "✅" : "…"} ${role}</span>`;
  }).join("");

  if(why){
    const t = ev.stress.triggers.length ? ev.stress.triggers.join(" | ") : "Keine Stress-Trigger.";
    why.textContent = `Auto-Status. Stress: ${ev.stress.mode.toUpperCase()} (${t})`;
  }

  nutzenApplyAutoToUI(ev);
}

/* =========================================
   4) Overlay open: use real fills
   ========================================= */

function openNutzenOverlay(){
  const ov = document.getElementById("nutzenOverlay");
  const bd = document.getElementById("nutzenOverlayBackdrop");
  if(!ov || !bd) return;

  // Inhalte füllen / aktualisieren
  try { nutzenOverlayFillRoles(); } catch(e) {}
  try { nutzenOverlayFillRangeBase(); } catch(e) {}

  // Stress Select: nur setzen, wenn leer (sonst überschreibst du manuell)
  const sel = document.getElementById("nutzenOverlayStressSelect");
  if(sel && !sel.value) sel.value = "auto";

  // show
  bd.style.display = "block";
  ov.style.display = "flex";

  // optional: Klassen für Animationen/Styles
  bd.classList.add("isOpen");
  ov.classList.add("isOpen");

  ov.setAttribute("aria-hidden","false");
}





/* =========================================
   5) Guard: prevent double-binding Overlay/Actions
   ========================================= */

let _nutzenOverlayBound = false;


function bindNutzenOverlayUI(){
  // 1) Globaler Guard (nur 1x)
  if(window._nutzenOverlayBound) return;
  window._nutzenOverlayBound = true;

  const btnOpen   = document.getElementById("nutzen_overlayBtn");
  const btnClose  = document.getElementById("nutzenOverlayCloseBtn");
  const backdrop  = document.getElementById("nutzenOverlayBackdrop");
  const selStress = document.getElementById("nutzenOverlayStressSelect");

  // 2) Pro-Element Guard via dataset.bound
  if(btnOpen && !btnOpen.dataset.bound){
    btnOpen.dataset.bound = "1";
    btnOpen.addEventListener("click", openNutzenOverlay);
  }

  if(btnClose && !btnClose.dataset.bound){
    btnClose.dataset.bound = "1";
    btnClose.addEventListener("click", closeNutzenOverlay);
  }

  if(backdrop && !backdrop.dataset.bound){
    backdrop.dataset.bound = "1";
    backdrop.addEventListener("click", closeNutzenOverlay);
  }

  // 3) ESC schließt – nur 1x binden
  if(!document.body.dataset.nutzenEscBound){
    document.body.dataset.nutzenEscBound = "1";
    document.addEventListener("keydown", (e) => {
      if(e.key !== "Escape") return;

      const ov = document.getElementById("nutzenOverlay");
      if(!ov) return;

      const isOpen =
        ov.classList.contains("isOpen") ||
        ov.getAttribute("aria-hidden") === "false" ||
        ov.style.display === "flex";

      if(isOpen) closeNutzenOverlay();
    });
  }

  // 4) Stress-Select im Overlay (manuell/auto)
  // Pro-Element Guard, damit kein doppeltes "change" entsteht
  if(selStress && !selStress.dataset.bound){
    selStress.dataset.bound = "1";
    selStress.addEventListener("change", () => {
      const v = selStress.value;

      // Manuell gesetzt
      if(v === "green" || v === "yellow" || v === "red"){
        nutzenSyncStress(v);
        return;
      }

      // Zurück auf "auto" => neu berechnen und anwenden
      const ev = nutzenEvaluateAll();
      nutzenSyncStress(ev.stress.mode);

      const whyTxt = ev.stress.triggers.length
        ? ("Auto-Trigger: " + ev.stress.triggers.join(" | "))
        : "Auto: keine Stress-Trigger erkannt.";

      const whyOv   = document.getElementById("nutzenOverlayStressWhy");
      const whyMain = document.getElementById("nutzenStressWhy");
      if(whyOv)   whyOv.textContent   = whyTxt;
      if(whyMain) whyMain.textContent = whyTxt;
    });
  }
}



let _actionsBound = false;
function bindOverlayActionsUI(){
  if(_actionsBound) return;
  _actionsBound = true;
  // deine bestehende Funktion bleibt – wir rufen sie einfach nur 1x
  // (Inhalt unverändert)
  const fp = ovGetEl("ov_fairPrice");
  const cp = ovGetEl("ov_currentPrice");
  const buy = ovGetEl("ov_buySelect");
  const add = ovGetEl("ov_addSelect");
  const clearBtn = ovGetEl("ov_clearActions");

  if(fp) fp.addEventListener("input", ovRenderActionsSummary);
  if(cp) cp.addEventListener("input", ovRenderActionsSummary);
  if(buy) buy.addEventListener("change", ovRenderActionsSummary);
  if(add) add.addEventListener("change", ovRenderActionsSummary);

  if(clearBtn){
    clearBtn.addEventListener("click", () => {
      if(fp) fp.value = "";
      if(cp) cp.value = "";
      if(buy) buy.value = "auto";
      if(add) add.value = "auto";
      ovRenderActionsSummary();
    });
  }
  ovRenderActionsSummary();
}






</script>
</body>
</html>
