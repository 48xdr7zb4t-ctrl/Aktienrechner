<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wachstum Rechner (Jahreswerte → CAGR)</title>
  <style>
    body{font-family:Arial, sans-serif;background:#f4f4f4;margin:0;padding:28px}
    .wrap{max-width:980px;margin:0 auto}
    .card{background:#fff;border-radius:14px;padding:18px 18px 8px;margin-bottom:16px;box-shadow:0 2px 10px rgba(0,0,0,.06)}
    h1{margin:0 0 10px;font-size:22px; text-align:center;}
    h2{margin:0 0 10px;font-size:18px}
    .muted{color:#666;font-size:13px;line-height:1.35; text-align:center;}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .grid3{display:grid;grid-template-columns:repeat(5, 1fr);gap:10px}
    label{font-size:13px;color:#333}
    input,select,button{width:100%;padding:10px;border-radius:10px;border:1px solid #d6d6d6;font-size:14px;box-sizing:border-box}
    button{background:#2f7dff;color:#fff;border:none;cursor:pointer;margin-top:10px}
    button:hover{opacity:.92}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .out{background:#fafafa;border:1px dashed #d6d6d6;border-radius:12px;padding:12px;margin-top:12px}
    .kpi{display:flex;justify-content:space-between;gap:10px;margin:8px 0}
    .kpi b{font-size:14px}
    .vol-muted { font-size:12px; color:#888; line-height:1.3; }
    .vol-subtitle { font-size:12px; color:#999; margin-top:4px; }
      
    .err{color:#b00020;font-size:13px;margin-top:8px}
    table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px}
    th,td{border:1px solid #e6e6e6;padding:8px;text-align:left}
    th{background:#f2f2f2}
    .small{font-size:12px;color:#666}
    @media (max-width:900px){
      .grid3{grid-template-columns:repeat(2, 1fr)}
    }
      .kpi.highlight b{
    font-size:16px;   /* etwas größer */
    font-weight:800;  /* fett */
  }
  
  #nutzenTable th { white-space: nowrap; }
#nutzenTable td { vertical-align: top; min-width: 140px; }
#nutzenTable .nutzenCell { white-space: nowrap; }


/* --- Nutzen: Rollen-Details (aufklappbar) --- */
.roleBox { margin-top:12px; }
.roleGrid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
@media (max-width:900px){ .roleGrid{ grid-template-columns:1fr; } }

.roleDetails {
  border:1px solid #e6e6e6;
  border-radius:12px;
  background:#fff;
  padding:10px 12px;
}
.roleDetails summary{
  cursor:pointer;
  font-weight:700;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  list-style:none;
}
.roleDetails summary::-webkit-details-marker{ display:none; }

.roleDetails summary .sumRow{
  
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;

}
.roleDetails summary { position: relative; z-index: 1; }
  /* Klick zählt immer für summary */

.roleBadge{
  font-size:12px;
  padding:3px 8px;
  border-radius:999px;
  background:#f2f2f2;
  white-space:nowrap;
}
.roleBadge.ok{ background:#eaf7ef; color:#1d6b3a; border:1px solid #cfe9d9; }
.roleBadge.bad{ background:#fdecec; color:#8a1f2a; border:1px solid #f6c9cf; }

.roleBadge.mid{ background:#fff3cd; color:#856404; border:1px solid #ffeeba; }


.roleMeta { margin-top:6px; font-size:12px; color:#666; line-height:1.35; }

.roleChecks{
  margin:10px 0 0;
  padding-left:18px;
  font-size:13px;
  line-height:1.45;
}
.roleChecks li{ margin:4px 0; }
.roleChecks .ok{ color:#1d6b3a; }
.roleChecks .bad{ color:#8a1f2a; }
.roleChecks .muted{ color:#777; }

 /* FIX: Nutzen-Buttons wieder klickbar (Overlay/Z-Index) */
#page-nutzen .card { position: relative; }
#nutzen_parseBtn, #nutzen_clearBtn, #nutzen_big, #nutzen_cagrYears {
  position: relative;
  z-index: 50;
}
#nutzenTable, #nutzen_roles, #nutzen_result {
  position: relative;
  z-index: 1;
}
  
#nutzen_bigMirror { display:none !important; }

/* ===============================
   OVERLAY: Rollen / Stress / Range
   =============================== */
.nutzenOverlayBackdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.45);
  display:none;
  z-index:9998;
}
.nutzenOverlay{
  position:fixed; inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9999;
  padding:18px;
}
.nutzenOverlayPanel{
  width:min(920px, 96vw);
  max-height:86vh;
  overflow:auto;
  background:#fff;
  border-radius:16px;
  box-shadow:0 10px 35px rgba(0,0,0,.22);
  border:1px solid #e9e9e9;
}
.nutzenOverlayHead{
  position:sticky;
  top:0;
  background:#fff;
  z-index:1;
  padding:14px 16px;
  border-bottom:1px solid #eee;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.nutzenOverlayTitle{
  font-size:16px;
  font-weight:800;
  margin:0;
}
.nutzenOverlayClose{
  width:auto;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid #d6d6d6;
  background:#f3f3f3;
  color:#333;
  cursor:pointer;
}
.nutzenOverlayBody{ padding:14px 16px; }

.overlayGrid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
}
@media (max-width:900px){
  .overlayGrid{ grid-template-columns:1fr; }
}

.overlayCard{
  border:1px solid #e6e6e6;
  border-radius:14px;
  background:#fafafa;
  padding:12px;
}
.overlayCard h3{
  margin:0 0 10px;
  font-size:14px;
}

.statusPill{
  display:inline-flex;
  align-items:center;
  gap:8px;
  font-size:12px;
  font-weight:700;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid #e6e6e6;
  background:#fff;
}
.statusDot{
  width:10px; height:10px; border-radius:999px;
  background:#bbb;
}
.statusGreen .statusDot{ background:#1d6b3a; }
.statusYellow .statusDot{ background:#b8860b; }
.statusRed .statusDot{ background:#8a1f2a; }

.roleChips{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin-top:8px;
}
.roleChip{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid #e6e6e6;
  background:#fff;
  font-size:12px;
  font-weight:700;
}
.roleChip.off{ opacity:.55; }

.overlayMiniTable{
  width:100%;
  border-collapse:collapse;
  font-size:12px;
  margin-top:10px;
}
.overlayMiniTable th, .overlayMiniTable td{
  border:1px solid #e6e6e6;
  padding:8px;
}
.overlayMiniTable th{ background:#f2f2f2; }

/* Overlay darf nur Klicks fressen, wenn es wirklich offen ist */
.nutzenOverlayBackdrop,
.nutzenOverlay{
  pointer-events: none;   /* wenn versteckt: keine Klicks blockieren */
}

/* wenn offen (per JS), dann wieder klickbar */
.nutzenOverlayBackdrop.isOpen,
.nutzenOverlay.isOpen{
  pointer-events: auto;
}


.statusDarkRed{ background:#5a0000; color:#fff; }
.statusDarkRed .statusDot{ background:#ff4d4d; } 

  </style>
</head>
<body>
<div class="wrap">


<!-- STARTSEITE (Menü) -->
<section id="page-home">

  <div class="card">
    <h1>Aktienübersicht</h1>
    <div class="muted">Wichtig bei Aktienkauf</div>
  </div>

  <div class="card">
    <div class="grid">
      <button type="button" onclick="goPage('etf')">Quellensteuerliste</button>
      <button type="button" onclick="goPage('finanztransaktionssteuer')">Finanztransaktionssteuer</button>
      <button type="button" onclick="goPage('cagr')">CAGR Rechner</button>
      <button type="button" onclick="goPage('icr')">Zinsdeckung (ICR) Rechner</button>
      <button type="button" onclick="goPage('volatility')">Volatilität (Std-Abw.)</button>
      <button type="button" onclick="goPage('checks')">Profitabel & FCF Check</button>
      <button type="button" onclick="goPage('fairprice')">Fairer Preis Rechner</button>
      <button type="button" onclick="goPage('fcfpayout')">(FCF-Payout Rechner)-in FCF Check</button>
      <button type="button" onclick="goPage('nutzen')">Nutzen Check</button>
      <button type="button" onclick="goPage('fx')">USD ⇄ EUR Rechner</button>

    </div>
  </div>
</section>

<section id="page-cagr" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Jahreswerte → CAGR + Jahr-zu-Jahr Wachstum</h1>
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <label>Was berechnen?</label>
        <select id="mode">
          <option value="revenue">Umsatz </option>
          <option value="eps">EPS</option>
          <option value="opmargin">Operative Marge</option>
          <option value="dividend">Dividende </option>
          <option value="price5y">Kurs </option>
          
        </select>
      </div>
      <div>
 <label>Anzahl Jahre (1–4)</label>
 <select id="years">
  <option value="2">1 Jahr</option>   <!-- 2 Datenpunkte => 1 Jahr -->
  <option value="3">2 Jahre</option>  <!-- 3 Datenpunkte => 2 Jahre -->
  <option value="4">3 Jahre</option>  <!-- 4 Datenpunkte => 3 Jahre -->
  <option value="5" selected>4 Jahre</option> <!-- 5 Datenpunkte => 4 Jahre -->
</select>

    </div>
    </div>

    <div style="margin-top:14px">
      <div id="yearInputs" class="grid3" style="margin-top:8px"></div>
      <div class="small">Erlaubt: 1.250.000 oder 1.250.000,50 oder 1250000</div>
    </div>

    <!-- Kurs 5Y (CAGR) - extra Eingabebox -->
<div id="price5yBox" style="display:none; margin-top:14px">
  <div class="grid">
    <div>
      <label>Kurs vor ~4 Jahren</label>
      <input id="pStart" inputmode="decimal" placeholder="z.B. 25,50" />
    </div>
    <div>
      <label>Kurs heute</label>
      <input id="pEnd" inputmode="decimal" placeholder="z.B. 40,10" />
    </div>
  </div>

  <div class="grid" style="margin-top:12px">
    <div>
    <label>Jahre</label>
     <input id="pYears" type="number" min="1" max="4" step="1" value="4" />
     <div class="small">1–4 Jahre einstellbar (wie bei FY-Logik üblich).</div>
    </div>
    <div></div>
  </div>
</div>

    <button id="calc" type="button">Berechnen</button>

    <div id="err" class="err" style="display:none"></div>
<div id="out" class="out" style="display:none"></div>

  </div> <!-- Ende: .card (CAGR) -->
</section> <!-- Ende: #page-cagr -->

<section id="page-fairprice" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Fairer Preis Rechner</h1>
  </div>

  <div class="card">
    <div class="grid">
      <!-- Rechner A: Implizites KGV Target aus Price Target -->
      <div class="out">
        <div class="kpi"><span><b>KGV Target berechnen</b></span><span class="small">Price Target / EPS</span></div>

        <label for="fp_epsA">EPS (Diluted, FY)</label>
        <input id="fp_epsA" inputmode="decimal" placeholder="z.B. 2,50" />

        <label for="fp_priceTarget" style="margin-top:10px">Price Target</label>
        <input id="fp_priceTarget" inputmode="decimal" placeholder="z.B. 40" />

        <button id="fp_calcPe" type="button" style="margin-top:10px">KGV Target berechnen</button>

        <div id="fp_peOut" class="out" style="display:none; margin-top:10px"></div>
        <div id="fp_peErr" class="err" style="display:none"></div>
      </div>

      <!-- Rechner B: Fairer Preis aus EPS & KGV Target -->
      <div class="out">
        <div class="kpi"><span><b>Fairer Preis</b></span><span class="small">EPS × KGV Target</span></div>

        <label for="fp_epsB">EPS (Diluted, FY)</label>
        <input id="fp_epsB" inputmode="decimal" placeholder="z.B. 2,50" />

        <label for="fp_peTarget" style="margin-top:10px">KGV Target</label>
        <input id="fp_peTarget" inputmode="decimal" placeholder="z.B. 15"  />

        <button id="fp_calcFair" type="button" style="margin-top:10px">Fairen Preis berechnen</button>

        <div id="fp_fairOut" class="out" style="display:none; margin-top:10px"></div>
        <div id="fp_fairErr" class="err" style="display:none"></div>
      </div>
    </div>
  </div>
</section>

<section id="page-fcfpayout" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>FCF-Payout Rechner</h1>
    <div class="muted">Dividenden gesamt ÷ Free Cash Flow (FCF)</div>
  </div>

  <div class="card">
    <div class="grid">

      <!-- Option A: Dividenden gesamt direkt -->
      <div class="out">
        <div class="kpi">
          <span><b>Option A: Dividenden gesamt</b></span>
          <span class="small">direkt eingeben</span>
        </div>

        <label for="fcf_divTotal">Dividenden gesamt (z. B. FY/TTM) Common Dividends Paid</label>
        <input id="fcf_divTotal" inputmode="decimal" placeholder="z.B. 1.250.000.000" />

        <label for="fcf_fcfA" style="margin-top:10px">FCF (gleiche Periode) 1Y</label>
        <input id="fcf_fcfA" inputmode="decimal" placeholder="z.B. 2.000.000.000" />

        <button id="fcf_calcA" type="button" style="margin-top:10px">FCF-Payout berechnen</button>

        <div id="fcf_outA" class="out" style="display:none; margin-top:10px"></div>
        <div id="fcf_errA" class="err" style="display:none"></div>
      </div>

      <!-- Option B: Dividende/Aktie + Aktienanzahl -->
      <div class="out">
        <div class="kpi">
          <span><b>Option B: Dividende/Aktie × Aktien</b></span>
          <span class="small">Dividenden gesamt berechnen</span>
        </div>

        <label for="fcf_dps">Dividende je Aktie (DPS)</label>
        <input id="fcf_dps" inputmode="decimal" placeholder="z.B. 2,10" />

        <label for="fcf_shares" style="margin-top:10px">Aktienanzahl (Shares, avg.)</label>
        <input id="fcf_shares" inputmode="decimal" placeholder="z.B. 1.100.000.000" />

        <label for="fcf_fcfB" style="margin-top:10px">FCF (gleiche Periode)</label>
        <input id="fcf_fcfB" inputmode="decimal" placeholder="z.B. 2.000.000.000" />

        <button id="fcf_calcB" type="button" style="margin-top:10px">FCF-Payout berechnen</button>

        <div id="fcf_outB" class="out" style="display:none; margin-top:10px"></div>
        <div id="fcf_errB" class="err" style="display:none"></div>
      </div>

    </div>

    <div class="small" style="margin-top:10px">
      Hinweis: Periode muss identisch sein (FY oder TTM). Wenn FCF ≤ 0, ist „Payout“ nicht sinnvoll (nicht gedeckt).
    </div>
  </div>
</section>


<section id="page-icr" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Zinsdeckung (ICR) Rechner</h1>
    <div class="muted">Typisch: EBIT ÷ Zinsaufwand (Interest Expense)</div>
  </div>

  <div class="card">
    <div class="grid">
      <div class="out">
        <div class="kpi">
          <span><b>ICR berechnen</b></span>
          <span class="small">EBIT / Zinsaufwand</span>
        </div>

        <label for="icr_ebit">EBIT</label>
        <input id="icr_ebit" inputmode="decimal" placeholder="z.B. 1.250.000.000" />

        <label for="icr_interest" style="margin-top:10px">Zinsaufwand (Interest Expense)</label>
        <input id="icr_interest" inputmode="decimal" placeholder="z.B. 150.000.000" />

        <button id="icr_calc" type="button" style="margin-top:10px">Zinsdeckung berechnen</button>

        <div id="icr_out" class="out" style="display:none; margin-top:10px"></div>
        <div id="icr_err" class="err" style="display:none"></div>

        <div class="small" style="margin-top:10px">
          Hinweis: In Cashflow/Income Statements ist „Interest Expense“ oft negativ (Vorzeichen). Dieser Rechner nutzt automatisch den Betrag (|Zinsaufwand|).
        </div>
      </div>

      <div class="out">
        <div class="kpi">
          <span><b>Interpretation (grob)</b></span>
          <span class="small">Daumenregeln</span>
        </div>
        <div class="small">
          • &lt; 2: kritisch<br/>
          • 2–4: eher schwach/erhöhtes Risiko<br/>
          • ≥ 4: eher solide<br/>
          • ≥ 8: sehr komfortabel (branchenabhängig)
        </div>
      </div>
    </div>
  </div>
</section>



<section id="page-checks" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Checks</h1>
    <div class="muted">Profitabel (Net Income &gt; 0) und FCF positiv (FCF &gt; 0)</div>
   </div>

   <div class="card">
    <div class="grid">

      <!-- Rechner 1: Profitabel -->
      <div class="out">
        <div class="kpi">
          <span><b>Profitabel?</b></span>
          <span class="small">Net Income (FY) &gt; 0</span>
        </div>

        <label for="chk_netIncome">Net Income (FY)</label>
        <input id="chk_netIncome" inputmode="decimal" placeholder="z.B. 1250000 oder 1.250.000" />

        <button id="chk_profitBtn" type="button">Prüfen</button>

        <div id="chk_profitErr" class="err" style="display:none"></div>
        <div id="chk_profitOut" class="out" style="display:none; margin-top:10px"></div>
      </div>

      <!-- Rechner 2: FCF positiv -->
      <div class="out">
        <div class="kpi">
          <span><b>FCF positiv?</b></span>
          <span class="small">FCF (FY) &gt; 0</span>
        </div>

        <label for="chk_fcf">FCF (FY)</label>
        <input id="chk_fcf" inputmode="decimal" placeholder="z.B. 350000 oder 350.000" />

        <button id="chk_fcfBtn" type="button">Prüfen</button>

        <div id="chk_fcfErr" class="err" style="display:none"></div>
        <div id="chk_fcfOut" class="out" style="display:none; margin-top:10px"></div>
      </div>



      <!-- Rechner 3: FCF aus OCF & CapEx -->
      <div class="out">
        <div class="kpi">
          <span><b>FCF berechnen</b></span>
          <span class="small">OCF − CapEx (oder + wenn CapEx negativ)</span>
        </div>

        <label for="chk_ocf">Operating Cash Flow (OCF)</label>
        <input id="chk_ocf" inputmode="decimal" placeholder="z.B. 1.250.000.000" />

        <label for="chk_capex" style="margin-top:10px">CapEx</label>
        <input id="chk_capex" inputmode="decimal" placeholder="z.B. 500.000.000 oder -500.000.000" />

        <div class="small" style="margin-top:8px">
          Regel: Wenn CapEx negativ eingegeben wird (z.B. -500), dann FCF = OCF + CapEx.
          Wenn CapEx positiv eingegeben wird, dann FCF = OCF − CapEx.
        </div>

        <button id="chk_fcfFromBtn" type="button" style="margin-top:10px">FCF berechnen → in Check übernehmen</button>

        <div id="chk_fcfFromErr" class="err" style="display:none"></div>
        <div id="chk_fcfFromOut" class="out" style="display:none; margin-top:10px"></div>
      </div>

      <!-- Rechner 4: FCF-Payout -->
<div class="out">
  <div class="kpi">
    <span><b>FCF-Payout</b></span>
    <span class="small">|Dividends Paid| ÷ FCF</span>
  </div>

  <label for="chk_divPaid">Dividends Paid (gesamt, FY/TTM)</label>
  <input id="chk_divPaid" inputmode="decimal" placeholder="z.B. -1.250.000.000 oder 1.250.000.000" />

  <label for="chk_fcfPayoutBase" style="margin-top:10px">FCF (gleiche Periode) </label>
  <input id="chk_fcfPayoutBase" inputmode="decimal" placeholder="z.B. 2.000.000.000" />

  <button id="chk_fcfPayoutBtn" type="button" style="margin-top:10px">FCF-Payout berechnen</button>

  <div id="chk_fcfPayoutErr" class="err" style="display:none"></div>
  <div id="chk_fcfPayoutOut" class="out" style="display:none; margin-top:10px"></div>

  <div class="small" style="margin-top:8px">
    Hinweis: Dividends Paid ist oft negativ → wird als Betrag (|…|) gerechnet. Wenn FCF ≤ 0, ist Payout nicht sinnvoll.
  </div>
    </div> 
  </div>   
</section>


<section id="page-volatility" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Volatilität (Std-Abw.)</h1>
    <div class="muted">
      Füge Kurs-Historie ein (z. B. von StockAnalysis: Date, Open, High, Low, Close, Adj Close, Change %, Volume).
      Der Rechner nutzt standardmäßig <b>Adj Close</b> (falls vorhanden), sonst <b>Close</b>.
    </div>
  </div>

  <div class="card">
    <label for="vol_big">Großes Eingabefeld (Historie)</label>
    <textarea id="vol_big" rows="10"
      style="width:100%;padding:10px;border-radius:10px;border:1px solid #d6d6d6;font-size:14px;box-sizing:border-box;resize:vertical"
      placeholder="Einfach hier reinkopieren…"></textarea>

    <div class="grid" style="margin-top:12px">
  <details style="margin-top:10px">
  <summary class="vol-muted" style="cursor:pointer">Erweiterte Optionen (Returns / Annualisierung)</summary>

  <div class="out" style="margin-top:10px">
    <div class="kpi"><span><b>Return-Definition</b></span><span class="vol-subtitle">optional</span></div>

    <label class="vol-muted" style="display:flex;gap:10px;align-items:center;margin-top:8px">
      <input type="radio" name="vol_retType" value="simple" checked>
      <span>Simple Returns</span>
    </label>
    <div class="vol-muted">Formel: (Pₜ / Pₜ₋₁ − 1) Simple Return</div>

    <label class="vol-muted" style="display:flex;gap:10px;align-items:center;margin-top:10px">
      <input type="radio" name="vol_retType" value="log">
      <span>Log Returns</span>
    </label>
    <div class="vol-muted">Formel: ln(Pₜ / Pₜ₋₁)  Log Return</div>

    <div style="margin-top:10px">
      <label class="vol-muted" for="vol_annualize">Annualisieren?</label>
      <select id="vol_annualize">
        <option value="no" selected>Nein (täglich)</option>
        <option value="yes">Ja (× √252)</option>
      </select>
      <div class="vol-muted">252 ≈ typische Handelstage/Jahr.</div>
    </div>
  </div>
</details>
      <div class="out">
        <div class="kpi"><span><b>Berechnung</b></span><span class="small">Aktion</span></div>
        <button type="button" id="vol_calcBtn">Volatilität berechnen</button>
        <button type="button" id="vol_clearBtn" style="background:#eee;color:#333">Leeren</button>
        <div id="vol_err" class="err" style="display:none;margin-top:10px"></div>
      </div>
    </div>

    <div id="vol_out" class="out" style="display:none;margin-top:12px"></div>

    <div class="small" style="margin-top:10px">
      Tipp: Wenn du Daten <b>neueste zuerst</b> einfügst, ist das okay – der Rechner sortiert automatisch nach Datum.
    </div>
  </div>
</section>

<section id="page-fx" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>USD ⇄ EUR Rechner</h1>
    <div class="muted">Standard: Offline-Kurs (vorgegeben). Optional kannst du den Kurs ändern oder per Button aktualisieren.</div>
  </div>

  <div class="card">
    <div class="grid">

      <div class="out">
        <div class="kpi">
          <span><b>Umrechnen</b></span>
          <span class="small">USD ↔ EUR</span>
        </div>

        <label for="fx_amount">Betrag</label>
        <input id="fx_amount" inputmode="decimal" placeholder="z.B. 100" />

        <div class="grid" style="margin-top:10px">
          <div>
            <label for="fx_from">Von</label>
            <select id="fx_from">
              <option value="USD" selected>USD</option>
              <option value="EUR">EUR</option>
            </select>
          </div>
          <div>
            <label for="fx_to">Nach</label>
            <select id="fx_to">
              <option value="EUR" selected>EUR</option>
              <option value="USD">USD</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <button type="button" id="fx_swapBtn" style="background:#eee;color:#333">↔ Swap</button>
          <button type="button" id="fx_refreshBtn">Kurs aktualisieren</button>
        </div>

<label for="fx_manualRate" style="margin-top:10px">Kurs (Standard = Offline-Default, optional anpassen)</label>
<input id="fx_manualRate" inputmode="decimal" placeholder="z.B. 0,92" />
<div class="small">Bedeutung: <b>1 (Von)</b> = Kurs in <b>(Nach)</b>. Beispiel: 1 USD = 0,92 EUR.</div>

        <button type="button" id="fx_calcBtn" style="margin-top:10px">Umrechnen</button>

        <div id="fx_err" class="err" style="display:none"></div>
        <div id="fx_out" class="out" style="display:none; margin-top:10px"></div>

        <div class="small" style="margin-top:10px">
         Hinweis: Frankfurter liefert i. d. R. Tageskurse (ECB, werktags aktualisiert).
<a href="https://frankfurter.dev/" target="_blank" rel="noopener">Quelle</a>
      </div>

      </div> 


      <div class="out">
        <div class="kpi">
          <span><b>Aktueller Kurs</b></span>
          <span class="small">Auto</span>
        </div>

        <div id="fx_rateBox" class="small" style="line-height:1.5">
          Kurs noch nicht geladen.
        </div>
      </div>

    </div>
  </div>
</section>


<section id="page-nutzen" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>
  </div>

  <div class="card">
    <h1>Nutzen Check</h1>
    <div class="muted">
      Tipp: Werte aus Excel/Google Sheets kopieren und hier einfügen (Tabs werden automatisch erkannt).
      Trennzeichen: Tab (Excel), Semikolon ; oder Zeilenumbrüche.
    </div>
  </div>

<div class="row" style="gap:10px; align-items:flex-end; margin-top:10px">
  <div style="min-width:220px">
    <label for="nutzen_cagrYears">CAGR Jahre (1–4)</label>
    <select id="nutzen_cagrYears">
      <option value="1">1 Jahr</option>
      <option value="2">2 Jahre</option>
      <option value="3">3 Jahre</option>
      <option value="4" selected>4 Jahre</option>
    </select>
    <div class="small">Nutzt automatisch die passenden CAGR-Spalten.</div>
  </div>

  <div style="min-width:220px">
    <label for="nutzen_volYears">Volatilität Jahr</label>
    <select id="nutzen_volYears">
      <option value="1">1Y</option>
      <option value="5">5Y</option>
      <option value="10">10Y</option>
    </select>
  </div>
</div>

  <div class="card">
    <div class="row" style="gap:10px; align-items:flex-end;">
      <div style="flex:1; min-width:220px;">
        <label for="nutzen_big">Großes Eingabefeld (55 Werte in Reihenfolge)</label>
        <textarea id="nutzen_big" rows="4" style="width:100%;padding:10px;border-radius:10px;border:1px solid #d6d6d6;font-size:14px;box-sizing:border-box;resize:vertical"></textarea>
        <div class="small" style="margin-top:6px">
          Reihenfolge = exakt die Überschriften (von links nach rechts). Fehlende Werte bleiben leer.
        </div>
      </div>
      <div style="min-width:220px">
        <button type="button" id="nutzen_parseBtn">Auf Spalten verteilen</button>
        <button type="button" id="nutzen_clearBtn" style="background:#eee;color:#333">Leeren</button>
        <button type="button" id="nutzen_overlayBtn" style="background:#111">Overlay (Rollen / Stress / Range)</button>
        
      </div>
    </div>

    <div style="overflow:auto; margin-top:12px">
      <table id="nutzenTable" style="min-width:2600px">
        <thead>
          <tr id="nutzenHeadRow"></tr>
        </thead>

        <!-- 1 großes Feld über die gesamte Breite (colspan=31) -->
        <tbody>
          <tr>
            <td id="nutzenBigCell" colspan="55" style="background:#fafafa">
              <div class="small" style="margin-bottom:6px;color:#666">

              </div>
              <!-- optionaler Spiegel-Output: wird per JS gesetzt -->
              
            </td>
          </tr>

          <!-- Ergebnis-Zeile: 31 Zellen -->
          <tr id="nutzenValueRow"></tr>
        </tbody>
      </table>
      <div id="nutzen_result" class="out" style="display:none; margin-top:12px"></div>

      <!-- Stress Flag (UI – Logik kommt später) -->
<div id="nutzen_stressBox" class="out" style="margin-top:12px">
  <div class="kpi">
    <span><b>Stress Flag</b></span>
  </div>

  <div id="nutzenStressPill" class="statusPill" style="margin-top:8px">
    <span class="statusDot"></span>
    <span id="nutzenStressText">– (noch nicht berechnet)</span>
  </div>

      </select>
    </div>
    <div></div>
  </div>

</div>
      <div id="nutzen_roles" class="roleBox"></div>

    <!-- Erklärungen (Hauptseite) -->
<div id="nutzen_explainBox" class="out" style="margin-top:12px">
  <div class="kpi">
    <span><b>Erklärungen</b></span>
  </div>

  <!-- 1) Kaufen/Nachkaufen Logik (sichtbar) -->
  <div style="margin-top:10px">
    <div class="small" style="color:#666; font-weight:700">Kaufen / Nachkaufen – Logik</div>
    <div class="small" style="margin-top:6px;color:#666" id="nutzenBuyLogicExplain">
      <!-- wird per JS gefüllt -->
      –
    </div>
  </div>

  <!-- 2) Stress Logik (sichtbar, darunter) -->
  <div style="margin-top:12px">
    <div class="small" style="color:#666; font-weight:700">Stress Flag – warum diese Farbe?</div>
    <div class="small" style="margin-top:6px;color:#666" id="nutzenStressLogicExplain">
      

      <!-- 3) Rollen – Base/Health -->
<div style="margin-top:12px">
  <div class="small" style="color:#666; font-weight:700">Rollen – Base/Health (Kurz)</div>
  <div class="small" style="margin-top:6px;color:#666; white-space:pre-line" id="nutzenRolesLogicExplain">–</div>
</div>

      
    </div>
  </div>
</div>

      <div id="nutzenRolesStressLegend" class="small" style="margin-top:8px;color:#666">
  <!-- wird per JS gefüllt -->
</div>


    <div class="small" style="margin-top:10px">
      Hinweis: Die Werte werden als Text verteilt (z. B. „12,5%“,  ja“, „1.250.000“ bleibt erhalten).
    </div>
  </div>
</section>


<!-- OVERLAY: Rollen / Stress / Kauf+Nachkauf -->
<div id="nutzenOverlayBackdrop" class="nutzenOverlayBackdrop"></div>

<div id="nutzenOverlay" class="nutzenOverlay" aria-hidden="true">
  <div class="nutzenOverlayPanel" role="dialog" aria-modal="true" aria-labelledby="nutzenOverlayTitle">
    <div class="nutzenOverlayHead">
      <div>
        <div id="nutzenOverlayTitle" class="nutzenOverlayTitle">Nutzen-Overlay</div>
      </div>
      <button type="button" class="nutzenOverlayClose" id="nutzenOverlayCloseBtn">✕ Schließen</button>
    </div>

    <div class="nutzenOverlayBody">
      <div class="overlayGrid">

        <!-- Rollen -->
        <div class="overlayCard">
          <h3>Rollen</h3>
          <div class="small" style="color:#666">
        
          </div>

          <div class="roleChips" id="nutzenOverlayRoles">
            <!-- wird per JS gefüllt -->
          </div>

    
          <div id="nutzenOverlayRolesStressLegend" class="small" style="margin-top:10px;color:#666">
  <!-- wird per JS gefüllt -->
</div>

        </div>



        <!-- Stress Flag -->
        <div class="overlayCard">
          <h3>Stress Flag</h3>

          <div id="nutzenOverlayStressPill" class="statusPill">
            <span class="statusDot"></span>
            <span id="nutzenOverlayStressText">– (noch nicht berechnet)</span>
          </div>


          <div class="grid" style="margin-top:8px">
    
            <div></div>
          </div>



          <!-- Preis & Aktionen (UI – keine Logik) -->
<div class="out" style="margin-top:12px">
  <div class="kpi">
    <span><b>Preis & Aktionen</b></span>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <label>Fairer Preis (manuell)</label>
      <input id="ov_fairPrice" type="number" step="0.01" placeholder="z. B. 400">
    </div>

    <div>
      <label>Kurs aktuell (optional)</label>
      <input id="ov_currentPrice" type="number" step="0.01" placeholder="z. B. 382.50">
    </div>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <label>Kaufen (UI)</label>
      <select id="ov_buySelect" disabled>
        <option value="auto" selected>Auto (später)</option>
        <option value="yes">Ja</option>
        <option value="maybe">Vielleicht</option>
        <option value="no">Nein</option>
      </select>
    </div>

    <div>
      <label>Nachkaufen (UI)</label>
      <select id="ov_addSelect" disabled>>
        <option value="auto" selected>Auto (später)</option>
        <option value="yes">Ja</option>
        <option value="maybe">Vielleicht</option>
        <option value="no">Nein</option>
      </select>
    </div>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <div class="small" style="color:#666">Status</div>
      <div id="ov_actionSummary" class="small" style="margin-top:6px">
        Noch nichts gesetzt.
      </div>
    </div>
    <div>
      <button type="button" id="ov_clearActions" class="btn" style="margin-top:18px">
        Zurücksetzen
      </button>
    </div>
  </div>
</div>


        </div>

      </div>

      <!-- Kauf / Nachkauf -->
      <div class="overlayCard" style="margin-top:12px">
        <h3>Kauf- & Nachkauf-Range</h3>
        <div class="small" style="color:#666">
          UI steht — Berechnung kommt später. Unten zeigen wir schon die vorhandenen Werte aus deiner Tabelle (falls befüllt).
        </div>

        <table class="overlayMiniTable">
          <thead>
            <tr>
              <th>Feld</th>
              <th>Wert (aus Tabelle)</th>
            </tr>
          </thead>
          <tbody id="nutzenOverlayRangeBase">
            <!-- wird per JS gefüllt -->
          </tbody>
        </table>


      </div>

    </div>
  </div>
</div>


<section id="page-etf" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>

      <div class="row" style="align-items:flex-end; margin-top:10px">
      <div style="flex:1; min-width:220px">
        <label for="whtSearch">Suche (Land / Text)</label>
        <input id="whtSearch" type="text" placeholder="z.B. USA, Schweiz, 15%, Rückforderung …" />
      </div>
    </div>

    <h1 style="margin-top:10px">Quellensteuerliste</h1>
    <div class="muted">Übersicht: Standard-WHT, DBA (DE typ.) und DE-Behandlung (Privatanleger).</div>
    <div class="muted">Dividenden – Privatperson (DE steuerlich ansässig) - als Vergleichbroker wird Scalable genutzt</div>
  </div>

  <div class="card">
    <table id="whtTable">
      <thead>
        <tr>
          <th>Land</th>
          <th>Standard-WHT Dividenden</th>
          <th>DBA DE (typ.)</th>
          <th>DE-Behandlung (Privatanleger)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="small">Hinweis: Werte sind vereinfacht und beziehen sich auf die typische Abwicklung bei Scalable Capital. Je Wertpapier, Lagerstelle und Auszahlungsweg sind Abweichungen möglich; ggf. ist Rückforderung nötig.</div>
  </div>
</section>



<section id="page-finanztransaktionssteuer" style="display:none">
  <div class="card">
    <button type="button" onclick="goPage('home')" style="background:#e9eefc;color:#1c3f99">← Zurück</button>

    <!-- SUCHFELD GANZ OBEN (nur FTS-Seite) -->
    <div class="row" style="align-items:flex-end; margin-top:10px">
      <div style="flex:1; min-width:220px">
        <label for="ftsSearch">Suche</label>
        <input id="ftsSearch" type="text" placeholder="z.B. Frankreich, 0,3%, Derivate …" />
      </div>
    </div>

    <h1 style="margin-top:10px">Finanztransaktionssteuer</h1>
    <div class="muted">Übersicht und Hinweise.</div>
  </div>

<table id="ftsTable">
  <thead>
    <tr>
      <th>Land</th>
      <th>Steuer (typ.)</th>
      <th>Wann fällt sie an?</th>
      <th>Scalable / Hinweis</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>
<div class="small">
  Hinweis: FTS-Regeln unterscheiden sich stark je Land und Produkt (Aktie/ETF/Derivat), Handelsplatz und Emittent.
  Werte sind vereinfacht als Orientierung.
</div>
</section>



</div>
<script>
   let whtSearchBound = false;
   let ftsSearchBound = false;
   let nutzenBound = false;
   let fxBound = false;


     const WHT_DATA = [
   { land:"Deutschland",
   standard:"25% KapESt + 5,5% Soli auf KapESt (+ ggf. KiSt)",
   dba:"–",
   de:"Scalable führt die Abgeltungsteuer (KapESt, Soli, ggf. KiSt) bei steuerpflichtigen Vorgängen automatisch ab; Freistellungsauftrag und Verlustverrechnungstöpfe werden dabei berücksichtigt."}, //  [oai_citation:0‡Scalable Capital Hilfe](https://help.scalable.capital/steuern-de12f868/wie-funktioniert-die-abf%C3%BChrung-der-abgeltungssteuer-d616ad21?utm_source=chatgpt.com)

   { land:"USA",
   standard:"30%",
   dba:"15% (mit W-8BEN)",
   de:"Für US-Dividenden gilt ohne gültiges W-8BEN i. d. R. 30% Quellensteuer. Mit korrekt hinterlegtem W-8BEN wird typischerweise der DBA-Satz von 15% angewendet. Die deutsche Abgeltungsteuer führt Scalable automatisch ab; die anrechenbare US-Quellensteuer wird im Rahmen der deutschen Besteuerung berücksichtigt. Eine Rückforderung ist meist nur nötig, wenn zu viel (z. B. 30% statt 15%) einbehalten wurde."}, //  [oai_citation:1‡de.scalable.capital](https://de.scalable.capital/assets/kcbf79ije7q7/3p8akTjsF4CUDdr7sQvFRS/ed449b9903137fb5e259f2ae17adc6f7/Scalable_Capital_-_Ausfuellhilfe_fuer_das_US-Formular_W-8BEN.pdf?utm_source=chatgpt.com)

   { land:"Kanada",
   standard:"25%",
   dba:"15%",
   de:"Kanada behält ohne DBA-Ermäßigung grundsätzlich 25% Non-Resident Tax ein. Nach DBA Kanada–Deutschland sind Dividenden für den in Deutschland Ansässigen auf max. 15% begrenzt (Portfolio-/Privatanleger-Fall). Scalable führt die deutsche Abgeltungsteuer automatisch ab; ein Über-DBA-Anteil wäre (falls er überhaupt anfällt) nur per Rückforderung in Kanada zu klären."}, //  [oai_citation:2‡canada.ca](https://www.canada.ca/en/revenue-agency/services/forms-publications/publications/t4058/non-residents-income-tax.html?utm_source=chatgpt.com)

   {land:"Mexiko",
   standard:"10%",
   dba:"15% (Privatanleger-Fall; 5% nur für qualifizierte Gesellschaften ≥10%)",
   de:"Mexiko erhebt auf Dividenden an Nichtansässige typischerweise 10% Quellensteuer. Das DBA Deutschland–Mexiko begrenzt Dividenden zwar grundsätzlich auf 15% (Privatanleger), aber weil der mexikanische Standardsatz schon darunter liegt, gibt es hier normalerweise keinen „Über-DBA“-Teil zum Zurückfordern. Scalable führt die deutsche Abgeltungsteuer automatisch ab; Anrechnung nur im Rahmen der deutschen Regeln."}, //  [oai_citation:3‡PwC Steuerübersichten](https://taxsummaries.pwc.com/mexico/corporate/withholding-taxes?utm_source=chatgpt.com)
 
   { land:"Brasilien",
   standard:"10% (seit 01/2026 auf Dividenden/Profite an Ausländer; zuvor i. d. R. 0%)",
   dba:"– (kein DBA/DTT Deutschland–Brasilien)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. In Brasilien fällt (seit 01/2026) i. d. R. 10% Quellensteuer auf ins Ausland ausgeschüttete Dividenden/Profite an; eine DBA-Reduktion gibt es mangels DBA nicht. Anrechnung in DE nur im Rahmen der deutschen Anrechnungsregeln und nur, soweit tatsächlich Quellensteuer einbehalten wurde."}, //  [oai_citation:0‡mayerbrown.com](https://www.mayerbrown.com/en/insights/publications/2025/12/enactment-of-law-no-15270-2025-which-establishes-dividend-taxation-expands-the-exemption-threshold-and-introduces-a-minimum-tax-on-high-incomes?utm_source=chatgpt.com)

   { land:"Vereinigtes Königreich (UK)",
   standard:"0% (normale UK-Aktien-Dividenden); 20% bei REIT/PAIF-‚Property Income Distributions‘",
   dba:"0% (normale Dividenden); bei REIT/PAIF ggf. Ermäßigung/Erstattung nach DBA möglich",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Bei normalen UK-Dividenden gibt es i. d. R. keine UK-Quellensteuer → keine Anrechnung/Rückforderung. Achtung Sonderfall: UK-REIT/PAIF-Ausschüttungen können mit UK-WHT (typisch 20%) kommen; hier kann je nach DBA/Status ggf. Erstattung/Reduktion relevant sein."}, //  [oai_citation:1‡PwC Steuerübersichten](https://taxsummaries.pwc.com/united-kingdom/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Irland",
   standard:"25% Dividend Withholding Tax (DWT) – kann für qualifizierte Nicht-Residenten oft vollständig befreit werden (Erklärung/Intermediär nötig)",
   dba:"15% (Obergrenze, falls überhaupt einbehalten wird; praktisch oft 0% bei korrekter Non-Resident-Befreiung)",
   de:"Scalable: DE-Steuer automatisch. Irland hat grundsätzlich 25% DWT, aber Nicht-Residenten aus ‚relevant territories‘ (u. a. DE) können bei korrekter Non-Resident-Erklärung (z. B. via Intermediär/Agent, Form V2A-Logik) häufig brutto (0% DWT) erhalten. Wenn dennoch einbehalten wird, ist der DBA-Gedanke typischerweise max. 15% – ein darüber hinausgehender Einbehalt wäre ggf. per Rückforderung in Irland zu klären."}, //  [oai_citation:2‡PwC Steuerübersichten](https://taxsummaries.pwc.com/ireland/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Frankreich",
   standard:"12,8% (Privatanleger/Individuals)",
   dba:"15% (DBA-Obergrenze; effektiv meist 12,8% weil Standard darunter)",
   de:"Scalable: DE-Steuer automatisch. Frankreich behält bei Privatanlegern i. d. R. 12,8% Quellensteuer ein; das liegt unter der typischen DBA-Obergrenze (15%). Rückforderung ist in der Praxis eher ein Thema, wenn ausnahmsweise mehr als 12,8% einbehalten wurde oder besondere Konstellationen vorliegen."}, //  [oai_citation:3‡PwC Steuerübersichten](https://taxsummaries.pwc.com/france/corporate/withholding-taxes?utm_source=chatgpt.com)
 
   { land:"Niederlande",
   standard:"15% Dividenden-Quellensteuer",
   dba:"15% (Privatanleger/Portfolio-Dividenden; praktisch i. d. R. keine Reduktion nötig, weil Standard = DBA)",
   de:"Scalable: DE-Steuer automatisch. Niederlande behalten typischerweise 15% auf Dividenden ein; diese 15% sind in DE grundsätzlich anrechenbar → meist kein Rückforderungsrest."}, //  [oai_citation:0‡business.gov.nl](https://business.gov.nl/regulations/dividend-tax/?utm_source=chatgpt.com)

   { land:"Belgien",
   standard:"30% Dividenden-Quellensteuer",
   dba:"15% (typischer DBA-Satz für Privatanleger/Portfolio-Dividenden)",
   de:"Scalable: DE-Steuer automatisch. Belgien behält standardmäßig 30% ein; in DE ist i. d. R. nur bis zum DBA-Satz (typisch 15%) anrechenbar. Der darüber hinausgehende Teil (typisch 15%-Punkte) wäre – falls du ihn reduzieren willst – nur über Erstattung/Refund in Belgien zu bekommen."}, //  [oai_citation:1‡Bird & Bird](https://www.twobirds.com/en/insights/2025/belgium/belgium-increase-of-the-withholding-tax-on-dividends--does-this-reform-really-undermine-the-attracti?utm_source=chatgpt.com)

   { land:"Luxemburg",
   standard:"15% Dividenden-Quellensteuer",
   dba:"15% (Privatanleger; 5% nur für qualifizierte Gesellschaften ≥10%)",
   de:"Scalable: DE-Steuer automatisch. Luxemburg hat als Standardsatz 15%; für Privatanleger entspricht das i. d. R. auch dem DBA-Satz → in DE grundsätzlich anrechenbar, meist kein Rückforderungsrest."}, //  [oai_citation:2‡Clearstream](https://www.clearstream.com/clearstream-en/res-library/market-coverage/equities-double-taxation-treaties-concluded-by-luxembourg-and-currently-in-force-1313108?utm_source=chatgpt.com)

   { land:"Schweiz",
   standard:"35% Quellensteuer (Verrechnungssteuer) auf Dividenden",
   dba:"15% (Restbelastung nach DBA; typischer Refund-Anteil ~20%-Punkte)",
   de:"Scalable: DE-Steuer automatisch. Schweiz behält 35% ein; in DE sind i. d. R. 15% anrechenbar, der Rest (typisch 20%-Punkte) ist häufig per Rückforderung in der Schweiz erstattbar. Für die CH-Rückforderung wird oft ein ‚Tax Voucher‘ benötigt; bei Scalable ist ein Tax Voucher laut Unterlagen mit 25 € pro Auftrag pro Kunde bepreist (falls benötigt)."}, //  [oai_citation:3‡ESTV](https://www.estv.admin.ch/en/anticipatory-tax?utm_source=chatgpt.com)
 
   { land:"Österreich",
   standard:"27,5% Quellensteuer auf Dividenden (KESt)",
   dba:"15% (Privatanleger/Portfolio-Dividenden)",
   de:"Scalable: DE-Steuer automatisch. Österreich behält grundsätzlich 27,5% ein; in Deutschland ist i. d. R. nur bis 15% anrechenbar. Der Überhang (typisch 12,5%-Punkte) ist – wenn du ihn zurückholen willst – nur über Rückforderung in Österreich möglich."}, //  [oai_citation:0‡Bundesministerium für Finanzen](https://www.bmf.gv.at/en/topics/taxation/double-taxation-agreements/relief-from-austrian-withholding-taxes-under-dtc.html?utm_source=chatgpt.com)

   { land:"Italien",
   standard:"26% Quellensteuer auf Dividenden (Standard)",
   dba:"15% (Privatanleger/Portfolio-Dividenden, typischer DBA-Satz)",
   de:"Scalable: DE-Steuer automatisch. Italien behält standardmäßig 26% ein; in DE ist i. d. R. bis 15% anrechenbar. Der Rest (typisch 11%-Punkte) wäre ggf. nur per Rückforderung in Italien zu holen."}, //  [oai_citation:1‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/italy/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Spanien",
   standard:"19% Quellensteuer auf Dividenden (Non-Resident Standard)",
   dba:"15% (Privatanleger/Portfolio-Dividenden nach DBA DE–ES)",
   de:"Scalable: DE-Steuer automatisch. Spanien behält i. d. R. 19% ein; in DE ist i. d. R. bis 15% anrechenbar. Die Differenz (typisch 4%-Punkte) ist ggf. per Rückforderung in Spanien möglich."}, //  [oai_citation:2‡Dentons](https://www.dentons.com/en/services-and-solutions/global-tax-guide-to-doing-business-in/spain?utm_source=chatgpt.com) 

   { land:"Portugal",
   standard:"28% Quellensteuer auf Dividenden (Non-Resident Individuals)",
   dba:"15% (Privatanleger/Portfolio-Dividenden nach DBA DE–PT)",
   de:"Scalable: DE-Steuer automatisch. Portugal behält für nichtansässige Privatpersonen typischerweise 28% ein; in DE ist i. d. R. nur bis 15% anrechenbar. Der Überhang (typisch 13%-Punkte) wäre ggf. nur per Rückforderung in Portugal zu klären."}, //  [oai_citation:3‡Caiado Guerreiro](https://www.caiadoguerreiro.com/en/taxation-of-dividends-between-companies-and-shareholders-resident-abroad/?utm_source=chatgpt.com)
  
   { land:"Dänemark",
   standard:"27% Dividenden-Quellensteuer (für Nichtansässige grundsätzlich; Reduktion nach DBA möglich)",
   dba:"15% (typischer DBA-Satz für Privatanleger/Portfolio-Dividenden)",
   de:"Scalable: DE-Steuer automatisch. Dänemark behält i. d. R. 27% ein; in DE ist typischerweise nur bis zum DBA-Satz (15%) anrechenbar. Der Überhang (typisch 12%-Punkte) ist – wenn du ihn zurückholen willst – nur über Rückforderung/Entlastungsverfahren in Dänemark möglich."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/denmark/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Schweden",
   standard:"30% Quellensteuer auf Dividenden an Nichtansässige",
   dba:"15% (nach DBA, sofern anwendbar)",
   de:"Scalable: DE-Steuer automatisch. Schweden behält für Nichtansässige normalerweise 30% ein; mit DBA kann der Satz reduziert sein (typisch 15%). In DE ist i. d. R. nur bis 15% anrechenbar; darüber hinausgehende Quellensteuer wäre ggf. per Rückforderung in Schweden zu klären."}, //  [oai_citation:1‡skatteverket.se](https://www.skatteverket.se/servicelankar/otherlanguages/englishengelska/businessesandemployers/nonestablishedforeignbusinesses/swedishwithholdingtaxondividends.4.34a801ea1041d54f9e28000452.html?utm_source=chatgpt.com)

   { land:"Norwegen",
   standard:"25% Quellensteuer auf Dividenden an ausländische Aktionäre",
   dba:"15% (Deutschland; 0% nur für qualifizierte Beteiligungen/Unternehmen)",
   de:"Scalable: DE-Steuer automatisch. Norwegen behält grundsätzlich 25% ein; nach DBA mit Deutschland gilt für Privatanleger typischerweise 15%. In DE i. d. R. nur bis 15% anrechenbar; der Überhang (typisch 10%-Punkte) wäre ggf. per Rückforderung in Norwegen zu holen."}, //  [oai_citation:2‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/norway/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Finnland",
   standard:"30% Quellensteuer auf Dividenden an Nichtansässige (35% bei nominee-registered, falls Begünstigter nicht identifizierbar)",
   dba:"oft 15% (je nach DBA; für Deutschland typischerweise 15%)", 
   de:"Scalable: DE-Steuer automatisch. Finnland behält bei Nichtansässigen typischerweise 30% ein (in Sonderfällen 35%); das DBA begrenzt häufig auf 15%. In DE ist i. d. R. nur bis 15% anrechenbar; ein Überhang wäre ggf. per Rückforderung in Finnland zu klären."}, //  [oai_citation:3‡vero.fi](https://www.vero.fi/en/individuals/tax-cards-and-tax-returns/moving_away_from_finland/paying_dividends_interest_and_royalties/?utm_source=chatgpt.com)

   { land:"Polen",
   standard:"19% Quellensteuer auf Dividenden (Standard, Non-Resident)",
   dba:"15% (DBA DE–PL: 15% „in allen anderen Fällen“; 5% nur für qualifizierte Gesellschaften ≥10%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Polen behält i. d. R. 19% ein; in Deutschland ist typischerweise nur bis 15% anrechenbar. Der Überhang (typisch 4%-Punkte) ist – wenn du ihn zurückholen willst – nur über Rückforderung/Entlastungsverfahren in Polen möglich."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/poland/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Tschechien",
   standard:"15% Quellensteuer auf Dividenden (Standard)",
   dba:"15% (Privatanleger-Fall; niedrigere Sätze betreffen typischerweise nur qualifizierte Gesellschaften/Beteiligungen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Tschechien behält i. d. R. 15% ein; diese 15% sind in DE grundsätzlich anrechenbar → meist kein Rückforderungsrest."}, //  [oai_citation:1‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/czech-republic/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Ungarn",
   standard:"15% Quellensteuer/Income Tax auf Dividenden (Standard)",
   dba:"15% (Privatanleger-Fall; niedrigere Sätze betreffen typischerweise nur qualifizierte Gesellschaften/Beteiligungen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Ungarn behält typischerweise 15% ein; diese 15% sind in DE grundsätzlich anrechenbar → meist kein Rückforderungsrest (sofern tatsächlich einbehalten)."}, //  [oai_citation:2‡Clearstream](https://www.clearstream.com/clearstream-en/res-library/market-coverage/equities-double-taxation-treaties-concluded-by-hungary-and-currently-in-force-1278696?utm_source=chatgpt.com)

   { land:"Griechenland",
   standard:"5% Quellensteuer auf Dividenden (Standard)",
   dba:"meist 10–15% (DBA-Obergrenze ist i. d. R. höher, praktisch aber irrelevant, weil GR-Standard bereits 5% ist)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Griechenland behält i. d. R. 5% ein; diese 5% sind in DE grundsätzlich anrechenbar → normalerweise kein Rückforderungsrest."}, //  [oai_citation:3‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/greece/individual/income-determination?utm_source=chatgpt.com)
  
   { land:"Türkei",
   standard:"15% Quellensteuer auf Dividenden (Standard, Non-Resident)",
   dba:"15% (Privatanleger/Portfolio-Dividenden; 5% nur für qualifizierte Gesellschaften mit hoher Beteiligung)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. In der Türkei beträgt die Dividenden-Quellensteuer für Nichtansässige grundsätzlich 15%. Für Privatanleger ist der DBA-Satz i. d. R. ebenfalls 15% → normalerweise kein Rückforderungsrest; relevant wird Rückforderung eher nur bei Fehlabzug/Abweichungen."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/turkey/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Russland",
   standard:"15% Quellensteuer auf Dividenden an Nichtansässige (nach russischem Recht; operative Abwicklung kann stark eingeschränkt sein)",
   dba:"– (DTA/DBA DE–RU von Russland seit 08/2023 für wesentliche Artikel ausgesetzt; Treaty-Entlastung praktisch i. d. R. nicht verlässlich)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt, soweit Zahlungen/Abwicklung überhaupt stattfinden. Die Anrechnung in DE hängt davon ab, ob tatsächlich Quellensteuer einbehalten wurde und ob belastbare Nachweise/Tax-Voucher vorhanden sind. Rückforderung/Entlastung in Russland ist praktisch oft schwierig (und kann je nach Wertpapier/Lagerstelle/Sanktionen faktisch nicht durchführbar sein)."}, //  [oai_citation:1‡Jarnias Cyril](https://www.jarniascyril.com/expatriation/guide-moving-to-russia-expat/russia-non-resident-taxation-filing-obligations/?utm_source=chatgpt.com)

   { land:"China",
   standard:"20% (Privatanleger/Individuals nach IIT-Logik; ohne Treaty-Entlastung)",
   dba:"10% (DBA DE–CN begrenzt Dividenden typischerweise auf 10%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Bei China-Dividenden ist der entscheidende Punkt, ob über die Verwahrkette/Treaty-Prozesse der DBA-Satz (typisch 10%) tatsächlich angewendet wird; ohne wirksame Treaty-Anwendung kann (bei Individuals) eine höhere Belastung auftreten. In DE ist die Quellensteuer grundsätzlich nur im Rahmen der deutschen Anrechnungsgrenzen anrechenbar."}, //  [oai_citation:2‡Lorenz & Partners](https://www.lorenz-partners.com/dividend-tax-german/?utm_source=chatgpt.com)
 
   { land:"Hongkong",
   standard:"0% (keine Quellensteuer auf Dividenden)",
   dba:"0% (praktisch, da keine WHT erhoben wird)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Hongkong erhebt aktuell keine Quellensteuer auf Dividenden → keine ausländische Quellensteuer, daher keine Anrechnung/Rückforderung nötig."}, //  [oai_citation:3‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/hong-kong-sar/corporate/withholding-taxes?utm_source=chatgpt.com)
  
   { land:"Singapur",
   standard:"0% (keine Quellensteuer auf Dividenden)",
   dba:"0% (praktisch, da keine WHT erhoben wird)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Singapur erhebt keine Quellensteuer auf Dividenden → keine ausländische Quellensteuer, daher keine Anrechnung/Rückforderung nötig."}, //  [oai_citation:0‡Default](https://www.iras.gov.sg/taxes/withholding-tax/payments-to-non-resident-company/payments-that-are-not-subject-to-withholding-tax?utm_source=chatgpt.com)

   { land:"Taiwan",
   standard:"21% Quellensteuer auf Dividenden an Nichtansässige (Standard)",
   dba:"10% (nach DE–Taiwan-Abkommen; Treaty-Entlastung erfordert i. d. R. Nachweise/Prozess in der Verwahrkette)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Ohne Treaty-Entlastung wird bei Taiwan-Dividenden typischerweise 21% einbehalten. Das DE–Taiwan-Abkommen begrenzt Dividenden grundsätzlich auf 10%; wenn über die Verwahrkette keine Treaty-Entlastung greift, bleibt der höhere Einbehalt bestehen und der Überhang wäre nur über Erstattungsverfahren/Entlastung in Taiwan lösbar."}, //  [oai_citation:1‡Ministerium für Landwirtschaft](https://www.mof.gov.tw/eng/singlehtml/264?cntId=82776&utm_source=chatgpt.com)

   { land:"Japan",
   standard:"typisch 15,315% auf Dividenden aus börsennotierten Aktien (Portfolio-Privatanleger; inkl. 2,1% Surtax auf den nationalen Anteil); in Sonderfällen auch ~20,42%",
   dba:"meist 15% (DBA-Obergrenze für Portfolio-Dividenden; ob/wie der kleine Zuschlagsanteil reduziert wird, hängt vom konkreten Entlastungsverfahren ab)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. In Japan wird bei Portfolio-Dividenden häufig ~15,315% einbehalten (typischer Börsenfall). In DE ist die Quellensteuer grundsätzlich nur bis zur Anrechnungsgrenze anrechenbar; ein eventueller Überhang wäre – falls relevant – nur über japanische Entlastung/Refund-Prozesse zu klären."}, //  [oai_citation:2‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/japan/corporate/income-determination?utm_source=chatgpt.com)

   { land:"Südkorea",
   standard:"22% Quellensteuer auf Dividenden an Nichtansässige (20% national + 10% Local Surtax auf die WHT = effektiv 22%)",
   dba:"15% (typischer DBA-Satz für Portfolio-Privatanleger; niedrigere Sätze nur für qualifizierte Beteiligungen/Unternehmen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Südkorea behält bei Nichtansässigen typischerweise effektiv 22% ein; in DE ist i. d. R. nur bis zum DBA-Satz (typisch 15%) anrechenbar. Der Überhang (typisch 7%-Punkte) wäre – wenn du ihn zurückholen willst – nur über Entlastungs-/Erstattungsverfahren in Korea möglich."}, //  [oai_citation:3‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/republic-of-korea/corporate/withholding-taxes?utm_source=chatgpt.com)
  
   { land:"Indien",
   standard:"20% Quellensteuer/TDS auf Dividenden an Nichtansässige (+ ggf. Zuschläge/Surcharge & Cess) – wenn kein Treaty-Satz angewendet wird",
   dba:"10% (DBA Indien–Deutschland, Art. 10: max. 10% wenn Empfänger beneficial owner)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Bei Indien ist ohne Treaty-Anwendung häufig 20% (+ Zuschläge/Cess) Einbehalt möglich. Nach DBA Indien–Deutschland sind Dividenden grundsätzlich auf 10% begrenzt; ob das in der Verwahrkette direkt als 10% durchläuft, hängt von den indischen/Intermediär-Prozessen und Nachweisen ab. In DE ist Quellensteuer i. d. R. nur bis zur Anrechnungsgrenze (typisch DBA-Satz) anrechenbar; ein Überhang wäre ggf. nur über Entlastung/Erstattung in Indien zu klären."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/india/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Indonesien",
   standard:"20% Quellensteuer auf Dividenden an Nichtansässige (ohne DBA)",
   dba:"15% (DBA Indonesien–Deutschland: Portfolio-Dividenden 15%; niedrigere Sätze nur für qualifizierte Beteiligungen/Unternehmen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Indonesien behält ohne Treaty i. d. R. 20% ein. Für DE-Privatanleger begrenzt das DBA die Dividenden-Quellensteuer typischerweise auf 15%; in Deutschland ist entsprechend i. d. R. nur bis 15% anrechenbar. Ein eventueller Überhang (z. B. wenn 20% einbehalten wurden) wäre nur über Erstattung/Entlastung in Indonesien zu klären."}, //  [oai_citation:1‡tax2win.in](https://tax2win.in/guide/dtaa-between-india-and-germany?utm_source=chatgpt.com)

   { land:"Malaysia",
   standard:"0% (keine Quellensteuer auf Dividenden)",
   dba:"0% (praktisch, da keine Dividenden-WHT erhoben wird)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Malaysia erhebt aktuell keine Quellensteuer auf Dividenden → keine ausländische Quellensteuer, daher keine Anrechnung/Rückforderung nötig."}, //  [oai_citation:2‡hasil.gov.my](https://www.hasil.gov.my/en/international/double-taxation-avoidance-agreement-dtadtaa/withholding-tax-rates/?utm_source=chatgpt.com)

   { land:"Thailand",
   standard:"10% Quellensteuer auf Dividenden",
   dba:"15% (DBA-Obergrenze; praktisch meist irrelevant, weil TH-Standard bereits 10% ist)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Thailand behält bei Dividenden typischerweise 10% ein; diese 10% sind in DE grundsätzlich anrechenbar (im Rahmen der deutschen Anrechnungsgrenzen). Rückforderung ist normalerweise kein Thema, weil die Quellensteuer nicht über einer typischen DBA-Obergrenze liegt."}, //  [oai_citation:3‡set.or.th](https://www.set.or.th/en/market/information/tax?utm_source=chatgpt.com)
   
   { land:"Vietnam",
   standard:"5% (Dividenden an Privatpersonen; für Corporate-Empfänger i. d. R. 0%)",
   dba:"–/praktisch selten relevant (Standard 5% liegt i. d. R. bereits unter typischen DBA-Obergrenzen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Vietnam besteuert Dividendenausschüttungen an Privatpersonen typischerweise mit 5% (PIT auf Investment Income). Wenn überhaupt Quellensteuer anfällt, ist sie in DE nur im Rahmen der Anrechnungsgrenzen anrechenbar; bei 5% entsteht normalerweise kein Rückforderungsrest."}, //  [oai_citation:0‡Andersen in Vietnam](https://vn.andersen.com/wp-content/uploads/2025/03/Andersen-in-Vietnam-Tax-Booklet_2025.pdf?utm_source=chatgpt.com)

   { land:"Philippinen", 
   standard:"25% (Dividenden an Nichtansässige nach Grundregel; in der Praxis über DBA reduzierbar)",
   dba:"15% (Privatanleger/„all other cases“ im DBA DE–PH; 5%/10% nur für qualifizierte Unternehmen mit hoher Beteiligung)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Ohne DBA-Entlastung wird in den Philippinen häufig ein höherer Satz einbehalten; nach DBA DE–PH sind Dividenden für Privatanleger typischerweise auf 15% begrenzt. In DE ist i. d. R. nur bis 15% anrechenbar; ein darüber hinausgehender Einbehalt wäre ggf. nur per Rückforderung/Entlastungsverfahren in den Philippinen lösbar."}, //  [oai_citation:1‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/philippines/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Australien",
   standard:"30% auf unfranked Dividenden (sofern keine Treaty-Reduktion greift); 0% auf franked Dividenden",
   dba:"15% (Privatanleger/„all other dividends“ im DBA AU–DE; 5% nur für Unternehmen ≥10% Beteiligung)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Franked Dividenden sind für Nichtansässige i. d. R. quellensteuerfrei (0%). Unfranked Dividenden unterliegen grundsätzlich WHT und können nach DBA AU–DE typischerweise auf 15% begrenzt sein (Privatanleger-Fall). In DE ist Quellensteuer nur im Rahmen der Anrechnungsgrenzen anrechenbar; Überhänge wären ggf. nur über Entlastung/Refund zu klären."}, //  [oai_citation:2‡ato.gov.au](https://www.ato.gov.au/forms-and-instructions/you-and-your-shares-2021/dividends-paid-or-credited-to-non-resident-shareholders?utm_source=chatgpt.com)

   { land:"Neuseeland", 
   standard:"30% NRWT auf Dividenden (ohne DBA/ohne korrekte DTA-Anwendung; Sonderregeln bei imputed dividends möglich)",
   dba:"15% (Privatanleger/Standard-DTA-Logik; 5% nur für qualifizierte Unternehmen ≥10%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Neuseeland wendet bei Dividenden ohne Treaty-Anwendung typischerweise 30% NRWT an. Unter DBA/DTA ist für Privatanleger regelmäßig eine Begrenzung (typisch 15%) vorgesehen; in DE ist i. d. R. nur bis zur DBA-Anrechnungsgrenze anrechenbar. Ein Überhang (z. B. 30% statt 15%) wäre ggf. nur über Entlastung/Refund in NZ zu klären."}, //  [oai_citation:3‡ird.govt.nz](https://www.ird.govt.nz/income-tax/withholding-taxes/non-resident-withholding-tax-nrwt/deduct-nrwt-at-the-right-rate/nrwt-rates-for-dta-countries?utm_source=chatgpt.com)
  
   { land:"Israel",
   standard:"25% (Privatanleger); 30% bei „substantial shareholder“ (typisch ≥10%)",
   dba:"10% (DBA DE–IL; 5% nur für Gesellschaften ≥10% Beteiligung; REIT-/Immobilien-ähnliche Ausschüttungen teils 15%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Israel behält bei Dividenden an ausländische Privatpersonen i. d. R. 25% ein (30% bei „substantial shareholder“). Nach dem DBA DE–IL liegt die Quellensteuer-Obergrenze für Privatanleger typischerweise bei 10% (wenn Treaty-Entlastung in der Verwahrkette greift); ein darüber hinausgehender Einbehalt wäre ggf. nur über Entlastung/Erstattung in Israel zu klären."}, //  [oai_citation:0‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/israel/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Saudi-Arabien",
   standard:"5% Quellensteuer auf Dividenden",
   dba:"– (kein allgemeines DBA DE–Saudi für Dividenden; nur sehr begrenztes DBA für Luftfahrt/Arbeitnehmer existiert)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Saudi-Arabien erhebt auf Dividenden an Nichtansässige grundsätzlich 5% Quellensteuer. Da es mit Deutschland kein allgemeines DBA für Dividenden gibt, läuft das in der Praxis i. d. R. ohne DBA-Reduktion."}, //  [oai_citation:1‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/saudi-arabia/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"VAE (UAE)",
   standard:"0% Quellensteuer (derzeit; WHT-Satz ist gesetzlich auf 0% gesetzt)",
   dba:"0% (praktisch, weil UAE-WHT = 0%)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Die VAE erheben derzeit 0% Quellensteuer auf relevante UAE-Einkünfte an Nichtansässige → keine ausländische Quellensteuer, daher keine Anrechnung/Rückforderung nötig."}, //  [oai_citation:2‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/united-arab-emirates/corporate/withholding-taxes?utm_source=chatgpt.com)

   { land:"Südafrika",
   standard:"20% Dividends Tax (Quellensteuer auf Dividenden an Nichtansässige)",
   dba:"15% (Privatanleger/„other beneficial owners“ nach DBA; niedrigere Sätze nur für qualifizierte Unternehmen/Beteiligungen)",
   de:"Scalable: DE-Steuer wird automatisch abgeführt. Südafrika behält grundsätzlich 20% ein; nach DBA ist für Privatanleger typischerweise 15% vorgesehen. In DE ist i. d. R. nur bis 15% anrechenbar; der Überhang (typisch 5%-Punkte) wäre – wenn du ihn zurückholen willst – nur über Entlastung/Erstattung in Südafrika möglich."}, //  [oai_citation:3‡PwC Steuerzusammenfassungen](https://taxsummaries.pwc.com/south-africa/corporate/withholding-taxes?utm_source=chatgpt.com)

];

const FTS_DATA = [
  {
    land: "Deutschland",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe wie z. B. in Frankreich/Italien.",
    note: "Scalable: i. d. R. keine FTS; nur Börsen-/Handelsplatzkosten/Spreads sind etwas anderes."
  },
  {
    land: "USA",
    steuer: "– (keine FTS; teils regulatorische Gebühren möglich)",
    wann: "Keine FTS auf Aktienkäufe; teils kleine regulatorische/SEC-bezogene Fees (nicht FTS) v. a. bei Verkäufen.",
    note: "Scalable: falls Gebühren anfallen, stehen sie in der Abrechnung (keine echte FTS)."
  },
  {
    land: "Kanada",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe/Verkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Mexiko",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Börsentransaktionen.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Brasilien",
    steuer: "i. d. R. keine klassische FTS (produkt-/strukturabhängig möglich)",
    wann: "Keine typische EU-ähnliche Aktienkauf-FTS; einzelne Abgaben können je Produkt/Route vorkommen.",
    note: "Scalable: abhängig von Produkt/Abwicklung; meist keine ausgewiesene FTS."
  },
  {
    land: "Vereinigtes Königreich (UK)",
    steuer: "0,5% Stamp Duty / SDRT (typisch, auf Käufe UK-Aktien)",
    wann: "Beim Kauf vieler UK-aktienähnlicher Titel (nicht auf Verkäufe); Ausnahmen je Instrument/Handelsweg.",
    note: "Scalable: wenn betroffen, erscheint es typischerweise als Steuer/Abgabe in der Abrechnung."
  },
  {
    land: "Irland",
    steuer: "1% Irish Stamp Duty (typisch, auf Käufe irischer Aktien)",
    wann: "Beim Kauf vieler irischer Aktien (nicht auf Verkäufe); Ausnahmen möglich.",
    note: "Scalable: wenn betroffen, wird es i. d. R. automatisch belastet."
  },
  {
    land: "Frankreich",
    steuer: "0,3% (typisch; französische Aktien-FTT)",
    wann: "Beim Kauf bestimmter französischer Aktien großer Unternehmen (schwellen-/listenbasiert).",
    note: "Scalable: wenn betroffen, wird es i. d. R. über die Abwicklung berechnet und ausgewiesen."
  },
  {
    land: "Niederlande",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Belgien",
    steuer: "Börsensteuer (TOB) – produktabhängig, teils gedeckelt",
    wann: "Je nach Wertpapier-Typ (Aktie/ETF/Fonds/Anleihe etc.) bei Kauf und/oder Verkauf; mit Höchstbeträgen.",
    note: "Scalable: hängt stark von Produkt & Abwicklung ab; Belgien ist besonders regel-/produktabhängig."
  },
  {
    land: "Luxemburg",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Schweiz",
    steuer: "Umsatzabgabe (Stempelsteuer) – nur falls CH-Effektenhändler beteiligt",
    wann: "Kann anfallen, wenn ein Schweizer Effektenhändler als Intermediär gilt; ansonsten oft nicht.",
    note: "Scalable: in DE-Depotstruktur häufig nicht relevant; abhängig von Verwahr-/Intermediär-Kette."
  },
  {
    land: "Österreich",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Italien",
    steuer: "0,1% / 0,2% (typisch; je nach Handelsplatz) + ggf. Derivate-FTT",
    wann: "Beim Kauf bestimmter italienischer Aktien; Derivate separat nach eigenen Tabellen/Regeln.",
    note: "Scalable: Aktien-Teil i. d. R. automatisch; Derivate nur relevant, wenn du diese handelst."
  },
  {
    land: "Spanien",
    steuer: "0,2% (typisch; spanische Aktien-FTT)",
    wann: "Beim Kauf bestimmter spanischer Aktien großer Unternehmen (listen-/schwellenbasiert).",
    note: "Scalable: wenn betroffen, wird es typischerweise automatisch berücksichtigt."
  },
  {
    land: "Portugal",
    steuer: "– (keine allgemeine Aktien-FTS)",
    wann: "Keine typische, landesweite Aktienkauf-FTS wie FR/IT/ES.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Dänemark",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Schweden",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Norwegen",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Finnland",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Polen",
    steuer: "– (keine typische Börsen-FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer wie in FR/IT/ES.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Tschechien",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Ungarn",
    steuer: "– (keine allgemeine Börsen-FTS auf Aktienkäufe)",
    wann: "Keine typische Aktienkauf-FTS wie FR/IT.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Griechenland",
    steuer: "– / ggf. Börsenabgaben je Markt möglich (nicht standardisierte FTS)",
    wann: "Keine klassische, allgemeine Aktienkauf-FTS wie FR/IT/ES.",
    note: "Scalable: i. d. R. keine FTS; im Zweifel Abrechnung prüfen."
  },
  {
    land: "Türkei",
    steuer: "– (keine allgemeine Aktien-FTS; teils Gebühren je Markt möglich)",
    wann: "Keine EU-ähnliche Aktienkauf-FTS als Standard.",
    note: "Scalable: i. d. R. keine FTS; abhängig von Produkt/Handelsweg."
  },
  {
    land: "Russland",
    steuer: "– (keine allgemein verlässliche FTS; Markt/Abwicklung stark eingeschränkt möglich)",
    wann: "Keine typische, stabile FTS-Logik für Privatanleger; Abwicklung kann eingeschränkt sein.",
    note: "Scalable: praktische Handelbarkeit/Abrechnung abhängig von Sanktionen/Handelsmöglichkeit."
  },
  {
    land: "China",
    steuer: "0,1% Stempelsteuer (typisch; auf Aktien-Transaktionen, i. d. R. Verkaufseite A-Shares)",
    wann: "Typisch als Stamp Duty auf bestimmte Börsentransfers (häufig auf Verkäufe; marktabhängig).",
    note: "Scalable: abhängig von Markt (A/H/ADR) und Abwicklung; erscheint ggf. als Stamp Duty."
  },
  {
    land: "Hongkong",
    steuer: "0,1% Stamp Duty je Seite (typisch)",
    wann: "Bei Kauf und Verkauf von HK-Aktien (jeweils auf den Transaktionswert; Rundungsregeln möglich).",
    note: "Scalable: wenn betroffen, erscheint es typischerweise als Stamp Duty."
  },
  {
    land: "Singapur",
    steuer: "– (keine allgemeine FTS/Stamp Duty auf Börsenaktienkäufe)",
    wann: "Keine typische Finanztransaktionssteuer auf börsliche Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Taiwan",
    steuer: "0,3% Securities Transaction Tax (typisch; oft Verkaufseite bei Aktien)",
    wann: "Typisch als STT auf Aktien-Transaktionen (häufig auf Verkäufe; je Produkt ggf. andere Sätze).",
    note: "Scalable: abhängig von Instrument/Markt; erscheint ggf. als Transaction Tax."
  },
  {
    land: "Japan",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe/Verkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Südkorea",
    steuer: "Securities Transaction Tax (STT) auf Verkäufe (Sätze je Markt/Produkt variieren)",
    wann: "Typisch auf Verkaufstransaktionen; Sätze unterscheiden sich (KOSPI/KOSDAQ/ETFs etc.).",
    note: "Scalable: abhängig von Markt/Produkt; wird ggf. in der Abrechnung ausgewiesen."
  },
  {
    land: "Indien",
    steuer: "Securities Transaction Tax (STT) (Sätze je Produkt/Seite variieren)",
    wann: "Auf Börsentransaktionen; je nach Instrument (Aktien, Optionen, Futures) und Kauf/Verkauf unterschiedlich.",
    note: "Scalable: nur relevant, wenn du indische Börsenprodukte handelst; erscheint ggf. als STT."
  },
  {
    land: "Indonesien",
    steuer: "Börsenabgaben/Levy möglich (keine „klassische“ FTS wie FR/IT)",
    wann: "Je nach Handelsplatz/Markt können Abgaben/Levy in Gebühren stecken.",
    note: "Scalable: abhängig vom Handelsweg; i. d. R. keine separate „FTS“-Position."
  },
  {
    land: "Malaysia",
    steuer: "Stamp Duty auf Contract Notes (typisch; gedeckelt, modellabhängig)",
    wann: "Bei Börsentransaktionen (häufig als Stempelsteuer auf Kontraktnoten; Caps möglich).",
    note: "Scalable: abhängig von Abwicklung/Markt; kann als Stamp Duty erscheinen."
  },
  {
    land: "Thailand",
    steuer: "– (keine allgemeine Aktien-FTS als Standard)",
    wann: "Keine typische Finanztransaktionssteuer auf Aktienkäufe wie in FR/IT.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Vietnam",
    steuer: "0,1% auf Verkäufe (typisch; marktabhängig)",
    wann: "Häufig als Abgabe auf Verkaufstransaktionen am Aktienmarkt (Regeln können je Markt variieren).",
    note: "Scalable: abhängig von Marktzugang/Produkt; erscheint ggf. als Transaction Tax/Fee."
  },
  {
    land: "Philippinen",
    steuer: "0,6% Stock Transaction Tax (typisch; auf Verkäufe börsennotierter Aktien)",
    wann: "Typisch auf Verkauf von an der lokalen Börse gehandelten Aktien.",
    note: "Scalable: abhängig von Marktzugang; erscheint ggf. als Stock Transaction Tax."
  },
  {
    land: "Australien",
    steuer: "– (keine allgemeine Aktien-Stamp Duty auf Börsenkäufe; historisch abgeschafft)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe an der Börse.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Neuseeland",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe/Verkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Israel",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe wie FR/IT.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Saudi-Arabien",
    steuer: "– (keine allgemeine FTS als Standard)",
    wann: "Keine typische Finanztransaktionssteuer auf Aktienkäufe wie in FR/IT/ES.",
    note: "Scalable: i. d. R. keine FTS; abhängig von Produkt/Markt."
  },
  {
    land: "VAE (UAE)",
    steuer: "– (keine allgemeine FTS)",
    wann: "Keine allgemeine Finanztransaktionssteuer auf Aktienkäufe.",
    note: "Scalable: i. d. R. keine FTS."
  },
  {
    land: "Südafrika",
    steuer: "0,25% Securities Transfer Tax (typisch; auf Käufe/Transfers)",
    wann: "Typisch bei Kauf/Übertragung südafrikanischer Wertpapiere (Aktien/ähnliche).",
    note: "Scalable: wenn betroffen, wird es i. d. R. automatisch belastet und ausgewiesen."
  }
];


    // --- Seiten Navigation ---
  function goPage(page){
     closeNutzenOverlay(); // <-- WICHTIG: verhindert "unsichtbares Overlay blockt Klicks"
  const home = document.getElementById("page-home");
  const cagr = document.getElementById("page-cagr");
  const etf  = document.getElementById("page-etf");
  const finanztas = document.getElementById("page-finanztransaktionssteuer");
  const fair = document.getElementById("page-fairprice");
  const fcfp = document.getElementById("page-fcfpayout");
  const icr = document.getElementById("page-icr");
  const checks = document.getElementById("page-checks");
  const nutzen = document.getElementById("page-nutzen");
  const vol = document.getElementById("page-volatility");
  const fx = document.getElementById("page-fx");





  if (home) home.style.display = (page === "home") ? "block" : "none";
  if (cagr) cagr.style.display = (page === "cagr") ? "block" : "none";
  if (etf)  etf.style.display  = (page === "etf")  ? "block" : "none";
  if (finanztas) finanztas.style.display = (page === "finanztransaktionssteuer") ? "block" : "none";
  if (fair) fair.style.display = (page === "fairprice") ? "block" : "none";
  if (fcfp) fcfp.style.display = (page === "fcfpayout") ? "block" : "none";
  if (icr) icr.style.display = (page === "icr") ? "block" : "none";
  if (checks) checks.style.display = (page === "checks") ? "block" : "none";
  if (nutzen) nutzen.style.display = (page === "nutzen") ? "block" : "none";
if(page === "nutzen"){
  if(!nutzenBound){
    bindNutzenUI();
    nutzenBound = true;
  }
  nutzenUpdateYearVisibility();
}
  if (vol) vol.style.display = (page === "volatility") ? "block" : "none";
  if (fx) fx.style.display = (page === "fx") ? "block" : "none";

  if(page === "fx"){
  if(!fxBound){
    bindFxUI();
    fxBound = true;
  }
}


if(page === "etf") {
  renderWhtTable(document.getElementById("whtSearch")?.value || "");
  if(!whtSearchBound){
    bindWhtSearch();
    whtSearchBound = true;
  }
}

if(page === "finanztransaktionssteuer") {
  renderFtsTable(document.getElementById("ftsSearch")?.value || "");
  if(!ftsSearchBound){
    bindFtsSearch();
    ftsSearchBound = true;
  }
}
     

}
 document.addEventListener("DOMContentLoaded", () => goPage("home"));


function renderWhtTable(filterText = ""){
  const tbody = document.querySelector("#whtTable tbody");
  if(!tbody) return;

  const q = String(filterText || "").trim().toLowerCase();

  const rows = WHT_DATA.filter(r => {
    if(!q) return true;
    const hay = `${r.land} ${r.standard} ${r.dba} ${r.de}`.toLowerCase();
    return hay.includes(q);
  });

  tbody.innerHTML = rows.map(r => `
    <tr>
      <td>${r.land}</td>
      <td>${r.standard}</td>
      <td>${r.dba}</td>
      <td>${r.de}</td>
    </tr>
  `).join("");

  if(rows.length === 0){
    tbody.innerHTML = `<tr><td colspan="4" class="small">Keine Treffer.</td></tr>`;
  }
}



function renderFtsTable(filterText = ""){
  const tbody = document.querySelector("#ftsTable tbody");
  if(!tbody) return;

  const q = String(filterText || "").trim().toLowerCase();

  const rows = FTS_DATA.filter(r => {
    if(!q) return true;
    const hay = `${r.land} ${r.steuer} ${r.wann} ${r.note}`.toLowerCase();
    return hay.includes(q);
  });

  tbody.innerHTML = rows.map(r => `
    <tr>
      <td>${r.land}</td>
      <td>${r.steuer}</td>
      <td>${r.wann}</td>
      <td>${r.note}</td>
    </tr>
  `).join("");

  if(rows.length === 0){
    tbody.innerHTML = `<tr><td colspan="4" class="small">Keine Treffer.</td></tr>`;
  }
}

 

function bindWhtSearch(){
  const input = document.getElementById("whtSearch");
  if(!input) return;

  input.addEventListener("input", () => {
    renderWhtTable(input.value);
  });

  input.addEventListener("keydown", (e) => {
    if(e.key === "Enter") e.preventDefault();
  });
}

 
function bindFtsSearch(){
  const input = document.getElementById("ftsSearch");
  if(!input) return;

  input.addEventListener("input", () => {
    renderFtsTable(input.value);
  });

  input.addEventListener("keydown", (e) => {
    if(e.key === "Enter") e.preventDefault();
  });
}




  // --- Helpers (DE/EN Zahlformate) ---
function parseNumberSmart(raw){
  if(raw == null) return NaN;
  let s = String(raw).trim();
  if(!s) return NaN;

  s = s.replace(/\s+/g, "");

  // --- Suffix (K/M/B/T) erkennen ---
  // Beispiele: 12,106M | 13,75B | 550,11M | 1.2T | 120k
  let mult = 1;
  const m = s.match(/^(.*?)([kKmMbBtT])$/);
  if(m){
    s = m[1];
    const suf = m[2].toUpperCase();
    mult = (suf === "K") ? 1e3
         : (suf === "M") ? 1e6
         : (suf === "B") ? 1e9
         : (suf === "T") ? 1e12
         : 1;
  }

  // Prozentzeichen entfernen, falls mal drin
  s = s.replace(/%/g, "");

  const hasComma = s.includes(",");
  const hasDot = s.includes(".");

  // de-DE Tausenderpunkte ohne Komma (z.B. "1.234.567")
  if(hasDot && !hasComma && /^\d{1,3}(\.\d{3})+(\.\d+)?$/.test(s)){
    s = s.replace(/\./g, "");
    const n = Number(s);
    return Number.isFinite(n) ? n * mult : NaN;
  }

  if(hasComma && hasDot){
    const lastComma = s.lastIndexOf(",");
    const lastDot = s.lastIndexOf(".");
    if(lastComma > lastDot){
      s = s.replace(/\./g, "");
      s = s.replace(",", ".");
    } else {
      s = s.replace(/,/g, "");
    }
  } else if(hasComma && !hasDot){
    if(/^\d{1,3}(,\d{3})+$/.test(s)) s = s.replace(/,/g, "");
    else s = s.replace(",", ".");
  } else {
    s = s.replace(/,/g, "");
  }

  const n = Number(s);
  return Number.isFinite(n) ? n * mult : NaN;
}

function parse52wRange(raw){
  // akzeptiert: "21,03-32,07" | "21.03 - 32.07" | "21,03 - 32,07"
  if(raw == null) return { low: NaN, high: NaN };
  let s = String(raw).trim();
  if(!s) return { low: NaN, high: NaN };

  // normalize: replace en dash etc.
  s = s.replace(/–/g, "-");

  const parts = s.split(/\s*[-–\/]\s*/).map(x=>nzNum(x)).filter(n=>Number.isFinite(n));
  if(parts.length < 2) return { low: NaN, high: NaN };

  const a = parseNumberSmart(parts[0]);
  const b = parseNumberSmart(parts[1]);
  if(!Number.isFinite(a) || !Number.isFinite(b)) return { low: NaN, high: NaN };

  return { low: Math.min(a,b), high: Math.max(a,b) };
}


 // Speziell für Prozent-Eingaben (Operative Marge):
// - "12,106" => 12.106
// - "12.106" => 12.106  (ein einzelner Punkt = Dezimalpunkt)
// - "1.234.567" => 1234567 (mehrere Punkte = Tausender)
function parsePercentSmart(raw){
  if(raw == null) return NaN;
  let s = String(raw).trim();
  if(!s) return NaN;

  s = s.replace(/\s+/g, "").replace(/%/g, "");

  const dotCount = (s.match(/\./g) || []).length;
  const hasComma = s.includes(",");

  // Wenn Komma vorhanden: Komma = Dezimal, Punkte = Tausender
  if(hasComma){
    s = s.replace(/\./g, "");
    s = s.replace(",", ".");
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  // Wenn genau EIN Punkt vorhanden: als Dezimalpunkt behandeln (typisch bei Margen)
  if(dotCount === 1){
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  // Wenn mehrere Punkte: Tausendertrennzeichen
  if(dotCount > 1){
    s = s.replace(/\./g, "");
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  // Kein Komma/kein Punkt
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}


  function fmtPct(x){
    if(!Number.isFinite(x)) return "–";
    return (x*100).toFixed(2).replace(".", ",") + " %";
  }
  function fmtNum(x){
    if(!Number.isFinite(x)) return "–";
    return x.toLocaleString("de-DE", {maximumFractionDigits: 2});
  }

  function cagr(start, end, years){
    return Math.pow(end / start, 1 / years) - 1;
  }

  function showErr(msg){
    const el = document.getElementById("err");
    el.style.display = "block";
    el.textContent = msg;
  }
  function hideErr(){
    const el = document.getElementById("err");
    el.style.display = "none";
    el.textContent = "";
  }

  function showInlineErr(id, msg){
  const el = document.getElementById(id);
  if(!el) return;
  el.style.display = "block";
  el.textContent = msg; 
}
function hideInlineErr(id){
  const el = document.getElementById(id);
  if(!el) return;
  el.style.display = "none";
  el.textContent = "";
}

function calcICR(ebit, interestExpense){
  const e = ebit;
  const iAbs = Math.abs(interestExpense); // Interest Expense kann negativ gelistet sein

  if(!Number.isFinite(e)) return { ok:false, err:"Bitte EBIT korrekt eingeben." };
  if(!Number.isFinite(iAbs)) return { ok:false, err:"Bitte Zinsaufwand korrekt eingeben." };

  if(iAbs === 0){
    return { ok:false, err:"Zinsaufwand ist 0 → ICR ist nicht sinnvoll (theoretisch unendlich)." };
  }

  const icr = e / iAbs;

  // Wenn EBIT negativ ist, ist Zinsdeckung faktisch schlecht (trotz Rechnung).
  return { ok:true, icr, e, iAbs };
}

function bindICRUI(){
  const btn = document.getElementById("icr_calc");
  if(!btn) return;

  btn.addEventListener("click", () => {
    hideInlineErr("icr_err");

    const ebit = parseNumberSmart(document.getElementById("icr_ebit")?.value);
    const intE = parseNumberSmart(document.getElementById("icr_interest")?.value);

    const res = calcICR(ebit, intE);
    if(!res.ok) return showInlineErr("icr_err", res.err);

    const out = document.getElementById("icr_out");
    if(!out) return;

    const warn = (res.e < 0)
      ? `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: EBIT ist negativ → Zinsdeckung ist praktisch kritisch.</div>`
      : "";

    out.innerHTML = `
      <div class="kpi"><span>EBIT</span><span><b>${fmtNum(res.e)}</b></span></div>
      <div class="kpi"><span>Zinsaufwand (|…|)</span><span><b>${fmtNum(res.iAbs)}</b></span></div>
      <div class="kpi"><span><b>Zinsdeckung (ICR)</b></span><span><b>${fmtNum(res.icr)}</b></span></div>
      ${warn}
    `;
    out.style.display = "block";
  });

  // Enter = berechnen
  ["icr_ebit","icr_interest"].forEach(id => {
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener("keydown", (e) => {
if(e.key === "Enter" && !e.shiftKey){
  e.preventDefault();
  btn.click();
}
    });
  });
}

document.addEventListener("DOMContentLoaded", bindICRUI);

function calcFcfPayout(divTotal, fcf){
  const divAbs = Math.abs(divTotal); // ok: Dividends Paid oft negativ
  const f = fcf;                    // NICHT abs!

  if(!Number.isFinite(divAbs)) return { ok:false, err:"Dividenden bitte korrekt eingeben." };
  if(!Number.isFinite(f)) return { ok:false, err:"FCF bitte korrekt eingeben." };
  if(f <= 0) return { ok:false, err:"FCF ist ≤ 0 → Payout nicht sinnvoll / nicht gedeckt." };

  const ratio = (divAbs / f) * 100;
  return { ok:true, ratio, divAbs, fcf: f };
}

function bindFcfPayoutUI(){
  const btnA = document.getElementById("fcf_calcA");
  const btnB = document.getElementById("fcf_calcB");

  const enterIds = ["fcf_divTotal","fcf_fcfA","fcf_dps","fcf_shares","fcf_fcfB"];

  if(btnA){
    btnA.addEventListener("click", () => {
      hideInlineErr("fcf_errA");

      const divT = parseNumberSmart(document.getElementById("fcf_divTotal")?.value);
      const fcf  = parseNumberSmart(document.getElementById("fcf_fcfA")?.value);

      const res = calcFcfPayout(divT, fcf);
      if(!res.ok) return showInlineErr("fcf_errA", res.err);

      const out = document.getElementById("fcf_outA");
      out.innerHTML = `
        <div class="kpi"><span>Dividenden gesamt</span><span><b>${fmtNum(res.divAbs)}</b></span></div>
        <div class="kpi"><span>FCF</span><span><b>${fmtNum(res.fcf)}</b></span></div>
        <div class="kpi"><span><b>FCF-Payout</b></span><span><b>${res.ratio.toFixed(2).replace(".", ",")} %</b></span></div>
      `;
      out.style.display = "block";
    });
  }

  if(btnB){
    btnB.addEventListener("click", () => {
      hideInlineErr("fcf_errB");

      const dps    = parseNumberSmart(document.getElementById("fcf_dps")?.value);
      const shares = parseNumberSmart(document.getElementById("fcf_shares")?.value);
      const fcf    = parseNumberSmart(document.getElementById("fcf_fcfB")?.value);

      if(!Number.isFinite(dps)) return showInlineErr("fcf_errB", "Bitte Dividende je Aktie korrekt eingeben.");
      if(!Number.isFinite(shares) || shares <= 0) return showInlineErr("fcf_errB", "Bitte Aktienanzahl korrekt (> 0) eingeben.");

      const divTotal = dps * shares;
      const res = calcFcfPayout(divTotal, fcf);
      if(!res.ok) return showInlineErr("fcf_errB", res.err);

      const out = document.getElementById("fcf_outB");
      out.innerHTML = `
        <div class="kpi"><span>DPS</span><span><b>${fmtNum(dps)}</b></span></div>
        <div class="kpi"><span>Shares</span><span><b>${fmtNum(shares)}</b></span></div>
        <div class="kpi"><span>Dividenden gesamt (berechnet)</span><span><b>${fmtNum(res.divAbs)}</b></span></div>
        <div class="kpi"><span>FCF</span><span><b>${fmtNum(res.fcf)}</b></span></div>
        <div class="kpi"><span><b>FCF-Payout</b></span><span><b>${res.ratio.toFixed(2).replace(".", ",")} %</b></span></div>
      `;
      out.style.display = "block";
    });
  }

enterIds.forEach(id => {
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener("keydown", (e) => {
    if(e.key === "Enter" && !e.shiftKey){
      e.preventDefault();
      // Option A Felder
      if(["fcf_divTotal","fcf_fcfA"].includes(id) && btnA) btnA.click();
      // Option B Felder
      if(["fcf_dps","fcf_shares","fcf_fcfB"].includes(id) && btnB) btnB.click();
    }
  });
});
}

document.addEventListener("DOMContentLoaded", bindFcfPayoutUI);




function calcPeTarget(){
  hideInlineErr("fp_peErr");

  const eps = parseNumberSmart(document.getElementById("fp_epsA")?.value);
  const pt  = parseNumberSmart(document.getElementById("fp_priceTarget")?.value);

  if(!Number.isFinite(eps)) return showInlineErr("fp_peErr", "Bitte EPS korrekt eingeben.");
  if(eps === 0) return showInlineErr("fp_peErr", "EPS darf nicht 0 sein.");
  if(!Number.isFinite(pt) || pt <= 0) return showInlineErr("fp_peErr", "Bitte Price Target korrekt (> 0) eingeben.");

  const pe = pt / eps;

  const out = document.getElementById("fp_peOut");
  if(!out) return;

  const warn = (eps < 0)
    ? `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: EPS ist negativ → KGV ist i. d. R. nicht sinnvoll (Turnaround/anderes Modell).</div>`
    : "";

  out.innerHTML = `
    <div class="kpi"><span>EPS</span><span><b>${fmtNum(eps)}</b></span></div>
    <div class="kpi"><span>Price Target</span><span><b>${fmtNum(pt)}</b></span></div>
    <div class="kpi"><span><b>KGV Target</b></span><span><b>${fmtNum(pe)}</b></span></div>
    ${warn}
    <div class="small" style="margin-top:6px">Tipp: Du kannst dieses KGV rechts übernehmen.</div>
  `;
  out.style.display = "block";

  // Komfort: übernehme KGV in Rechner B
  const peB = document.getElementById("fp_peTarget");
  if(peB) peB.value = String(Math.round(pe * 100) / 100).replace(".", ",");
}


function calcFairPriceStandalone(){
  hideInlineErr("fp_fairErr");

  const eps = parseNumberSmart(document.getElementById("fp_epsB")?.value);
  const pe  = parseNumberSmart(document.getElementById("fp_peTarget")?.value);

  if(!Number.isFinite(eps)) return showInlineErr("fp_fairErr", "Bitte EPS korrekt eingeben.");
  if(!Number.isFinite(pe) || pe <= 0) return showInlineErr("fp_fairErr", "Bitte KGV Target korrekt (> 0) eingeben.");

  const fair = eps * pe;

  const out = document.getElementById("fp_fairOut");
  if(!out) return;

  const warn = (eps < 0)
    ? `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: EPS ist negativ → Fair-Price via KGV ist i. d. R. nicht sinnvoll.</div>`
    : "";

  out.innerHTML = `
    <div class="kpi"><span>EPS</span><span><b>${fmtNum(eps)}</b></span></div>
    <div class="kpi"><span>KGV Target</span><span><b>${fmtNum(pe)}</b></span></div>
    <div class="kpi"><span><b>Fairer Preis</b></span><span><b>${fmtNum(fair)}</b></span></div>
    ${warn}
  `;
  out.style.display = "block";
}

function bindFairPriceUI(){
  const btnPe   = document.getElementById("fp_calcPe");
  const btnFair = document.getElementById("fp_calcFair");

  if(btnPe) btnPe.addEventListener("click", calcPeTarget);
  if(btnFair) btnFair.addEventListener("click", calcFairPriceStandalone);

  // Enter = berechnen
  const a = ["fp_epsA","fp_priceTarget"].map(id => document.getElementById(id)).filter(Boolean);
  const b = ["fp_epsB","fp_peTarget"].map(id => document.getElementById(id)).filter(Boolean);

  a.forEach(el => el.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcPeTarget(); } }));
  b.forEach(el => el.addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcFairPriceStandalone(); } }));
}

document.addEventListener("DOMContentLoaded", bindFairPriceUI);

  function applyModeUI(){
  const mode = document.getElementById("mode")?.value;

  const yearInputsWrap = document.getElementById("yearInputs")?.parentElement; // der Wrapper <div style="margin-top:14px">
  const priceBox = document.getElementById("price5yBox");

  // Years-Select Wrapper (das div, wo "Anzahl Jahre" drin ist)
  const yearsSelect = document.getElementById("years");
  const yearsSelectWrap = yearsSelect ? yearsSelect.closest("div") : null;

  if(mode === "price5y"){
    if(yearInputsWrap) yearInputsWrap.style.display = "none";
    if(yearsSelectWrap) yearsSelectWrap.style.display = "none";
    if(priceBox) priceBox.style.display = "block";
  } else {
    if(yearInputsWrap) yearInputsWrap.style.display = "block";
    if(yearsSelectWrap) yearsSelectWrap.style.display = "block";
    if(priceBox) priceBox.style.display = "none";
    buildYearInputs(true); // beim normalen UI-Refresh Werte behalten
  }

  bindEnterToCalculate(); // Enter-Binding nach UI-Umschalten erneuern
}

// --- Bewertung: KGV Target + Fairer Preis ---








  // --- Dynamic Inputs ---
function buildYearInputs(keepValues = true){
  const n = Number(document.getElementById("years").value);
  const box = document.getElementById("yearInputs");

  const prev = keepValues
    ? [...box.querySelectorAll("input")].map(i => i.value)
    : [];

  box.innerHTML = "";

  for(let i=1;i<=n;i++){
    const wrap = document.createElement("div");
    const lab = document.createElement("label");
    lab.textContent = `Jahr ${i}`;
    lab.style.display = "block";
    lab.style.marginBottom = "6px";

    const inp = document.createElement("input");
    inp.id = "y" + i;
    inp.placeholder = (i===1) ? "Start" : (i===n ? "Ende" : "");
    inp.inputMode = "decimal";
    inp.value = keepValues ? (prev[i-1] ?? "") : "";

    wrap.appendChild(lab);
    wrap.appendChild(inp);
    box.appendChild(wrap);
  }
}

  

  function bindEnterToCalculate(){
  const calcBtn = document.getElementById("calc");

  // alle Inputs/Selects, die Enter auslösen sollen
 const fields = document.querySelectorAll("#yearInputs input, #mode, #years, #pStart, #pEnd, #pYears");

  fields.forEach(el => {
    el.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        calcBtn.click();     // rechnet
      }
     });
   });
 }

if (document.getElementById("years")) {
  document.getElementById("years").addEventListener("change", () => buildYearInputs(true));
  buildYearInputs();
  bindEnterToCalculate();
  applyModeUI();
}
document.getElementById("mode").addEventListener("change", () => {
  hideErr();
  const out = document.getElementById("out");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  buildYearInputs(false); // << löscht die Jahreswerte beim Moduswechsel
  applyModeUI();
});


  // --- Compute ---
  document.getElementById("calc").addEventListener("click", ()=>{
    hideErr();
    const out = document.getElementById("out");
    out.style.display = "none";
    out.innerHTML = "";

    const n = Number(document.getElementById("years").value);
    const mode = document.getElementById("mode").value;
    const label =
   (mode === "revenue") ? "Umsatz" :
   (mode === "eps") ? "EPS" :
   (mode === "opmargin") ? "Operative Marge" :
   (mode === "dividend") ? "Dividende" :

   "Kurs";

    // values
  const vals = [];
for(let i=1;i<=n;i++){
  const raw = document.getElementById("y"+i).value;
  const v = (mode === "opmargin") ? parsePercentSmart(raw) : parseNumberSmart(raw);
  vals.push(v);
}
    

// --- Sondermodus: Kurs CAGR (fix 4 Jahre) ---
if(mode === "price5y"){
  const pStart = parseNumberSmart(document.getElementById("pStart").value);
  const pEnd   = parseNumberSmart(document.getElementById("pEnd").value);

  const pYearsRaw = parseNumberSmart(document.getElementById("pYears").value);
const pYears = Math.round(pYearsRaw);

if(!Number.isFinite(pYearsRaw)) return showErr("Bitte Jahre korrekt eingeben.");
if(pYears < 1 || pYears > 4) return showErr("Jahre müssen zwischen 1 und 4 liegen.");
  


  // UI-Wert sicher setzen (falls Browser cached o.ä.)
  
  const pYearsEl = document.getElementById("pYears");
  if (pYearsEl) pYearsEl.value = String(pYears);

  if(!Number.isFinite(pStart) || pStart <= 0) return showErr("Bitte Kurs vor ~4 Jahren korrekt (> 0) eingeben.");
  if(!Number.isFinite(pEnd)   || pEnd <= 0)   return showErr("Bitte Kurs heute korrekt (> 0) eingeben.");

  const g = cagr(pStart, pEnd, pYears);
  const rel = (pEnd / pStart) - 1;
  const abs = pEnd - pStart;

  let html = "";
  html += `<div class="kpi"><span><b>Kurs CAGR (${pYears} Jahre)</b></span><span><b>${fmtPct(g)}</b></span></div>`;
  html += `<div class="kpi highlight"><span><b>Gesamtwachstum</b></span><span><b>${fmtPct(rel)}</b></span></div>`;
  html += `<div class="kpi"><span>Absolute Veränderung</span><span>${fmtNum(abs)}</span></div>`;
  html += `<div class="kpi"><span>Kurs (Start → Ende)</span><span>${fmtNum(pStart)} → ${fmtNum(pEnd)}</span></div>`;

  out.innerHTML = html;
  out.style.display = "block";
  return;
}

    // validate: all filled + finite
    for(let i=0;i<n;i++){
      if(!Number.isFinite(vals[i])){
        return showErr(`Bitte Wert für Jahr ${i+1} korrekt eingeben.`);
      }
    }

    // CAGR needs start > 0 and end > 0
const start = vals[0];
const end = vals[n-1];

// --- Sondermodus: Operative Marge (Eingabe in %) ---
// Regeln:
// - CAGR nur sinnvoll, wenn Start% > 0 und Ende% > 0
// - Sonst: Veränderung in Prozentpunkten (pp)
if(mode === "opmargin"){
  const valsPct = vals.slice();              // z.B. 12,5 = 12,5%
  const valsRatio = valsPct.map(v => v/100); // für CAGR-Rechnung als Anteil

  const startPct = valsPct[0];
  const endPct   = valsPct[n-1];
  const startR   = valsRatio[0];
  const endR     = valsRatio[n-1];

  const yearsSpan = n - 1;

  // CAGR nur wenn Start & Ende > 0
  let g = NaN;
  let cagrOk = false;
  if(startPct > 0 && endPct > 0){
    g = cagr(startR, endR, yearsSpan);
    cagrOk = true;
  }

  // Veränderung in Prozentpunkten
  const deltaPP = endPct - startPct;
  const ppPerYear = deltaPP / yearsSpan;

  // YoY in pp
  const yoyPP = [];
  for(let i=1;i<n;i++){
    yoyPP.push(valsPct[i] - valsPct[i-1]);
  }

  // render
  let html = "";
  if(cagrOk){
    html += `<div class="kpi"><span><b>${label} CAGR (${yearsSpan} Jahre)</b></span><span><b>${fmtPct(g)}</b></span></div>`;
  } else {
    html += `<div class="kpi"><span><b>${label} CAGR (${yearsSpan} Jahre)</b></span><span><b>–</b></span></div>`;
    html += `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: Operative Marge ist in Jahr 1 oder Jahr ${n} ≤ 0 → CAGR ist i. d. R. nicht sinnvoll. Stattdessen: Veränderung (pp).</div>`;
  }

  html += `<div class="kpi"><span>Veränderung (gesamt)</span><span><b>${fmtNum(deltaPP)} pp</b></span></div>`;
  html += `<div class="kpi"><span>Veränderung pro Jahr</span><span><b>${fmtNum(ppPerYear)} pp/Jahr</b></span></div>`;
  html += `<div class="kpi"><span>Jahr 1 / Jahr ${n}</span><span>${fmtNum(startPct)} % → ${fmtNum(endPct)} %</span></div>`;

  html += `<table>
    <thead>
      <tr>
        <th>Jahr</th>
        <th>${label} (%)</th>
        <th>Δ ggü. Vorjahr (pp)</th>
      </tr>
    </thead>
    <tbody>
  `;

  for(let i=0;i<n;i++){
    const dpp = (i===0) ? "–" : `${fmtNum(yoyPP[i-1])} pp`;
    html += `<tr>
      <td>Jahr ${i+1}</td>
      <td>${fmtNum(valsPct[i])} %</td>
      <td>${dpp}</td>
    </tr>`;
  }

  html += `</tbody></table>`;

  out.innerHTML = html;
  out.style.display = "block";
  return; // wichtig: verhindert, dass die "normale" CAGR-Logik unten weiterläuft
}

// Für Umsatz/Dividende bleibt die harte Regel (keine negativen/0 Startwerte)
if(mode !== "eps"){
  if(start <= 0) return showErr(`Jahr 1 (${label}) muss > 0 sein, sonst ist CAGR nicht sinnvoll.`);
  if(end < 0) return showErr(`Letztes Jahr (${label}) darf nicht negativ sein.`);
}

// Für EPS: negative Werte sind erlaubt.
// CAGR ist aber nur sinnvoll, wenn Start und Ende > 0 (klassische CAGR-Definition).

 
// YoY
const yoy = [];
for(let i=1;i<n;i++){
  const prev = vals[i-1];
  const cur = vals[i];
  if(prev === 0){
    yoy.push(NaN);
  } else {
    yoy.push((cur / prev) - 1);
  }
}

    const yearsSpan = n - 1; // Jahr1->JahrN

     let g = NaN;              // CAGR (nur wenn sinnvoll) 
     let cagrOk = false;
 
     if(mode !== "eps"){
     g = cagr(start, end, yearsSpan);
     cagrOk = true;
} else {
  // EPS: CAGR nur wenn Start & Ende > 0
  if(start > 0 && end > 0){
    g = cagr(start, end, yearsSpan);
    cagrOk = true;
  }
}

     // Ø YoY (geometrisch), nur wenn alle Jahre gültig und > -100%
    let geoAvgYoy = NaN;
    let ok = true;
    let factor = 1;

    for (let i = 1; i < n; i++) {
    const prev = vals[i-1];
    const cur  = vals[i];

     if (!(prev > 0) || !(cur >= 0)) { ok = false; break; }
    factor *= (cur / prev);
   }

    if (ok) {
    geoAvgYoy = Math.pow(factor, 1/(n-1)) - 1;
 }

    // total growth
    let rel = NaN;
if(start !== 0){
  rel = (end / start) - 1; // bei EPS mit negativem Start interpretierbar, aber ok als Mathe-Wert
}
    const abs = end - start;

    // render
    let html = "";
    if(cagrOk){
  html += `<div class="kpi"><span><b>${label} CAGR (${yearsSpan} Jahre)</b></span><span><b>${fmtPct(g)}</b></span></div>`;
} else if(mode === "eps"){
  html += `<div class="kpi"><span><b>EPS CAGR (${yearsSpan} Jahre)</b></span><span><b>–</b></span></div>`;
  html += `<div class="small" style="margin-top:6px;color:#b00020">Hinweis: EPS ist in Jahr 1 oder Jahr ${n} ≤ 0 → CAGR ist i. d. R. nicht sinnvoll. Stattdessen: EPS-Veränderung.</div>`;
}
if(mode === "eps"){
  const delta = end - start;
  const perYear = delta / yearsSpan;
  html += `<div class="kpi"><span>EPS Veränderung (gesamt)</span><span>${fmtNum(delta)}</span></div>`;
  html += `<div class="kpi"><span>EPS Veränderung pro Jahr</span><span>${fmtNum(perYear)}</span></div>`;
}
    html += `<div class="kpi highlight"><span><b>Gesamtwachstum (Jahr 1 → Jahr ${n})</b></span><span><b>${fmtPct(rel)}</b></span></div>`;
    html += `<div class="kpi"><span>Absolute Veränderung</span><span>${fmtNum(abs)}</span></div>`;
    html += `<div class="kpi"><span>Jahr 1 / Jahr ${n}</span><span>${fmtNum(start)} → ${fmtNum(end)}</span></div>`;
    html += `<div class="kpi"><span>Ø Jahr-zu-Jahr Wachstum (geo)</span><span>${fmtPct(geoAvgYoy)}</span></div>`;

    html += `<table>
      <thead>
        <tr>
          <th>Jahr</th>
          <th>${label}</th>
          <th>Wachstum ggü. Vorjahr</th>
        </tr>
      </thead>
      <tbody>
    `;

    for(let i=0;i<n;i++){
      const growth = (i===0) ? "–" : (Number.isFinite(yoy[i-1]) ? fmtPct(yoy[i-1]) : "– (Vorjahr ≤ 0)");
      html += `<tr>
        <td>Jahr ${i+1}</td>
        <td>${fmtNum(vals[i])}</td>
        <td>${growth}</td>
      </tr>`;
    }

    html += `</tbody></table>`;

    out.innerHTML = html;
    out.style.display = "block";
  });





  function calcProfitCheck(){
  hideInlineErr("chk_profitErr");
  const out = document.getElementById("chk_profitOut");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  const ni = parseNumberSmart(document.getElementById("chk_netIncome")?.value);
  if(!Number.isFinite(ni)) return showInlineErr("chk_profitErr","Bitte Net Income korrekt eingeben.");

  const ok = ni > 0;

  out.innerHTML = `
    <div class="kpi"><span>Net Income</span><span><b>${fmtNum(ni)}</b></span></div>
    <div class="kpi"><span><b>Profitabel?</b></span><span><b>${ok ? "✅ ja" : "❌ nein"}</b></span></div>
    ${ni === 0 ? `<div class="small" style="margin-top:6px;color:#666">Hinweis: 0 ist weder Gewinn noch Verlust.</div>` : ""}
  `;
  out.style.display = "block";
}

function calcFcfCheck(){
  hideInlineErr("chk_fcfErr");
  const out = document.getElementById("chk_fcfOut");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  const fcf = parseNumberSmart(document.getElementById("chk_fcf")?.value);
  if(!Number.isFinite(fcf)) return showInlineErr("chk_fcfErr","Bitte FCF korrekt eingeben.");

  const ok = fcf > 0;

  out.innerHTML = `
    <div class="kpi"><span>FCF</span><span><b>${fmtNum(fcf)}</b></span></div>
    <div class="kpi"><span><b>FCF positiv?</b></span><span><b>${ok ? "✅ ja" : "❌ nein"}</b></span></div>
    ${fcf === 0 ? `<div class="small" style="margin-top:6px;color:#666">Hinweis: 0 bedeutet kein freier Cashflow übrig.</div>` : ""}
  `;
  out.style.display = "block";
}


function calcFcfFromOcfCapex(){
  hideInlineErr("chk_fcfFromErr");
  const out = document.getElementById("chk_fcfFromOut");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  const ocf = parseNumberSmart(document.getElementById("chk_ocf")?.value);
  const capex = parseNumberSmart(document.getElementById("chk_capex")?.value);

  if(!Number.isFinite(ocf)) return showInlineErr("chk_fcfFromErr","Bitte OCF korrekt eingeben.");
  if(!Number.isFinite(capex)) return showInlineErr("chk_fcfFromErr","Bitte CapEx korrekt eingeben.");

  // Logik:
  // CapEx negativ (z.B. -500) => FCF = OCF + CapEx
  // CapEx positiv (z.B. 500)  => FCF = OCF - CapEx
  const fcf = (capex < 0) ? (ocf + capex) : (ocf - capex);

  out.innerHTML = `
    <div class="kpi"><span>OCF</span><span><b>${fmtNum(ocf)}</b></span></div>
    <div class="kpi"><span>CapEx</span><span><b>${fmtNum(capex)}</b></span></div>
    <div class="kpi highlight"><span><b>FCF (berechnet)</b></span><span><b>${fmtNum(fcf)}</b></span></div>
    <div class="small" style="margin-top:6px">Übernommen in „FCF (FY)“ → du kannst direkt „Prüfen“ klicken.</div>
  `;
  out.style.display = "block";

  // In den bestehenden FCF-Check übernehmen
  const fcfInput = document.getElementById("chk_fcf");
  if(fcfInput) fcfInput.value = String(Math.round(fcf * 100) / 100).replace(".", ",");

  // Optional: direkt checken
  // calcFcfCheck();
}


function calcFcfPayoutInChecks(){
  hideInlineErr("chk_fcfPayoutErr");
  const out = document.getElementById("chk_fcfPayoutOut");
  if(out){ out.style.display="none"; out.innerHTML=""; }

  const divPaidRaw = parseNumberSmart(document.getElementById("chk_divPaid")?.value);
  const fcfRaw     = parseNumberSmart(document.getElementById("chk_fcfPayoutBase")?.value);

  if(!Number.isFinite(divPaidRaw)) return showInlineErr("chk_fcfPayoutErr","Bitte Dividends Paid korrekt eingeben.");
  if(!Number.isFinite(fcfRaw))     return showInlineErr("chk_fcfPayoutErr","Bitte FCF korrekt eingeben.");
  if(fcfRaw <= 0)                 return showInlineErr("chk_fcfPayoutErr","FCF ist ≤ 0 → Payout nicht sinnvoll / nicht gedeckt.");

  const divAbs = Math.abs(divPaidRaw);
  const payout = (divAbs / fcfRaw) * 100;

  out.innerHTML = `
    <div class="kpi"><span>Dividends Paid (|…|)</span><span><b>${fmtNum(divAbs)}</b></span></div>
    <div class="kpi"><span>FCF</span><span><b>${fmtNum(fcfRaw)}</b></span></div>
    <div class="kpi highlight"><span><b>FCF-Payout</b></span><span><b>${payout.toFixed(2).replace(".", ",")} %</b></span></div>
  `;
  out.style.display = "block";
}

document.addEventListener("DOMContentLoaded", bindChecksUI);

function bindChecksUI(){
  const b1 = document.getElementById("chk_profitBtn");
  const b2 = document.getElementById("chk_fcfBtn");
  const b3 = document.getElementById("chk_fcfFromBtn");
  const b4 = document.getElementById("chk_fcfPayoutBtn");

  if(b1) b1.addEventListener("click", calcProfitCheck);
  if(b2) b2.addEventListener("click", calcFcfCheck);
  if(b3) b3.addEventListener("click", calcFcfFromOcfCapex);
  if(b4) b4.addEventListener("click", calcFcfPayoutInChecks);
  

  const i1 = document.getElementById("chk_netIncome");
  const i2 = document.getElementById("chk_fcf");
  const i3 = document.getElementById("chk_ocf");
  const i4 = document.getElementById("chk_capex");

  if(i1) i1.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcProfitCheck(); }});
  if(i2) i2.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcFcfCheck(); }});
  if(i3) i3.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcFcfFromOcfCapex(); }});
  if(i4) i4.addEventListener("keydown",(e)=>{ if(e.key==="Enter"){ e.preventDefault(); calcFcfFromOcfCapex(); }});
}

document.addEventListener("DOMContentLoaded", bindChecksUI);



function bindShiftEnterDelegation(selector){
  document.addEventListener("keydown", (e) => {
    if (!(e.key === "Enter" && e.shiftKey)) return;

    const el = e.target;
    if (!(el instanceof HTMLElement)) return;

    // nur für Felder, die zu deinem Selector passen
    if (!el.matches(selector)) return;

    e.preventDefault();

    // aktuelles Feld-Set live holen (wichtig bei dynamischen Inputs!)
    const fields = Array.from(document.querySelectorAll(selector))
      .filter(x => !x.disabled && x.offsetParent !== null);

    const idx = fields.indexOf(el);
    const next = fields[idx + 1];
    if (next) next.focus();
  }, true); // capture=true, damit es nicht von anderen Enter-Handlern "geschluckt" wird
}

document.addEventListener("DOMContentLoaded", () => {
  bindShiftEnterDelegation(
    "#yearInputs input, #pStart, #pEnd, #pYears, " +
    "#chk_netIncome, #chk_fcf, #chk_ocf, #chk_capex, " +
    "#chk_divPaid, #chk_fcfPayoutBase, " +
    "#icr_ebit, #icr_interest, " +
    "#fp_epsA, #fp_priceTarget, #fp_epsB, #fp_peTarget, " +
    "#fcf_divTotal, #fcf_fcfA, #fcf_dps, #fcf_shares, #fcf_fcfB, " +
     "#fx_amount, #fx_from, #fx_to, #fx_manualRate"
  );
});

// ---------- Volatilität

// ---------- VOLATILITÄT (Std-Abw.) ----------
function parseVolLines(raw){
  let s = String(raw ?? "").trim();
  if(!s) return [];

  // Zeilen normalisieren
  s = s.replace(/\r/g, "\n");
  const lines = s.split("\n").map(x => x.trim()).filter(Boolean);

  const out = [];
  for(const line of lines){
    // Header-Zeilen überspringen
    const low = line.toLowerCase();
    if(low.includes("date") && (low.includes("close") || low.includes("adj"))) continue;

    // 1) bevorzugt Tab-splitting (Excel/Copy-Paste)
    let parts = line.includes("\t") ? line.split("\t") : null;

    // 2) fallback: mehrere Spaces
    if(!parts){
      parts = line.split(/\s{2,}|\s+\t|\t+\s+/).filter(Boolean);
      if(parts.length < 6){
        // noch robuster: alles nach "Volume" / etc. per single-space
        parts = line.split(/\s+/).filter(Boolean);
      }
    }

    // StockAnalysis: Date hat Komma -> meist als 3 Tokens wenn per single-space
    // Wir versuchen, ein Datum zu rekonstruieren:
    // Varianten:
    // A) parts[0] == "Feb", parts[1]=="20,", parts[2]=="2026"
    // B) parts[0] == "Feb 20, 2026" (wenn Tab)
    let dateStr = parts[0];

    if(/^[A-Za-z]{3,}$/.test(parts[0]) && parts.length >= 3 && parts[1].includes(",") && /^\d{4}$/.test(parts[2])){
      dateStr = `${parts[0]} ${parts[1]} ${parts[2]}`;
      parts = [dateStr, ...parts.slice(3)];
    }

    // Wenn es ein Tab-Paste war, ist date meist komplett in parts[0]
    // Numerische Felder: Open, High, Low, Close, Adj Close, Change%, Volume
    // Wir brauchen nur Close/AdjClose. Typisch sind mindestens 6 Zahlen.
    const dt = new Date(dateStr);
    if(!Number.isFinite(dt.getTime())) continue;

    // Versuche Close und Adj Close anhand typischer Position:
    // Nach Date kommen meist: Open High Low Close AdjClose Change% Volume
    // => closeIndex 3, adjIndex 4 (0-based in "parts" nach dem Datum)
    const open  = parseNumberSmart(parts[1]);
    const high  = parseNumberSmart(parts[2]);
    const lowP  = parseNumberSmart(parts[3]);
    const close = parseNumberSmart(parts[4]);
    const adj   = parseNumberSmart(parts[5]); // kann NaN sein, falls nicht vorhanden

    // Wenn Tab-Paste exakt ist, passt das. Wenn nicht, fallback: nimm die letzten 3-4 numerischen Spalten
    let closeUse = close;
    let adjUse = adj;

    // Fallback-Heuristik: finde alle parsebaren Zahlen (ohne Prozent)
    if(!Number.isFinite(closeUse)){
      const nums = parts
        .map(p => String(p).replace("%",""))
        .map(p => parseNumberSmart(p))
        .filter(n => Number.isFinite(n));

      // Bei StockAnalysis sind die ersten 5 nums typischerweise O/H/L/C/Adj
      if(nums.length >= 4) closeUse = nums[3];
      if(nums.length >= 5) adjUse = nums[4];
    }

    out.push({
      date: dt,
      dateStr,
      close: closeUse,
      adjClose: adjUse
    });
  }

  return out;
}

function stdevSample(arr){
  const n = arr.length;
  if(n < 2) return NaN;
  let mean = 0;
  for(const x of arr) mean += x;
  mean /= n;

  let ss = 0;
  for(const x of arr){
    const d = x - mean;
    ss += d*d;
  }
  return Math.sqrt(ss / (n - 1));
}

function mean(arr){
  if(!arr.length) return NaN;
  let s=0; for(const x of arr) s+=x;
  return s/arr.length;
}

function bindVolUI(){
  const ta = document.getElementById("vol_big");
  const btn = document.getElementById("vol_calcBtn");
  const clr = document.getElementById("vol_clearBtn");
  const err = document.getElementById("vol_err");
  const out = document.getElementById("vol_out");

  if(!btn || !ta || !out || !err) return;

  function showVolErr(m){
    err.style.display="block";
    err.textContent=m;
  }
  function hideVolErr(){
    err.style.display="none";
    err.textContent="";
  }

  function getRetType(){
    const r = document.querySelector('input[name="vol_retType"]:checked');
    return r ? r.value : "simple";
  }

  btn.addEventListener("click", () => {
    hideVolErr();
    out.style.display="none";
    out.innerHTML="";

    const rows = parseVolLines(ta.value);
    if(rows.length < 3) return showVolErr("Zu wenig Daten erkannt. Bitte mehrere Tage einfügen (mind. 3 Zeilen).");

    // Preis wählen: Adj Close wenn vorhanden und >0, sonst Close
    const usable = rows
      .map(r => ({
        date: r.date,
        px: (Number.isFinite(r.adjClose) && r.adjClose > 0) ? r.adjClose : r.close
      }))
      .filter(r => Number.isFinite(r.px) && r.px > 0);

    if(usable.length < 3) return showVolErr("Konnte keine gültigen Close/Adj Close Preise erkennen.");

    // Sortiere nach Datum aufsteigend
    usable.sort((a,b)=>a.date - b.date);

    // Returns berechnen
    const retType = getRetType();
    const rets = [];
    for(let i=1;i<usable.length;i++){
      const p0 = usable[i-1].px;
      const p1 = usable[i].px;
      if(p0 <= 0 || p1 <= 0) continue;
      const r = (retType === "log") ? Math.log(p1/p0) : (p1/p0 - 1);
      if(Number.isFinite(r)) rets.push(r);
    }

    if(rets.length < 2) return showVolErr("Zu wenige gültige Returns (nach Filterung).");

    const sd = stdevSample(rets);
    const mu = mean(rets);
    const minR = Math.min(...rets);
    const maxR = Math.max(...rets);

    const annualize = document.getElementById("vol_annualize")?.value === "yes";
    const factor = annualize ? Math.sqrt(252) : 1;
    const sdAdj = sd * factor;

    const fmtPctLocal = (x) => (x*100).toFixed(2).replace(".", ",") + " %";
    const from = usable[0].date.toLocaleDateString("de-DE");
    const to   = usable[usable.length-1].date.toLocaleDateString("de-DE");

    out.innerHTML = `
      <div class="kpi"><span>Zeitraum</span><span><b>${from} → ${to}</b></span></div>
      <div class="kpi"><span>Zeilen (Preise)</span><span><b>${usable.length}</b></span></div>
      <div class="kpi"><span>Returns</span><span><b>${rets.length}</b></span></div>

      <div class="kpi highlight"><span><b>Volatilität (Std-Abw.)</b></span><span><b>${fmtPctLocal(sdAdj)}</b></span></div>

      <div class="kpi"><span>Ø täglicher Return</span><span>${fmtPctLocal(mu)}</span></div>
      <div class="kpi"><span>Min / Max Return</span><span>${fmtPctLocal(minR)} / ${fmtPctLocal(maxR)}</span></div>

      <div class="small" style="margin-top:8px">
        Return-Typ: <b>${retType === "log" ? "Log Returns" : "Simple Returns"}</b><br/>
        Annualisierung: <b>${annualize ? "Ja (× √252)" : "Nein (täglich)"}</b>
      </div>
    `;
    out.style.display = "block";
  });

  if(clr){
    clr.addEventListener("click", () => {
      ta.value = "";
      hideVolErr();
      out.style.display = "none";
      out.innerHTML = "";
    });
  }
}

document.addEventListener("DOMContentLoaded", bindVolUI);

  // Enter im Textarea soll normal Zeilenumbruch machen (kein Berechnen).





// ---------- Euro - Dollar ----------
const FX_OFFLINE_DEFAULT = 0.92; // 1 USD = 0,92 EUR (kannst du ändern)

// LocalStorage Keys (damit "standardmäßig offline", aber mit Cache)
const FX_LS_RATE_KEY = "fx_usd_eur_rate";
const FX_LS_TIME_KEY = "fx_usd_eur_rate_ts";

// Frankfurter API (ECB-Daten, werktags). Wir holen USD->EUR.
const FX_API = "https://api.frankfurter.app/latest?from=USD&to=EUR";

// --- Helper ---
function fxNowMs(){ return Date.now(); }
function fxIsFresh(tsMs, maxAgeHours=24){
  if(!Number.isFinite(tsMs)) return false;
  return (fxNowMs() - tsMs) <= maxAgeHours*60*60*1000;
}
function fxFmtRate(x){
  if(!Number.isFinite(x)) return "–";
  return x.toLocaleString("de-DE",{minimumFractionDigits:4, maximumFractionDigits:6});
}
function fxFmtMoney(x, ccy){
  if(!Number.isFinite(x)) return "–";
  // ohne Intl-Währungsformat (weil du eh DE/EN mischst) – schlicht:
  return `${x.toLocaleString("de-DE",{maximumFractionDigits:2})} ${ccy}`;
}

// Rate lesen: Cache -> Default
function fxGetStoredRate(){
  const r = Number(localStorage.getItem(FX_LS_RATE_KEY));
  const ts = Number(localStorage.getItem(FX_LS_TIME_KEY));
  if(Number.isFinite(r) && r>0) return { rate:r, ts };
  return { rate: FX_OFFLINE_DEFAULT, ts: NaN };
}
function fxStoreRate(rate){
  if(!Number.isFinite(rate) || rate<=0) return;
  localStorage.setItem(FX_LS_RATE_KEY, String(rate));
  localStorage.setItem(FX_LS_TIME_KEY, String(fxNowMs()));
}

// Aktuelle Rate für UI konstruieren abhängig von From/To
// Basis ist immer usdEur = 1 USD in EUR
function fxGetEffectiveRate(from, to, usdEur){
  if(from === to) return 1;
  // Wenn von USD nach EUR: usdEur
  if(from === "USD" && to === "EUR") return usdEur;
  // Wenn von EUR nach USD: inverse
  if(from === "EUR" && to === "USD") return 1 / usdEur;
  // Fallback
  return NaN;
}

async function fxFetchFrankfurterUsdEur(){
  const res = await fetch(FX_API, { cache:"no-store" });
  if(!res.ok) throw new Error("HTTP " + res.status);
  const data = await res.json();
  const rate = data?.rates?.EUR;
  const date = data?.date; // yyyy-mm-dd (Tageskurs)
  if(!Number.isFinite(rate) || rate<=0) throw new Error("Rate fehlt/ungültig");
  return { rate, date };
}

function bindFxUI(){

  console.log("bindFxUI start", {
  amount: !!document.getElementById("fx_amount"),
  from: !!document.getElementById("fx_from"),
  to: !!document.getElementById("fx_to"),
  calc: !!document.getElementById("fx_calcBtn"),
  rateBox: !!document.getElementById("fx_rateBox")
});
  const amountEl = document.getElementById("fx_amount");
  const fromEl   = document.getElementById("fx_from");
  const toEl     = document.getElementById("fx_to");
  const swapBtn  = document.getElementById("fx_swapBtn");
  const refreshBtn = document.getElementById("fx_refreshBtn");
  const manualEl = document.getElementById("fx_manualRate");
  const calcBtn  = document.getElementById("fx_calcBtn");
  const errEl    = document.getElementById("fx_err");
  const outEl    = document.getElementById("fx_out");
  const rateBox  = document.getElementById("fx_rateBox");

  if(!amountEl || !fromEl || !toEl || !swapBtn || !refreshBtn || !manualEl || !calcBtn || !errEl || !outEl || !rateBox) return;

  function showFxErr(msg){
    errEl.style.display="block";
    errEl.textContent=msg;
  }
  function hideFxErr(){
    errEl.style.display="none";
    errEl.textContent="";
  }
  function setRateBox(text){
    rateBox.innerHTML = text;
  }

  // 1) Init: Offline Default + ggf. Cache anzeigen
  const stored = fxGetStoredRate();
  let usdEur = stored.rate; // 1 USD in EUR
  let ts = stored.ts;

  // Manual field standardmäßig NICHT überschreiben, wenn User schon was eingetippt hat
  function syncManualPlaceholder(){
    const from = fromEl.value;
    const to   = toEl.value;
    const rEff = fxGetEffectiveRate(from, to, usdEur);
    // Wir setzen den Input nur, wenn er leer ist (damit "offline standardmäßig")
    if(!manualEl.value){
      manualEl.value = String(Math.round(rEff*1000000)/1000000).replace(".", ",");
    }
  }

  function renderRateStatus(extraNote=""){
    const from = fromEl.value, to = toEl.value;
    const eff = fxGetEffectiveRate(from, to, usdEur);
    const ageTxt = Number.isFinite(ts)
      ? ` (Cache: ${new Date(ts).toLocaleString("de-DE")})`
      : " (Offline-Default)";

    setRateBox(`
      <div><b>Basis:</b> 1 USD = ${fxFmtRate(usdEur)} EUR${ageTxt}</div>
      <div><b>Aktiv:</b> 1 ${from} = ${fxFmtRate(eff)} ${to}</div>
      ${extraNote ? `<div class="vol-muted" style="margin-top:6px">${extraNote}</div>` : ""}
    `);
  }

  syncManualPlaceholder();
  renderRateStatus(fxIsFresh(ts,24) ? "" : "Hinweis: Cache älter/leer → aktuell wird der Offline-Default genutzt (bis du aktualisierst).");

  // 2) Convert
  function fxConvert(){
    hideFxErr();
    outEl.style.display="none";
    outEl.innerHTML="";

    const amt = parseNumberSmart(amountEl.value);
    if(!Number.isFinite(amt)) return showFxErr("Bitte Betrag korrekt eingeben.");

    const from = fromEl.value;
    const to   = toEl.value;
    if(from === to){
      outEl.innerHTML = `<div class="kpi highlight"><span><b>Ergebnis</b></span><span><b>${fxFmtMoney(amt,to)}</b></span></div>`;
      outEl.style.display="block";
      return;
    }

    // Manual Rate: wenn vorhanden, nimmt Vorrang (genau wie du es wolltest)
    let rateManual = parseNumberSmart(manualEl.value);
    const hasManual = Number.isFinite(rateManual) && rateManual > 0;

    const rate = hasManual ? rateManual : fxGetEffectiveRate(from, to, usdEur);
    if(!Number.isFinite(rate) || rate<=0) return showFxErr("Kurs ist ungültig. Bitte Kurs eintragen oder aktualisieren.");

    const result = amt * rate;

    const src = hasManual ? "Manuell" : (Number.isFinite(ts) ? "Cache/Frankfurter" : "Offline-Default");
    outEl.innerHTML = `
      <div class="kpi"><span>Quelle</span><span><b>${src}</b></span></div>
      <div class="kpi"><span>Kurs</span><span><b>1 ${from} = ${fxFmtRate(rate)} ${to}</b></span></div>
      <div class="kpi highlight"><span><b>Ergebnis</b></span><span><b>${fxFmtMoney(result,to)}</b></span></div>
    `;
    outEl.style.display="block";
  }

  // 3) Refresh (Frankfurter) – optional, nur per Button (=> standardmäßig offline)
  async function fxRefresh(){
    hideFxErr();
    setRateBox(`Lade Kurs von Frankfurter…`);

    try{
      const { rate, date } = await fxFetchFrankfurterUsdEur();
      usdEur = rate;
      fxStoreRate(rate);
      ts = Number(localStorage.getItem(FX_LS_TIME_KEY)) || fxNowMs();

      // Manual-Feld nur überschreiben, wenn leer ODER wenn es exakt der bisherige Auto-Wert war
      // (damit User-Manuell nicht "kaputt" geht)
      const from = fromEl.value, to = toEl.value;
      const eff = fxGetEffectiveRate(from,to,usdEur);

      if(!manualEl.value){
        manualEl.value = String(Math.round(eff*1000000)/1000000).replace(".", ",");
      }

      renderRateStatus(`Stand (Frankfurter/ECB): ${date} (werktags).`);
    }catch(e){
      const fallback = fxGetStoredRate();
      usdEur = fallback.rate;
      ts = fallback.ts;
      renderRateStatus("Konnte online nicht laden → nutze Offline/Cache.");
      showFxErr("Kurs konnte nicht aktualisiert werden (offline?).");
    }
  }

  // 4) Swap
  function fxSwap(){
    const a = fromEl.value;
    fromEl.value = toEl.value;
    toEl.value = a;

    // Manual placeholder neu setzen (nur wenn leer)
    syncManualPlaceholder();
    renderRateStatus();
  }

  // Events
  calcBtn.addEventListener("click", fxConvert);
  refreshBtn.addEventListener("click", fxRefresh);
  swapBtn.addEventListener("click", fxSwap);

  // Wenn User From/To ändert: Rate-Box + (optional) Auto-Manual setzen, wenn leer
  fromEl.addEventListener("change", () => { syncManualPlaceholder(); renderRateStatus(); });
  toEl.addEventListener("change",   () => { syncManualPlaceholder(); renderRateStatus(); });

  // Enter = umrechnen
  [amountEl, manualEl].forEach(el=>{
    el.addEventListener("keydown",(e)=>{
      if(e.key==="Enter" && !e.shiftKey){
        e.preventDefault();
        fxConvert();
      }
    });
  });
}







// ---------- NUTZEN CHECK (55 Spalten + 1 großes Feld) ----------



/* ===============================
   PHASE 1: Normalize Helpers
================================ */

function nzNumber(x){
  if(x === null || x === undefined) return NaN;
  if(typeof x === "number") return Number.isFinite(x) ? x : NaN;

  let s = String(x).trim();
  if(!s) return NaN;

  const low = s.toLowerCase();
  if(["n/a","na","—","-","null",""].includes(low)) return NaN;

  let neg = false;
  if(/^\(.*\)$/.test(s)){ neg = true; s = s.slice(1,-1).trim(); }
  if(s.startsWith("-")){ neg = true; s = s.slice(1).trim(); }

  // remove currency words/symbols
  s = s.replace(/[$€£¥]|usd|eur|gbp|jpy/gi, "").trim();

  // unit suffix K/M/B/T
  let mult = 1;
  const unitMatch = s.match(/([0-9.,]+)\s*([kmbt])\b/i);
  if(unitMatch){
    s = unitMatch[1];
    const u = unitMatch[2].toLowerCase();
    if(u==="k") mult = 1e3;
    if(u==="m") mult = 1e6;
    if(u==="b") mult = 1e9;
    if(u==="t") mult = 1e12;
  }

  // keep only digits and separators
  s = s.replace(/[^\d.,]/g, "");

  const hasDot = s.includes(".");
  const hasComma = s.includes(",");
  if(hasDot && hasComma){
    const lastDot = s.lastIndexOf(".");
    const lastComma = s.lastIndexOf(",");
    if(lastComma > lastDot){
      s = s.replace(/\./g, "").replace(/,/g, ".");
    }else{
      s = s.replace(/,/g, "");
    }
  }else if(hasComma && !hasDot){
    s = s.replace(/,/g, ".");
  }else{
    s = s.replace(/,/g, "");
  }

  const v = Number(s);
  if(!Number.isFinite(v)) return NaN;
  const out = v * mult;
  return neg ? -out : out;
}

function nzPercent(x){
  if(x === null || x === undefined) return NaN;
  return nzNumber(String(x).replace("%",""));
}


function nutzenDevCheckHeaders(){
  const must = ["KGV target","Fairer Preis","Kurs aktuell","52-Week Range"];
  const missing = must.filter(h => !NUTZEN_HEADERS.includes(h));
  if(missing.length) console.warn("Nutzen DevCheck – Missing headers:", missing);
}


function nutzenDevCheckDOM(){
  const ids = [
    "nutzenHeadRow","nutzenValueRow","nutzen_roles",
    "nutzen_parseBtn","nutzen_clearBtn",
    "nutzen_cagrYears","nutzen_volYears",
    "nutzenStressSelect","nutzenStressWhy",
    "nutzen_overlayBtn","nutzenOverlay","nutzenOverlayBackdrop"
  ];
  const missing = ids.filter(id => !document.getElementById(id));
  if(missing.length) console.warn("Nutzen DevCheck – Missing DOM IDs:", missing);
}

function nutzenDevCheckTableShape(){
  const headRow = document.getElementById("nutzenHeadRow");
  const valRow  = document.getElementById("nutzenValueRow");
  if(!headRow || !valRow) return;

  const ths = headRow.querySelectorAll("th").length;
  const tds = valRow.querySelectorAll("td").length;

  if(ths !== NUTZEN_HEADERS.length || tds !== NUTZEN_HEADERS.length){
    console.warn("Nutzen DevCheck – Table shape mismatch", {
      headers: NUTZEN_HEADERS.length, ths, tds
    });
  }
}

function nutzenDevCheckYearMeta(){
  // Prüft: (1) YearMeta passt auf alle erwarteten Muster, (2) Select-Werte existieren
  const yearsCagrInHeaders = new Set();
  const yearsVolInHeaders  = new Set();

  for(const h of NUTZEN_HEADERS){
    const meta = nutzenYearMeta(h);
    if(!meta) continue;
    if(meta.type === "cagr") yearsCagrInHeaders.add(meta.year);
    if(meta.type === "vol")  yearsVolInHeaders.add(meta.year);
  }

  const selC = document.getElementById("nutzen_cagrYears");
  const selV = document.getElementById("nutzen_volYears");

  const cVals = selC ? Array.from(selC.options).map(o=>Number(o.value)).filter(Number.isFinite) : [];
  const vVals = selV ? Array.from(selV.options).map(o=>Number(o.value)).filter(Number.isFinite) : [];

  const missingC = [...yearsCagrInHeaders].filter(y => !cVals.includes(y));
  const missingV = [...yearsVolInHeaders].filter(y => !vVals.includes(y));

  if(missingC.length) console.warn("Nutzen DevCheck – CAGR years in headers but not in select:", missingC);
  if(missingV.length) console.warn("Nutzen DevCheck – VOL years in headers but not in select:", missingV);
}

function nutzenDevCheckRuntime(){
  const mustFns = [
    "nutzenEvaluateAll","renderNutzenRolesBox","nutzenApplyAutoToUI",
    "openNutzenOverlay","closeNutzenOverlay",
    "nutzenSyncStress","ovRenderActionsSummary"
  ];
  const missing = mustFns.filter(fn => typeof window[fn] !== "function");
  if(missing.length) console.warn("Nutzen DevCheck – Missing functions:", missing);
}


function nzYesNo(x){
  if(x === null || x === undefined) return null;
  const s = String(x).trim().toLowerCase();
  if(!s) return null;
  if(["ja","yes","true","1","positiv","positive"].includes(s)) return true;
  if(["nein","no","false","0","negativ","negative"].includes(s)) return false;
  return null;
}

function nzParse52w(x){
  const s = (x ?? "").toString();
  const nums = s.match(/-?\(?[\d.,]+(?:\s*[kmbt])?\)?/gi);
  if(!nums || nums.length < 2) return { low: NaN, high: NaN };
  const a = nzNumber(nums[0]);
  const b = nzNumber(nums[1]);
  if(!Number.isFinite(a) || !Number.isFinite(b)) return { low: NaN, high: NaN };
  return { low: Math.min(a,b), high: Math.max(a,b) };
}

// tolerant header getter (fängt doppelte spaces / kleine Variationen ab)
function getH(m, ...candidates){
  for(const k of candidates){
    if(k in m) return m[k];
  }
  // fallback: normalize spaces and compare
  const keys = Object.keys(m);
  for(const want of candidates){
    const w = want.replace(/\s+/g," ").trim();
    const hit = keys.find(real => real.replace(/\s+/g," ").trim() === w);
    if(hit) return m[hit];
  }
  return undefined;
}


/* ===============================
   PHASE 1: Normalize Company
   input:  m = { "<Header>": "<string>", ... }
   output: d = normalized stable keys
================================ */

function normalizeCompany(m){
  const d = {};

  // 1) Revenue (FY)
  d.revenue_fy = nzNumber(getH(m, "Revenue (FY)"));

  // 2) Revenue CAGR 1/2/3/4Y (du willst mind. 4Y anzeigen, aber Set ist da)
  for(const y of CAGR_YEARS){
    d[`revenue_cagr_${y}y`] = nzPercent(getH(m, `Revenue Growth ${y}Y (CAGR)`, `Revenue  ${y}Y (CAGR)`, `Revenue ${y}Y (CAGR)`));
  }

  // 3) Revenue Growth 1Y (YoY)
  d.revenue_yoy_1y = nzPercent(getH(m, "Revenue Growth  1Y (YoY)", "Revenue Growth 1Y (YoY)"));

  // 4) Interest Expense 1Y
  d.interest_exp_1y = nzNumber(getH(m, "Interest Expense 1Y"));

  // 5) Net Income Y1 + Positiv Flag
  d.net_income_1y  = nzNumber(getH(m, "Net Income Y1"));
  d.net_income_yes = nzYesNo(getH(m, "Net income positiv (Ja/Nein)"));

  // 6) EPS (Diluted, FY) + EPS CAGR 1/2/3/4Y
  d.eps_fy = nzNumber(getH(m, "EPS 1Y (Diluted, FY)", "EPS (Diluted, FY)"));
  for(const y of CAGR_YEARS){
    d[`eps_cagr_${y}y`] = nzPercent(getH(m, `EPS Growth ${y}Y (CAGR)`));
  }

  // 7) Operating Margin pp CAGR 1/2/3/4Y + Operating Margin 1Y
  for(const y of CAGR_YEARS){
    d[`op_margin_pp_cagr_${y}y`] = nzNumber(getH(m, `Operating Margin ${y}Y pp (CAGR)`, `Operating Margin pp ${y}Y (CAGR)`));
  }
  d.op_margin_1y = nzPercent(getH(m, "Operating Margin 1Y"));

  // 8) Profit / EBITDA / Gross
  d.profit_margin_1y  = nzPercent(getH(m, "Profit Margin 1Y"));
  d.ebitda_1y         = nzNumber(getH(m, "EBITDA 1Y"));
  d.ebitda_margin_1y  = nzPercent(getH(m, "EBITDA Margin 1Y"));
  d.dps_cagr_4y        = nzPercent(getH(m, " Dividende (DPS) 4Y (CAGR)", "Dividende (DPS) 4Y (CAGR)"));
  d.gross_margin_1y    = nzPercent(getH(m, "Gross Margin 1Y"));

  // 9) Cash & ST Investments 1Y
  d.cash_st_invest_1y  = nzNumber(getH(m, "Cash& Short- Term Investments 1Y", "Cash & Short- Term Investments 1Y"));

  // 10) Beta + 52W Range
  d.beta = nzNumber(getH(m, "Beta"));
  const r52 = nzParse52w(getH(m, "52- Week Range", "52 Week Range"));
  d.range52_low  = r52.low;
  d.range52_high = r52.high;

  // 11) KGV target + Fairer Preis
  d.pe_target       = nzNumber(getH(m, "KGV target"));
  d.fair_price_input= nzNumber(getH(m, "Fairer Preis"));

  // 12) Cashflow / Capex / Buybacks / FCF
  d.ocf_1y        = nzNumber(getH(m, "Operating Cash Flow 1Y"));
  d.capex_1y      = nzNumber(getH(m, "Capital Expenditures 1Y"));
  d.repurchases_1y= nzNumber(getH(m, "Repurchase of Common Stock 1Y"));

  d.fcf_1y        = nzNumber(getH(m, "FCF 1Y"));
  // fcf conversion: wenn du es als Zahl 0.8 oder als "80%" führst → aktuell als Number; später können wir typisieren
  d.fcf_conv      = nzNumber(getH(m, "FCF Conversion"));
  d.fcf_margin_1y = nzPercent(getH(m, "FCF-Marge 1Y"));
  d.fcf_yes       = nzYesNo(getH(m, "FCF positiv (Ja/Nein)"));
  d.fcf_payout    = nzPercent(getH(m, "FCF-Payout"));
  d.fcf_ps_1y     = nzNumber(getH(m, "Free Cash Flow Per Share 1Y"));

  // 13) Enterprise/Valuation
  d.enterprise_value_1y = nzNumber(getH(m, "Enterprise Value 1Y"));
  d.pe_1y               = nzNumber(getH(m, "KGV (PE Ratio) 1Y"));
  d.p_fcf_1y            = nzNumber(getH(m, "P/FCF Ratio  1Y", "P/FCF Ratio 1Y"));
  d.ev_ebitda_1y        = nzNumber(getH(m, "EV/ EBITDA Ratio 1Y", "EV/ EBITDA Ratio 1"));

  // 14) Zusätzliche neue Felder aus deiner Liste (Ratio-Block)
  d.ev_fcf_ratio        = nzNumber(getH(m, "EV/ FCF Ratio", "EV/FCF Ratio"));
  d.debt_fcf_ratio      = nzNumber(getH(m, "Debt / FCF Ratio"));
  d.net_debt_ebitda_1y  = nzNumber(getH(m, "Net Debt / EBITDA Ratio 1Y"));

  d.quick_ratio_1y      = nzNumber(getH(m, "Quick Ratio 1Y"));
  d.current_ratio_1y    = nzNumber(getH(m, "Current Ratio 1Y"));

  d.roe_1y              = nzPercent(getH(m, "ROE 1Y"));
  d.roic_1y             = nzPercent(getH(m, "ROIC 1Y"));
  d.roce_1y             = nzPercent(getH(m, "ROCE 1Y"));

  d.fcf_yield_1y        = nzPercent(getH(m, "FCF Yield 1Y"));
  d.payout_ratio_1y     = nzPercent(getH(m, "Payout Ratio 1Y"));
  d.interest_coverage_1y= nzNumber(getH(m, "Zinsdeckung 1Y (Interest Coverage)", "Interest Coverage 1Y"));

  // 15) Shares / Marketcap / Dividend details
  d.shares_outstanding_1y = nzNumber(getH(m, "Shares Outstanding 1Y"));
  d.market_cap            = nzNumber(getH(m, "Marktkapitalisierung", "Market Cap"));
  d.shares_change_yoy     = nzPercent(getH(m, "Shares Change (YoY)", "Shares Change YoY"));

  d.dividend_pa           = nzNumber(getH(m, "Dividende (p.a.)"));
  d.div_frequency         = getH(m, "Div.- Frequency", "Div. Frequency");
  d.div_yield_current_pct = nzPercent(getH(m, "Div.-Rendite aktuell (%)", "Dividend Yield (%)"));

  d.div_growth_years      = nzNumber(getH(m, "Dividend Growth years"));
  d.div_growth_pct        = nzPercent(getH(m, "Dividend Growth"));

  d.buyback_yield         = nzPercent(getH(m, "Buyback Yield"));
  d.shareholder_yield     = nzPercent(getH(m, "Shareholder Yield"));

  // 16) Kurs aktuell + Kurs CAGR 1/2/3/4Y (OPEN) + Vol 1/5/10Y
  d.price_current = nzNumber(getH(m, "Kurs aktuell", "Price", "Current Price"));

  for(const y of CAGR_YEARS){
    d[`price_cagr_${y}y`] = nzPercent(getH(m, `Kurs ${y}Y (CAGR) OPEN`, `Kurs ${y}Y (CAGR)`, `Price ${y}Y (CAGR)`));
  }

  for(const y of VOL_YEARS){
    // du hattest "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y"
    d[`vol_${y}y`] = nzPercent(getH(m, `Volatilität annualisiert (Std-Abw.) ${y}Y`, `Volatilität ${y}Y`));
  }

  return d;
}




// 55 Headers (wie von dir gewünscht)
const NUTZEN_HEADERS = [
  "Revenue (FY)",
  "Revenue 4Y (CAGR)",
  "Revenue Growth 1Y (YoY)",
  "Interest Expense 1Y",
  "Net Income 1Y",
  "Net Income positiv (Ja/Nein)",
  "EPS 1Y (Diluted, FY)",
  "EPS Growth 4Y (CAGR)",
  "Operating Margin 4Y pp (CAGR)",
  "Operating Margin 1Y",
  "Profit Margin 1Y",
  "EBITDA 1Y",
  "EBITDA Margin 1Y",
  "Dividende (DPS) 4Y (CAGR)",
  "Gross Margin 1Y",
  "Cash & Short-Term Investments 1Y",
  "Beta",
  "52-Week Range",
  "KGV target",
  "Fairer Preis",
  "Operating Cash Flow 1Y",
  "Capital Expenditures 1Y",
  "Repurchase of Common Stock 1Y",
  "FCF 1Y",
  "FCF Conversion",
  "FCF-Marge 1Y",
  "FCF positiv (Ja/Nein)",
  "FCF-Payout",
  "Free Cash Flow per Share 1Y",
  "Enterprise Value 1Y",
  "KGV (PE Ratio) 1Y",
  "P/FCF Ratio 1Y",
  "EV/EBITDA Ratio 1Y",
  "EV/FCF Ratio",
  "Debt / FCF Ratio",
  "Net Debt / EBITDA Ratio 1Y",
  "Quick Ratio 1Y",
  "Current Ratio 1Y",
  "ROE 1Y",
  "ROIC 1Y",
  "ROCE 1Y",
  "FCF Yield 1Y",
  "Payout Ratio 1Y",
  "Zinsdeckung 1Y (Interest Coverage)",
  "Shares Outstanding 1Y",
  "Marktkapitalisierung",
  "Shares Change (YoY)",
  "Dividende (p.a.)",
  "Div.-Frequency",
  "Div.-Rendite aktuell (%)",
  "Dividend Growth years",
  "Dividend Growth",
  "Buyback Yield",
  "Shareholder Yield",
  "Kurs aktuell",
  "Kurs 4Y (CAGR)",
  "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",
];



// =============================
// Phase 9: Header-Aliases (Kompatibilität)
// =============================
const NUTZEN_HEADER_ALIASES = {
  // canonical passt final
  "KGV Target": "KGV target",
  "KGV target": "KGV target",

  "52 Week Range": "52-Week Range",
  "52-Week Range": "52-Week Range",

  // Cash
  "Cash& Short- Term Investments 1Y": "Cash & Short-Term Investments 1Y",
  "Cash& Short-Term Investments 1Y": "Cash & Short-Term Investments 1Y",
  "Cash & Short- Term Investments 1Y": "Cash & Short-Term Investments 1Y",
  "Cash & Short-Term Investments 1Y": "Cash & Short-Term Investments 1Y",

  // Net income positiv
  "Net income positiv (Ja/Nein)": "Net Income positiv (Ja/Nein)",
  "Net Income positiv (Ja/Nein)": "Net Income positiv (Ja/Nein)",

  // Revenue CAGR alt -> final
  "Revenue Growth 4Y (CAGR)": "Revenue 4Y (CAGR)",
  "Revenue 4Y (CAGR)": "Revenue 4Y (CAGR)",

  // OPM pp alt -> final
  "Operating Margin pp 4Y (CAGR)": "Operating Margin 4Y pp (CAGR)",
  "Operating Margin 4Y pp (CAGR)": "Operating Margin 4Y pp (CAGR)",

  // FCF Conversion
  "FCF Conversion 1Y": "FCF Conversion",
  "FCF Conversion": "FCF Conversion",

  // EV/EBITDA final (ohne Space)
  "EV/ EBITDA Ratio 1Y": "EV/EBITDA Ratio 1Y",
  "EV/EBITDA Ratio 1Y": "EV/EBITDA Ratio 1Y",

  // EV/FCF final (ohne 1Y)
  "EV/ FCF Ratio 1Y": "EV/FCF Ratio",
  "EV/FCF Ratio 1Y": "EV/FCF Ratio",
  "EV/FCF Ratio": "EV/FCF Ratio",

  // Debt/FCF final (ohne 1Y)
  "Debt / FCF Ratio 1Y": "Debt / FCF Ratio",
  "Debt / FCF Ratio": "Debt / FCF Ratio",

  // Div frequency final
  "Div.- Frequency": "Div.-Frequency",
  "Div- Frequency": "Div.-Frequency",
  "Div.-Frequency": "Div.-Frequency",

  // FCF per share Schreibweisen
  "Free Cash Flow Per Share 1Y": "Free Cash Flow per Share 1Y",
  "Free Cash Flow per Share 1Y": "Free Cash Flow per Share 1Y",

  // Kurs Open -> final
  "Kurs 4Y (CAGR) Open": "Kurs 4Y (CAGR)",
  "Kurs 4Y (CAGR)": "Kurs 4Y (CAGR)",

  // Vol alt (3 Spalten) -> final Pack
  "Volatilität annualisiert (Std-Abw.) 1Y": "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",
  "Volatilität annualisiert (Std-Abw.) 5Y": "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",
  "Volatilität annualisiert (Std-Abw.) 10Y": "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",
  "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y": "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y",

  // Dividend Growth Years Varianten
  "Dividend Growth Years": "Dividend Growth years",
  "Dividend Growth Years ": "Dividend Growth years",
  "Dividend Growth years": "Dividend Growth years",

  // Net Debt / EBITDA Varianten
  "Net Dept/ EBITDA": "Net Debt / EBITDA Ratio 1Y",
  "Net Dept/ EBITDA Ratio 1Y": "Net Debt / EBITDA Ratio 1Y",
  "Net Debt/ EBITDA Ratio 1Y": "Net Debt / EBITDA Ratio 1Y",
  "Net Debt / EBITDA Ratio 1Y": "Net Debt / EBITDA Ratio 1Y",

  // Interest coverage Varianten
  "Interest Coverage 1Y": "Zinsdeckung 1Y (Interest Coverage)",
  "Zinsdeckung (ICR)": "Zinsdeckung 1Y (Interest Coverage)",
  "Zinsdeckung 1Y (Interest Coverage)": "Zinsdeckung 1Y (Interest Coverage)",
};



function nzGet(m, key){
  const canonical = NUTZEN_HEADER_ALIASES[key] || key;
  return (m?.[canonical] ?? m?.[key] ?? "");
}




function nutzenYearMeta(header){
  if(!header) return null;

  // Vol pack (eine Spalte)
  if(header.startsWith("Volatilität annualisiert")) return { type:"volpack" };

  // 4Y CAGR Spalten (nur diese existieren final)
  if(header === "Revenue 4Y (CAGR)") return { type:"cagr", group:"rev", year:4 };
  if(header === "EPS Growth 4Y (CAGR)") return { type:"cagr", group:"eps", year:4 };
  if(header === "Operating Margin 4Y pp (CAGR)") return { type:"cagr", group:"opm", year:4 };
  if(header === "Dividende (DPS) 4Y (CAGR)") return { type:"cagr", group:"dps", year:4 };
  if(header === "Kurs 4Y (CAGR)") return { type:"cagr", group:"kurs", year:4 };

  return null;
}



function nutzenGetSelectedCagrYear(){
  const sel = document.getElementById("nutzen_cagrYears");
  const y = sel ? Number(sel.value) : NaN;
  return Number.isFinite(y) ? y : 4;
}

function nutzenGetSelectedVolYear(){
  const sel = document.getElementById("nutzen_volYears");
  const y = sel ? Number(sel.value) : NaN;
  return Number.isFinite(y) ? y : 1;
}


function nutzenUpdateYearVisibility(){
  let cagrY = (typeof nutzenGetSelectedCagrYear === "function")
    ? Number(nutzenGetSelectedCagrYear())
    : NaN;

  let volY = (typeof nutzenGetSelectedVolYear === "function")
    ? Number(nutzenGetSelectedVolYear())
    : NaN;

  if(!Number.isFinite(cagrY)){
    const sel = document.getElementById("nutzen_cagrYears");
    if(sel) cagrY = Number(sel.value);
  }

  if(!Number.isFinite(volY)){
  const selV = document.getElementById("nutzen_volYears");
  if(selV) volY = Number(selV.value);
}

  const headRow = document.getElementById("nutzenHeadRow");
  const valRow  = document.getElementById("nutzenValueRow");
  if(!headRow || !valRow) return;

  const headCells = Array.from(headRow.children);
  const valCells  = Array.from(valRow.children);

  for(let i=0;i<NUTZEN_HEADERS.length;i++){
    const th = headCells[i];
    const td = valCells[i];
    if(!th || !td) continue;

    const tNew = th.dataset.yearType;
    const yNew = Number(th.dataset.yearValue);

    if(tNew === "cagr"){
      const show = Number.isFinite(cagrY) ? (yNew === cagrY) : true;
      th.style.display = show ? "" : "none";
      td.style.display = show ? "" : "none";
      continue;
    }
    if(tNew === "vol"){
      const show = Number.isFinite(volY) ? (yNew === volY) : true;
      th.style.display = show ? "" : "none";
      td.style.display = show ? "" : "none";
      continue;
    }

    // optional: altes schema behalten/entfernen
    const isOldCagr = th.dataset.cagrYear && th.dataset.cagrGroup;
    if(isOldCagr){
      const yOld = Number(th.dataset.cagrYear);
      const show = Number.isFinite(cagrY) ? (yOld === cagrY) : true;
      th.style.display = show ? "" : "none";
      td.style.display = show ? "" : "none";
      continue;
    }

    

    th.style.display = "";
    td.style.display = "";
  }
}




// Table initial bauen (Header + eine Value-Row mit 55 Zellen)
function buildNutzenTable(){
  const headRow = document.getElementById("nutzenHeadRow");
  const valRow  = document.getElementById("nutzenValueRow");
  const bigCell = document.getElementById("nutzenBigCell");
  if(!headRow || !valRow) return;

  // colspan sicher setzen
  if(bigCell) bigCell.colSpan = NUTZEN_HEADERS.length;

  headRow.innerHTML = "";
  valRow.innerHTML = "";

  NUTZEN_HEADERS.forEach((h, idx) => {
    const th = document.createElement("th");
    th.textContent = h;
    th.className = "nutzenCell";
    th.dataset.idx = String(idx);

const meta = nutzenYearMeta(h);


if(meta){
  th.dataset.yearType = meta.type;      // "cagr" oder "vol"
  th.dataset.yearGroup = meta.group;    // z.B. "rev" oder "vol"
  th.dataset.yearValue = String(meta.year); // 1/2/3/4/10
}

    headRow.appendChild(th);

    const td = document.createElement("td");
    td.className = "nutzenCell";
    td.dataset.idx = String(idx);
    td.textContent = ""; // leer initial

    td.contentEditable = "true";
    td.spellcheck = false;             // optional
    td.inputMode = "text";             // optional

if(meta){
  td.dataset.yearType  = meta.type;
  td.dataset.yearGroup = meta.group || "";
  td.dataset.yearValue = String(meta.year);
}

    valRow.appendChild(td);
  });
}

// Text in Tokens splitten: Tab (Excel) / ; / Zeilenumbruch
function splitNutzenTokens(raw){
  let s = String(raw ?? "");
  if(!s.trim()) return [];

  s = s.replace(/\r/g, "\n");

  // Wichtig: Bei Excel ist TAB das sichere Trennzeichen.
  // Leere Felder MÜSSEN erhalten bleiben, sonst verrutschen die Spalten!
  if(s.includes("\t")){
    return s.split("\t").map(x => x.trim()); // KEIN filter() !
  }

  // Semikolon-Export: auch hier leere Felder behalten
  if(s.includes(";")){
    return s.split(";").map(x => x.trim()); // KEIN filter() !
  }

  // Fallback: Zeilenweise (hier ignorieren wir echte Leerzeilen)
 // Fallback: Wenn alles in 1 Zeile steht und keine Tabs/; vorhanden sind,
// splitte auf 2+ Spaces (typisch Web-Kopien)
const lines = s.split("\n").map(x => x.trim()).filter(x => x.length>0);

if(lines.length === 1 && /\s{2,}/.test(lines[0])){
  return lines[0].split(/\s{2,}/).map(x => x.trim());
}

// sonst: jede Zeile = 1 Token
return lines;
}



function nutzenGetVisibleIndices(){
  const cagrY = nutzenGetSelectedCagrYear();
  const volY  = nutzenGetSelectedVolYear();

  const idxs = [];
  for(let i=0;i<NUTZEN_HEADERS.length;i++){
    const meta = nutzenYearMeta(NUTZEN_HEADERS[i]);

    if(!meta) { idxs.push(i); continue; }
    if(meta.type === "cagr" && meta.year === cagrY) { idxs.push(i); continue; }
    if(meta.type === "vol"  && meta.year === volY)  { idxs.push(i); continue; }
  }
  return idxs;
}



function nutzenFillValues(tokens){
  const valRow = document.getElementById("nutzenValueRow");
  if(!valRow) return;

  const tds = Array.from(valRow.querySelectorAll("td"));

  // alles erstmal leeren
  for(const td of tds) td.textContent = "";

  const totalCols = tds.length; // 55
  const visibleIdxs = nutzenGetVisibleIndices();

  // Fall A: User liefert exakt 55 Werte -> 1:1
  if(tokens.length >= totalCols){
    for(let i=0;i<totalCols;i++){
      tds[i].textContent = tokens[i] ?? "";
    }
    return;
  }

  // Fall B: User kopiert nur sichtbare Spalten (sehr häufig!)
  // -> Tokens auf sichtbare Indizes mappen, Rest bleibt leer
  for(let j=0;j<visibleIdxs.length;j++){
    const colIndex = visibleIdxs[j];
    tds[colIndex].textContent = tokens[j] ?? "";
  }
}

function nutzenUpdateBigMirror(){
  const ta = document.getElementById("nutzen_big");
  const mirror = document.getElementById("nutzen_bigMirror");
  if(!ta || !mirror) return;
  mirror.textContent = ta.value || "";
}


// UI-Bindings für Nutzen
function bindNutzenUI(){
  if(window._nutzenUIBound) return;
  window._nutzenUIBound = true;
  // 1) Tabelle bauen (einmalig)
  buildNutzenTable();


  
  bindNutzenStressUI();
  bindNutzenOverlayUI();
  bindOverlayActionsUI();
  bindNutzenAutoRerender();

  renderNutzenRolesBox();

  // 4) Parse Button
  const parseBtn = document.getElementById("nutzen_parseBtn");
  if(parseBtn){
    parseBtn.addEventListener("click", () => {
      const raw = document.getElementById("nutzen_big")?.value ?? "";
      const tokens = splitNutzenTokens(raw);
      nutzenFillValues(tokens);
      nutzenUpdateYearVisibility();

      // Rollen + Auto-UI (Stress/Fair/Actions) aktualisieren
      renderNutzenRolesBox();
    });
  }


  // Enter/Return im großen Input: wie "Bestätigen"
const big = document.getElementById("nutzen_big");
if(big && !big.dataset.enterBound){
  big.dataset.enterBound = "1";

  let enterCount = 0;
  let enterTimer = null;

  big.addEventListener("keydown", (e) => {
    if(e.key !== "Enter") return;
    if(e.shiftKey || e.ctrlKey || e.metaKey || e.altKey) return;

    e.preventDefault(); // kein Zeilenumbruch

    // Parse/Verteilen IMMER bei Enter
    const raw = big.value ?? "";
    const tokens = splitNutzenTokens(raw);
    nutzenFillValues(tokens);
    nutzenUpdateYearVisibility();
    renderNutzenRolesBox();

    // Doppel-Enter erkennen
    enterCount++;
    if(enterTimer) clearTimeout(enterTimer);

    enterTimer = setTimeout(() => {
      // Zeitfenster vorbei -> reset
      enterCount = 0;
      enterTimer = null;
    }, 350);

    if(enterCount >= 2){
      // reset sofort, damit es beliebig oft wieder geht
      enterCount = 0;
      if(enterTimer) { clearTimeout(enterTimer); enterTimer = null; }

      if(typeof openNutzenOverlay === "function"){
        openNutzenOverlay();
      }
    }
  });
}


  // 5) Clear Button
  const clrBtn = document.getElementById("nutzen_clearBtn");
  if(clrBtn){
    clrBtn.addEventListener("click", () => {
      const ta2 = document.getElementById("nutzen_big");
      if(ta2) ta2.value = "";
      nutzenUpdateBigMirror();
      nutzenFillValues([]);
      nutzenUpdateYearVisibility();
      renderNutzenRolesBox();
    });
  }

  // 6) CAGR Years Select
  const sel = document.getElementById("nutzen_cagrYears");
  if(sel){
    sel.addEventListener("change", () => {
      nutzenUpdateYearVisibility();
      // optional: wenn du nach Wechsel sofort neu rendern willst:
      // renderNutzenRolesBox();
    });
  }

  const selVol = document.getElementById("nutzen_volYears");
if(selVol){
  selVol.addEventListener("change", () => {
    nutzenUpdateYearVisibility();
    // optional:
    // renderNutzenRolesBox();
  });
}

  // Initial: richtige Sichtbarkeit
  nutzenUpdateYearVisibility();
  nutzenDevCheckDOM();
  nutzenDevCheckTableShape();
  nutzenDevCheckYearMeta();
  nutzenDevCheckRuntime();
}



/* ===============================
   OVERLAY: Rollen / Stress / Range
   =============================== */

function nutzenGetTableMap(){
  // Map: Header -> Zelleninhalt (Text)
  const valRow = document.getElementById("nutzenValueRow");
  if(!valRow) return {};

  const cells = Array.from(valRow.querySelectorAll("td"));
  const map = {};
  for(let i=0;i<NUTZEN_HEADERS.length;i++){
    map[NUTZEN_HEADERS[i]] = (cells[i]?.textContent ?? "").trim();
  }
  return map;
}

function nutzenOverlaySetStress(mode){
  const pill = document.getElementById("nutzenOverlayStressPill");
  const txt  = document.getElementById("nutzenOverlayStressText");
  if(!pill || !txt) return;

  pill.classList.remove("statusGreen","statusYellow","statusRed","statusDarkRed");

  if(mode === "green"){
    pill.classList.add("statusGreen");
    txt.textContent = "Grün (auto)";
  } else if(mode === "yellow"){
    pill.classList.add("statusYellow");
    txt.textContent = "Gelb (auto)";
  } else if(mode === "red"){
    pill.classList.add("statusRed");
    txt.textContent = "Rot (auto)";
  } else if(mode === "darkred"){
    pill.classList.add("statusDarkRed");
    txt.textContent = "Dunkelrot (akut, auto)";
  } else {
    txt.textContent = "– (noch nicht berechnet)";
  }
}



/* ===============================
/* ===============================
   STRESS FLAG (Nutzen + Overlay) – UI only (Sync)
   =============================== */

function nutzenSetStressUI(mode){
  const pill = document.getElementById("nutzenStressPill");
  const txt  = document.getElementById("nutzenStressText");
  if(!pill || !txt) return;

  pill.classList.remove("statusGreen","statusYellow","statusRed","statusDarkRed");

  if(mode === "green"){
    pill.classList.add("statusGreen");
    txt.textContent = "Grün";
  } else if(mode === "yellow"){
    pill.classList.add("statusYellow");
    txt.textContent = "Gelb";
  } else if(mode === "red"){
    pill.classList.add("statusRed");
    txt.textContent = "Rot";
  } else if(mode === "darkred"){
    pill.classList.add("statusDarkRed");
    txt.textContent = "Dunkelrot";
  } else {
    txt.textContent = "–";
  }
}


function setSelectIfHasOption(sel, value){
  if(!sel) return;
  const has = Array.from(sel.options || []).some(o => o.value === value);
  if(has) sel.value = value;
}


function nutzenSyncStress(mode, why){
  // 1) Haupt-UI immer
  nutzenSetStressUI(mode);

  // 2) Overlay-Farbe nur wenn Funktion existiert
  if(typeof nutzenOverlaySetStress === "function"){
    nutzenOverlaySetStress(mode);
  }

  // 3) Selects setzen – nur wenn Element existiert
  const selMain = document.getElementById("nutzenStressSelect");
  setSelectIfHasOption(selMain, mode || "auto");

  const selOv = document.getElementById("nutzenOverlayStressSelect");
  setSelectIfHasOption(selOv, mode || "auto");

  // 4) Why-Text (robust)
  const txt = (why && String(why).trim())
    ? String(why)
    : stressExplainText(mode);

  const whyMain = document.getElementById("nutzenStressWhy");
  if(whyMain) whyMain.textContent = txt;

  const whyOv = document.getElementById("nutzenOverlayStressWhy");
  if(whyOv) whyOv.textContent = txt;
}





function nutzenRenderMainExplanations(ev, bandsRes){
  // 1) Kaufen/Nachkaufen – Logik
  const buyEl = document.getElementById("nutzenBuyLogicExplain");
  if(buyEl){
    buyEl.textContent =
      (bandsRes?.explain && String(bandsRes.explain).trim())
        ? String(bandsRes.explain)
        : "Keine Kauf-Ranges: Fair Value fehlt (oder ist 0).";
    buyEl.style.whiteSpace = "pre-line";
  }



// 2) Stress – Logik (BASE + HEALTH schön formatieren)
// 2) Stress – Logik (BASE + HEALTH schön formatieren)
const stressEl = document.getElementById("nutzenStressLogicExplain");
if(stressEl){
  const whyRaw = (ev?.stress?.why && String(ev.stress.why).trim())
    ? String(ev.stress.why)
    : "";

  if(!whyRaw){
    stressEl.textContent = "Noch keine Stress-Begründung verfügbar.";
    stressEl.style.whiteSpace = "pre-line";
  } else {

    const iconForSeverity = (line) => {
      if(/\bDunkelrot\b/i.test(line)) return "🟥";
      if(/\bRot\b/i.test(line))       return "❌";
      if(/\bGelb\b/i.test(line))      return "⚠️";
      if(/\bGrün\b/i.test(line))      return "✅";
      return "•";
    };

    const iconForHealthLine = (line) => {
      if(/Entlastung:/i.test(line)) return "✅";
      if(/Verstärker:/i.test(line)) return "❌";
      return iconForSeverity(line);
    };

    const out = whyRaw.split("\n").map(l => {
      const line = l.trim();
      if(!line) return "";

      if(line.startsWith("BASE:")){
        return "BASE: " + line.slice(5).trim();
      }

      if(line.startsWith("HEALTH:")){
        const rest = line.slice(7).trim();
        const parts = rest.split("|").map(x => x.trim()).filter(Boolean);
        return [
          "HEALTH:",
          ...parts.map(p => `${iconForHealthLine(p)} ${p}`)
        ].join("\n");
      }

      return `• ${line}`;
    }).join("\n");

    stressEl.textContent = out;
    stressEl.style.whiteSpace = "pre-line";
  }
}



  // 3) Rollen – Base/Health Kurzliste
  const rolesEl = document.getElementById("nutzenRolesLogicExplain");
  if(rolesEl){
    const roles = ev?.roles || {};
    const lines = [];

    for(const roleRaw of (NUTZEN_ROLE_CATALOG || [])){
      const key = normalizeNutzenRoleName(roleRaw) || roleRaw;
      const r = roles[key];
      if(!r?.why?.length) continue;
      if(r.state === "off") continue;
      lines.push(`• ${key}: ${r.why[0]}`);
    }

    rolesEl.textContent = lines.length ? lines.join("\n") : "Keine aktiven Rollen / keine Details.";
    rolesEl.style.whiteSpace = "pre-line";
  }
}








  
function nutzenOverlayFillRangeBase(){
  const tbody = document.getElementById("nutzenOverlayRangeBase");
  if(!tbody) return;

  const ev = nutzenEvaluateAll();
  const m  = ev.map || {};

  const fpEl = document.getElementById("ov_fairPrice");
  const fairManual = fpEl ? nzNum(fpEl.value) : NaN;
  const fairUsed = (Number.isFinite(fairManual) && fairManual > 0) ? fairManual : ev.fair;
const ev2 = { ...ev, fair: fairUsed };

const cpEl = document.getElementById("ov_currentPrice");
const priceManual = cpEl ? nzNum(cpEl.value) : NaN;

// Kurs für Overlay-Render & ev2 überschreiben (damit alles konsistent ist)
const priceUsed = (Number.isFinite(priceManual) && priceManual > 0)
  ? priceManual
  : nzNum(nzGet(m,"Kurs aktuell"));

ev2.map = { ...(ev2.map || {}), "Kurs aktuell": Number.isFinite(priceUsed) ? String(priceUsed) : (ev2.map?.["Kurs aktuell"] || "") };



  // 52W Range robust (Aliases)
  const p52 = nzParse52w(nzGet(m, "52-Week Range"));

  // Vol: erst final Pack, sonst 1Y
  const volPack = nzGet(m, "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y");
  const vol1y    = nzGet(m, "Volatilität annualisiert (Std-Abw.) 1Y");
  const volShow  = volPack || vol1y || "–";

  const baseRows = [
    ["Kurs aktuell", Number.isFinite(priceUsed) ? priceUsed.toFixed(2) : (nzGet(m,"Kurs aktuell") || "–")],
    ["Fairer Preis", (Number.isFinite(fairUsed) ? fairUsed.toFixed(2) : (nzGet(m,"Fairer Preis") || "–"))],
    ["KGV Target",   nzGet(m,"KGV target") || nzGet(m,"KGV Target") || "–"],
    ["KGV (PE Ratio) 1Y", nzGet(m,"KGV (PE Ratio) 1Y") || "–"],
    ["Beta", nzGet(m,"Beta") || "–"],
    ["52W Low",  Number.isFinite(p52.low)  ? nzFmtPrice(p52.low)  : "–"],
    ["52W High", Number.isFinite(p52.high) ? nzFmtPrice(p52.high) : "–"],
    ["Volatilität", volShow],
    ["Stress (Auto)", (ev.stress?.mode || "–").toUpperCase()],
  ];

  // Stress-Farbe sync
  const rawMode = String(ev.stress?.mode || "").toLowerCase();
  const mode =
    (rawMode === "green" || rawMode === "grün") ? "green" :
    (rawMode === "yellow" || rawMode === "gelb") ? "yellow" :
    (rawMode === "red" || rawMode === "rot") ? "red" :
    (rawMode === "darkred" || rawMode === "dunkelrot") ? "darkred" :
    "green";
  nutzenSyncStress(mode, ev.stress?.why || "");


// Kauf-Ranges berechnen + Erklärungen setzen (mit manuellem Fair)
const bandsRes = nutzenComputeBuyBands(ev2);
nutzenRenderMainExplanations(ev2, bandsRes);

  let bandsRows = [];
  let explainTxt = "";

  if(bandsRes.ok){
    const b = bandsRes.bands;

      const price = (mult)=> (mult===Infinity) ? Infinity : (fairUsed * mult);

    const rowBand = (label, lo, hi) => {
      const loP = (lo===0) ? 0 : price(lo);
      const hiP = price(hi);

      const rangeStr =
        (hi === Infinity)
          ? `> ${nzFmtPrice(loP)}`
          : `${nzFmtPrice(loP)} – ${nzFmtPrice(hiP)}`;

      const multStr =
        (hi === Infinity)
          ? `> ${(lo*100).toFixed(0)}% von Fair`
          : `${(lo*100).toFixed(0)}–${(hi*100).toFixed(0)}% von Fair`;

      return [label, `${rangeStr}  (${multStr})`];
    };

    bandsRows = [
      ["— Kauf-Ranges (auto) —", ""],
      rowBand("Nachkaufen (Strong Buy)", b.strongBuy.lo, b.strongBuy.hi),
      rowBand("Kaufen (Buy)",            b.buy.lo,       b.buy.hi),
      rowBand("Halten (Hold)",           b.hold.lo,      b.hold.hi),
      rowBand("Teuer (Wait/Trim)",       b.expensive.lo, b.expensive.hi),
      rowBand("Sehr teuer",              b.veryExp.lo,   b.veryExp.hi),
    ];

    explainTxt = bandsRes.explain;
  } else {
    bandsRows = [
      ["— Kauf-Ranges (auto) —", ""],
      ["Hinweis", "Fair Value fehlt → keine Ranges berechenbar."]
    ];
    explainTxt = bandsRes.explain || "";
  }

  // Render
  const esc = (x)=> String(x).replace(/</g,"&lt;").replace(/>/g,"&gt;");
  const allRows = [...baseRows, ...bandsRows];

  tbody.innerHTML = allRows.map(r => `
    <tr>
      <td>${esc(r[0])}</td>
      <td><b>${esc(r[1])}</b></td>
    </tr>
  `).join("");

  // Erklärungstext (falls du ein Feld dafür hast)
  const explainEl = document.getElementById("nutzenOverlayRangeExplain");
  if(explainEl){
    explainEl.textContent = explainTxt;
  } else if(explainTxt){
    tbody.innerHTML += `
      <tr>
        <td>Begründung</td>
        <td><span class="muted">${esc(explainTxt)}</span></td>
      </tr>
    `;
  }
}










function stressExplainText(mode){
  if(mode === "green")   return "Grün: Sehr stabil – keine Stress-Trigger aktiv.";
  if(mode === "yellow")  return "Gelb: Leichter Stress – einzelne Warnsignale (z.B. höhere Volatilität oder Bewertung) aber noch kein Krisenbild.";
  if(mode === "red")     return "Rot: Hoher Stress – mehrere Warnsignale gleichzeitig (z.B. hoher Drawdown, schwache Cashflows, hohe Verschuldung).";
  if(mode === "darkred") return "Dunkelrot: Krisenmodus – starke finanzielle/marktseitige Risiken (z.B. FCF negativ + hohe Schulden + Kurs nahe Tief).";
  return "Auto (später): Wird anhand deiner Regeln berechnet.";
}










function closeNutzenOverlay(){
  const ov = document.getElementById("nutzenOverlay");
  const bd = document.getElementById("nutzenOverlayBackdrop");
  if(!ov || !bd) return;

  bd.style.display = "none";
  ov.style.display = "none";
  ov.setAttribute("aria-hidden","true");
}


// Wichtig: wird erst gebunden, wenn Nutzen-UI gebunden ist
// -> wir rufen es am Ende von bindNutzenUI() auf


/* ===============================
   ROLLEN-KATALOG (nur UI)
   =============================== */

// Alle Rollen, die du genannt hast (ohne Vergabe-Logik)
const NUTZEN_ROLE_CATALOG = [
  "Dividenden-Aristokrat",
  "Dividenden-Wachstum",
  "Value",
  "Wachstum",
  "Quality",
  "GARP",
  "Turnaround",
  "Zykliker",
  "Spekulation",
  "Krisenfall",
  "Defensiv",
  "Stabil defensiv",
  "Pricing Power",
  "Recurring Revenue / Abo Modell",
  "Balance Sheet Strong",
  "Leveraged / Schuldenlastig",
  "Small Cap",
  "Mid Cap",
  "Large Cap",
  "Mega Cap"
];



// Normalisiert alte/abweichende Rollennamen → neue Katalog-Namen
function normalizeNutzenRoleName(role){
  if(!role) return "";

  const r = String(role).trim();

  // 1) Harte Mappings (alt → neu)
  const map = {
    "Dividenden Aristokrat": "Dividenden-Aristokrat",
    "Dividenden-Aristokrat": "Dividenden-Aristokrat",

    "Dividenden Wachstum": "Dividenden-Wachstum",
    "Dividenden-Wachstum": "Dividenden-Wachstum",

    "High Dividend": null, // entfernt

    "GARP (Wachstum, preis ist nicht teuer)": "GARP",
    "GARP (Wachstum, Preis ist nicht teuer)": "GARP",
    "GARP": "GARP",

    "Kriesenfall": "Krisenfall", // Tippfehler
    "Krisenfall": "Krisenfall",

    "stabil Defensiv": "Stabil defensiv",
    "Stabil defensiv": "Stabil defensiv",

    "Recurring Revenue/ Abo Modell": "Recurring Revenue / Abo Modell",
    "Recurring Revenue/Abo Modell": "Recurring Revenue / Abo Modell",
    "Recurring Revenue / Abo Modell": "Recurring Revenue / Abo Modell",

    "Balance Sheet strong": "Balance Sheet Strong",
    "Balance Sheet Strong": "Balance Sheet Strong",

    "leveraged/ Schuldenlastig": "Leveraged / Schuldenlastig",
    "Leveraged/ Schuldenlastig": "Leveraged / Schuldenlastig",
    "Leveraged / Schuldenlastig": "Leveraged / Schuldenlastig",

    "Small Cap": "Small Cap",
    "Mid Cap": "Mid Cap",
    "Large Cap": "Large Cap",
    "Mega Cap": "Mega Cap",

    "Value": "Value",
    "Wachstum": "Wachstum",
    "Quality": "Quality",
    "Turnaround": "Turnaround",
    "Zykliker": "Zykliker",
    "Spekulation": "Spekulation",
    "Defensiv": "Defensiv",
    "Pricing Power": "Pricing Power",
  };

  if(Object.prototype.hasOwnProperty.call(map, r)){
    return map[r] ?? ""; // null/undefined => entfernen
  }

  // 2) Fallback: leichte "Fuzzy"-Normalisierung (nur wenn nicht im Mapping)
  const lower = r.toLowerCase();

  if(lower.includes("dividenden") && lower.includes("arist")) return "Dividenden-Aristokrat";
  if(lower.includes("dividenden") && lower.includes("wach"))  return "Dividenden-Wachstum";
  if(lower.startsWith("garp")) return "GARP";
  if(lower.includes("krisen") || lower.includes("kriesen")) return "Krisenfall";
  if(lower.includes("stabil") && lower.includes("def")) return "Stabil defensiv";
  if(lower.includes("recurring") || lower.includes("abo")) return "Recurring Revenue / Abo Modell";
  if(lower.includes("balance") && lower.includes("sheet")) return "Balance Sheet Strong";
  if(lower.includes("lever") || lower.includes("schulden")) return "Leveraged / Schuldenlastig";

  // Cap Größen
  if(lower.includes("mega cap")) return "Mega Cap";
  if(lower.includes("large cap")) return "Large Cap";
  if(lower.includes("mid cap")) return "Mid Cap";
  if(lower.includes("small cap")) return "Small Cap";

  // Unbekannt: unverändert zurückgeben (oder "" wenn du hart filtern willst)
  return r;
}


// Hilfsfunktion: normalisiert ein Rollen-Array + filtert alles raus,
// was nicht mehr existiert oder leer ist, und entfernt Duplikate
function normalizeNutzenRolesArray(roles){
  const arr = Array.isArray(roles) ? roles : [];
  const out = [];
  const seen = new Set();

  for(const x of arr){
    const n = normalizeNutzenRoleName(x);
    if(!n) continue;

    // Optional: nur Rollen zulassen, die im Katalog sind
    if(Array.isArray(NUTZEN_ROLE_CATALOG) && !NUTZEN_ROLE_CATALOG.includes(n)) continue;

    if(!seen.has(n)){
      seen.add(n);
      out.push(n);
    }
  }
  return out;
}





function roleBadgeHtml(st){
  if(st === "on")  return `<span class="roleBadge ok">✅ aktiv</span>`;
  if(st === "warn") return `<span class="roleBadge mid">⚠️ aktiv</span>`;
  if(st === "off") return `<span class="roleBadge bad">❌ nicht</span>`;
  return `<span class="roleBadge">… offen</span>`;
}


/* ===============================
   OVERLAY: Fairer Preis / Kaufen / Nachkaufen – UI only
   =============================== */


function ovRenderActionsSummary(){
  const fp = ovGetEl("ov_fairPrice")?.value;
  const cp = ovGetEl("ov_currentPrice")?.value;
  const buy = ovGetEl("ov_buySelect")?.value || "auto";
  const add = ovGetEl("ov_addSelect")?.value || "auto";
  const out = ovGetEl("ov_actionSummary");
  if(!out) return;

  const tBuy = (buy==="auto") ? "Kaufen: Auto" : (buy==="yes" ? "Kaufen: Ja" : buy==="maybe" ? "Kaufen: Vielleicht" : "Kaufen: Nein");
  const tAdd = (add==="auto") ? "Nachkaufen: Auto" : (add==="yes" ? "Nachkaufen: Ja" : add==="maybe" ? "Nachkaufen: Vielleicht" : "Nachkaufen: Nein");

  const tFP = fp ? `Fairer Preis: ${fp}` : "Fairer Preis: –";
  const tCP = cp ? `Kurs: ${cp}` : "Kurs: –";

  out.textContent = `${tFP} | ${tCP} | ${tBuy} | ${tAdd}`;
}




/* =========================================
   1) HELPERS: Parsing / Utilities
   ========================================= */

function nzStr(x){
  const s = (x ?? "").toString().trim();
  if(!s) return "";

  const low = s.toLowerCase();

  // Missing tokens / placeholders
  if(
    low === "n/a" || low === "na" || low === "n.a." ||
    low === "null" || low === "undefined" ||
    low === "none" ||
    low === "k.a." || low === "k.a" ||
    low === "–" || low === "-"
  ){
    return "";
  }

  return s;
}


function nzParseVolPack(raw){
  const s = nzStr(raw);
  if(!s) return { v1: NaN, v5: NaN, v10: NaN };

  const m1  = s.match(/1Y\s*[:=]?\s*([-\d.,]+)\s*%?/i);
  const m5  = s.match(/5Y\s*[:=]?\s*([-\d.,]+)\s*%?/i);
  const m10 = s.match(/10Y\s*[:=]?\s*([-\d.,]+)\s*%?/i);

  const nums = s.match(/[-]?\d+(?:[.,]\d+)?/g) || [];

  const v1  = m1  ? nzPct(m1[1])  : (nums[0] ? nzPct(nums[0]) : NaN);
  const v5  = m5  ? nzPct(m5[1])  : (nums[1] ? nzPct(nums[1]) : NaN);
  const v10 = m10 ? nzPct(m10[1]) : (nums[2] ? nzPct(nums[2]) : NaN);

  return { v1, v5, v10 };
}



function nzNum(raw){
  // akzeptiert "1.234,56", "1234.56", "12%", "–", "-", "n/a", "na"
  // akzeptiert Suffix: k/K/t (=Tausend), m/M (=Millionen), b/B (=Billionen=1e9), T (=Trillionen=1e12)
  let s = nzStr(raw);
  if(!s) return NaN;

  const s0  = String(s).trim();
  const low = s0.toLowerCase();

  // Missing tokens / not available
  if(
    low === "–" || low === "-" ||
    low === "n/a" || low === "na" || low === "n.a." ||
    low === "null" || low === "none" ||
    low === "k.a." || low === "k.a"
  ){
    return NaN;
  }

  // remove spaces + percent sign (pct handled separately by nzPct)
  s = s0.replace(/\s/g, "").replace("%", "");

  // DE number format handling
  if(s.includes(",") && s.includes(".")){
    s = s.replace(/\./g, "").replace(",", ".");
  } else if(s.includes(",")){
    s = s.replace(",", ".");
  }

  // Suffix shortcuts (case-sensitive)
  // k/K/t = 1e3, m/M = 1e6, b/B = 1e9, T = 1e12
  const m = s.match(/^(-?\d+(?:\.\d+)?)([kKmMbBtT])$/);
  if(m){
    const v = Number(m[1]);
    if(!Number.isFinite(v)) return NaN;

    const u = m[2];
    const mul =
      (u === "k" || u === "K" || u === "t") ? 1e3 :
      (u === "m" || u === "M") ? 1e6 :
      (u === "b" || u === "B") ? 1e9 :
      (u === "T")              ? 1e12 :
      NaN;

    return Number.isFinite(mul) ? v * mul : NaN;
  }

  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}




function nzPct(raw){
  // "12,3%" => 12.3 (Prozentpunkte)
  const n = nzNum(raw);
  return Number.isFinite(n) ? n : NaN;
}

function nzYesNo(raw){
  const s = nzStr(raw).toLowerCase();
  if(["ja","yes","true","1","y"].includes(s)) return true;
  if(["nein","no","false","0","n"].includes(s)) return false;
  return null; // unbekannt
}

function nzRangePct(raw){
  // "52 Week Range" kann sein: "100 - 200" oder "100–200" oder "100 / 200"
  const s = nzStr(raw);
  if(!s) return NaN;
  const parts = s.split(/[-–\/]/).map(x=>nzNum(x)).filter(n=>Number.isFinite(n));
  if(parts.length < 2) return NaN;
  const lo = Math.min(parts[0], parts[1]);
  const hi = Math.max(parts[0], parts[1]);
  if(lo <= 0) return NaN;
  return (hi - lo) / lo; // z.B. 0.50 = 50%
}


function nzClamp(x, a, b){ return Math.max(a, Math.min(b, x)); }



// FCF Conversion Rechner (robust):
// bevorzugt: FCF / Net Income
// fallback: (OCF + CapEx) / Net Income  (CapEx ist meist negativ)
// Output: ratio (0..1..), plus Quelle/Erklärung
function nzCalcFcfConversion(m){
  const ni   = nzNum(nzGet(m, "Net Income 1Y", "Net Income Y1", "Net Income 1Y"));
  if(!Number.isFinite(ni) || ni === 0) return { ratio: NaN, src: "missing_ni" };

  const fcfRaw = nzNum(nzGet(m, "FCF 1Y"));
  const ocf    = nzNum(nzGet(m, "Operating Cash Flow 1Y"));
  const capex  = nzNum(nzGet(m, "Capital Expenditures 1Y"));

  // 1) Wenn FCF vorhanden -> FCF/NI
  if(Number.isFinite(fcfRaw)){
    return { ratio: fcfRaw / ni, src: "fcf_over_ni" };
  }

  // 2) Fallback: FCF ≈ OCF + CapEx  (CapEx typischerweise negativ)
  if(Number.isFinite(ocf) && Number.isFinite(capex)){
    const fcfDerived = ocf + capex;
    return { ratio: fcfDerived / ni, src: "ocf_plus_capex_over_ni" };
  }

  return { ratio: NaN, src: "missing_inputs" };
}

// nur fürs UI/Labels
function nzFmtPct01(x){
  if(!Number.isFinite(x)) return "–";
  return (x * 100).toFixed(0) + "%";
}




function nzSelectedCagrYear(){
  const sel = document.getElementById("nutzen_cagrYears");
  const y = sel ? Number(sel.value) : 4;
  return [1,2,3,4].includes(y) ? y : 4;
}

/* =========================================
   2) CORE: Evaluate (Roles + Stress + Fair + Actions)
   ========================================= */

function nutzenComputeFairPrice(m){
  const fairGiven = nzNum(nzGet(m, "Fairer Preis"));
  if(Number.isFinite(fairGiven) && fairGiven > 0) return fairGiven;

  const eps = nzNum(nzGet(m, "EPS 1Y (Diluted, FY)"));
  const peT = nzNum(nzGet(m, "KGV target")); // <- wichtig: canonical
  if(Number.isFinite(eps) && eps > 0 && Number.isFinite(peT) && peT > 0){
    return eps * peT;
  }
  return NaN;
}


function nutzenComputeActions(m, fair){
  const current = nzNum(nzGet(m, "Kurs aktuell"));
  if(!Number.isFinite(current) || current <= 0 || !Number.isFinite(fair) || fair <= 0){
    return { buy:"auto", add:"auto", why:["Zu wenig Daten (Kurs/Fair fehlen)."] };
  }
  const discount = (fair - current) / fair; // 0.20 => 20% unter fair

  // simple, robuste Heuristik
  // buy: >=15% unter fair => Ja, 5-15% => Vielleicht, sonst Nein
  let buy = "no";
  if(discount >= 0.15) buy = "yes";
  else if(discount >= 0.05) buy = "maybe";

  // add (nachkaufen): tieferer Discount
  let add = "no";
  if(discount >= 0.25) add = "yes";
  else if(discount >= 0.12) add = "maybe";

  return {
    buy, add,
    why: [
      `Fair ≈ ${fair.toFixed(2)} | Kurs ≈ ${current.toFixed(2)} | Discount ≈ ${(discount*100).toFixed(1)}%`
    ]
  };
}


function nzParse52w(raw){
  // liefert {low, high} oder {low:NaN, high:NaN}
  const s = nzStr(raw);
  if(!s) return { low: NaN, high: NaN };

  const parts = s.split(/\s*[-–\/]\s*/).map(x => x.trim());
  if(parts.length < 2) return { low: NaN, high: NaN };

  const a = nzNum(parts[0]);
  const b = nzNum(parts[1]);
  if(!Number.isFinite(a) || !Number.isFinite(b)) return { low: NaN, high: NaN };

  return { low: Math.min(a, b), high: Math.max(a, b) };
}

function nzFmtPrice(x){
  return Number.isFinite(x) ? x.toFixed(2) : "–";
}

/**
 * Kauf-Bands:
 * - Baseline: Strong Buy <= 0.75*Fair, Buy 0.75–0.90, Hold 0.90–1.10, Teuer 1.10–1.25, Sehr teuer >1.25
 * - Dynamisch: bei Stress/Vol werden die Buy-Zonen "strenger" (mehr Sicherheitsmarge)
 */
function nutzenComputeBuyBands(ev){
  const fair = ev?.fair;
  if(!Number.isFinite(fair) || fair <= 0){
    return {
      ok:false,
      bands:null,
      explain:"Keine Kauf-Ranges: Fair Value fehlt (oder ist 0)."
    };
  }

  const vol = nzPct(nzGet(ev.map, "Volatilität annualisiert (Std-Abw.) 1Y")); 
// dank Aliases klappt auch 1Y/5Y/10Y-Pack, wenn du es so mappst
  const stress = (ev?.stress?.mode || "green"); // green/yellow/red

  // ---- Baseline Multiples ----
  let strongBuyMax = 0.75;
  let buyMax       = 0.90;
  let holdMax      = 1.10;
  let expensiveMax = 1.25;

  // ---- Risiko-Anpassung (warum):
  // Höhere Unsicherheit (gelb/rot) oder hohe Volatilität -> größere Sicherheitsmarge -> Buy-Zonen tiefer.
  // Niedrige Unsicherheit -> leicht weniger strenge Marge möglich.
  let shift = 0; // wie stark wir nach unten verschieben

  if(stress === "red") shift += 0.08;
  else if(stress === "yellow") shift += 0.04;

  if(Number.isFinite(vol)){
    if(vol >= 60) shift += 0.06;
    else if(vol >= 45) shift += 0.04;
    else if(vol <= 30 && stress === "green") shift -= 0.02; // stabiler => minimal weniger streng
  }

  // Clamp: nicht zu extrem
  shift = nzClamp(shift, -0.03, 0.18);

  strongBuyMax = nzClamp(strongBuyMax - shift, 0.55, 0.85);
  buyMax       = nzClamp(buyMax       - shift, strongBuyMax + 0.05, 0.98);

  // Hold/Expensive lassen wir bewusst stabil:
  // Warum: Über Fair werden die Signale ohnehin schwächer, zu viel Dynamik macht's unruhig.
  // Optional könntest du bei rot auch holdMax leicht senken – ich lasse es erstmal simpel/robust.

  const bands = {
    strongBuy: { lo: 0,              hi: strongBuyMax },
    buy:       { lo: strongBuyMax,   hi: buyMax },
    hold:      { lo: buyMax,         hi: holdMax },
    expensive: { lo: holdMax,        hi: expensiveMax },
    veryExp:   { lo: expensiveMax,   hi: Infinity }
  };

  const explain =
    `Baseline (Fair-Multiples): Nachkaufen ≤0,75×, Kaufen 0,75–0,90×, Halten 0,90–1,10×, Teuer 1,10–1,25×.\n` +
    `Anpassung: shift=${(shift*100).toFixed(0)}%-Pkt (Stress=${stress}${Number.isFinite(vol)?`, Vol=${vol.toFixed(1)}%`:""}). ` +
    `Mehr Risiko ⇒ größere Sicherheitsmarge ⇒ Buy-Zonen tiefer.`;

  return { ok:true, bands, explain };
}



/* ===========================
   Extra helpers (neu)
   =========================== */

function nzLower(raw){ return nzStr(raw).toLowerCase(); }

function nzIsRegularDividend(freqRaw){
  // akzeptiert: "quarterly", "quartalsweise", "monthly", "jährlich" etc.
  const s = nzLower(freqRaw);
  if(!s) return false;
  // "stabil regelmäßig" ist nicht messbar -> wir nehmen typische Muster
  return (
    s.includes("quart") || s.includes("quarter") ||
    s.includes("monat") || s.includes("month") ||
    s.includes("halb")  || s.includes("semi")  ||
    s.includes("jähr")  || s.includes("year")  ||
    s.includes("annual")
  );
}

function nzIsPeUsable(pe){
  return Number.isFinite(pe) && pe > 0 && pe < 2000; // sehr grob, aber verhindert Quatsch
}







/* =========================================
   STRESS / KRISENFALL (ersetzt deine Funktion)
   ========================================= */

function nutzenComputeStress(m){
  // Severity: green=0, yellow=1, red=2, darkred=3
  const sevName = ["green","yellow","red","darkred"];
  const sevLabel = { green:"Grün", yellow:"Gelb", red:"Rot", darkred:"Dunkelrot" };
  const triggers = [];

  // --- robust getter: versucht mehrere Header-Varianten ---
  const get = (...keys) => {
   for(const k of keys){
    const v = nzGet(m, k);
    if(v !== undefined && v !== null && String(v).trim() !== "") return v;
    }
    return "";
  };

  // --- values (nach deinen HEADERS) ---
  const quick   = nzNum(get("Quick Ratio 1Y"));
  const currentR= nzNum(get("Current Ratio 1Y"));

  const cashST  = nzNum(get("Cash & Short-Term Investments 1Y"));

  const icr     = nzNum(get("Zinsdeckung 1Y (Interest Coverage)", "Zinsdeckung (ICR)"));
  const nde     = nzNum(get("Net Debt / EBITDA Ratio 1Y", "Net Dept/ EBITDA", "Net Dept/ EBITDA Ratio 1Y"));
  const dcf     = nzNum(get("Debt / FCF Ratio 1Y", "Debt/ FCF", "Debt/ FCF Ratio"));

  const ocf     = nzNum(get("Operating Cash Flow 1Y"));
  const capex   = nzNum(get("Capital Expenditures 1Y"));
  const fcf     = nzNum(get("FCF 1Y"));

  const fcfPos  = nzYesNo(get("FCF positiv (Ja/Nein)", "FCF Positiv (ja/nein)", "FCF Positiv (Ja/Nein)"));
  const fcfMgn  = nzPct(get("FCF-Marge 1Y", "FCF-Margin 1Y", "FCF-Margin"));
  const fcfConvRaw = nzNum(get("FCF Conversion 1Y", "FCF Conversion"));

  const netIncomePos = nzYesNo(get("Net income positiv (Ja/Nein)", "Net income positiv (ja/nein)"));
  const opm1y   = nzPct(get("Operating Margin 1Y"));
  const pm1y    = nzPct(get("Profit Margin 1Y"));
  const opmCagr4= nzPct(get("Operating Margin pp 4Y (CAGR)"));

  const vol1y   = nzPct(get("Volatilität annualisiert (Std-Abw.) 1Y"));
  const beta    = nzNum(get("Beta"));
  const sharesCh= nzPct(get("Shares Change (YoY)"));

  const roic    = nzPct(get("ROIC 1Y", "ROIC"));
  const roce    = nzPct(get("ROCE 1Y", "ROCE"));

  const price   = nzNum(get("Kurs aktuell"));
  const r52     = nzParse52w(get("52-Week Range", "52 Week Range"));
  const rangePct= nzRangePct(get("52-Week Range", "52 Week Range"));

  // --- helpers ---
  const clampSev = (x)=> Math.max(0, Math.min(3, x));
  const worsenOnce = (sev, why)=>{
    const n = clampSev(sev + 1);
    if(n !== sev) triggers.push("Verstärker: " + why);
    return n;
  };
  const improveOnce = (sev, why)=>{
    const n = clampSev(sev - 1);
    if(n !== sev) triggers.push("Entlastung: " + why);
    return n;
  };

  // normalize conversion: akzeptiere 0.6 oder 60 als "60%"
  const fcfConv = Number.isFinite(fcfConvRaw)
    ? (fcfConvRaw > 1.5 ? fcfConvRaw / 100 : fcfConvRaw)
    : NaN;

  const marketVolHigh = Number.isFinite(vol1y) && vol1y >= 45;
  const marketBetaHigh= Number.isFinite(beta) && beta >= 1.5;
  const near52Low = (Number.isFinite(price) && Number.isFinite(r52.low) && r52.low > 0)
    ? (price <= r52.low * 1.15)
    : false;

  // =========================================================
  // Block A — Liquidität
  // =========================================================
  let A = 1; // default = gelb (konservativ bei fehlenden Daten)
  const quickKnown = Number.isFinite(quick);
  const currKnown  = Number.isFinite(currentR);

  if(!quickKnown && !currKnown){
    A = 1;
    triggers.push("A Liquidität: zu wenig Daten (Quick/Current fehlt)");
  } else {
    // Dunkelrot
    if( (quickKnown && quick < 0.8) || (currKnown && currentR < 1.0) ) {
      A = 3;
    }
    // Rot
    else if( (quickKnown && quick < 1.0) || (currKnown && currentR < 1.2) ){
      A = 2;
    }
    // Gelb
    else if(
      (quickKnown && quick >= 1.0 && quick < 1.2) ||
      (currKnown  && currentR >= 1.2 && currentR < 1.5)
    ){
      A = 1;
    }
    // Grün (beide Bedingungen)
    else if( (quickKnown && quick >= 1.2) && (currKnown && currentR >= 1.5) ){
      A = 0;
    } else {
      // Mischfall: z.B. Quick gut, Current knapp darunter => gelb
      A = 1;
    }
  }

  triggers.push(`Block A (Liquidität): ${sevLabel[sevName[A]]}` +
    (quickKnown ? ` | Quick=${quick}` : "") +
    (currKnown ? ` | Current=${currentR}` : "")
  );

  // Cash&STI Verstärker: wenn sehr niedrig und schon gelb/rot/dunkelrot => 1 Stufe schlechter
  // (ohne Verhältnis-Daten nehmen wir konservativ: <=0 oder NaN -> kein Verstärker; nur wenn klar sehr klein)
  if(Number.isFinite(cashST) && cashST <= 0 && A >= 1){
    A = worsenOnce(A, "Cash & Short-Term Investments sehr niedrig");
  }

  // =========================================================
  // Block B — Zinslast & Leverage  (FIX: Debt/FCF nicht mehr alleine Dunkelrot)
  // =========================================================
  let B = 1; // default gelb bei fehlenden Daten
  const icrKnown = Number.isFinite(icr);
  const ndeKnown = Number.isFinite(nde);
  const dcfKnown = Number.isFinite(dcf);

  if(!icrKnown && !ndeKnown && !dcfKnown){
    B = 1;
    triggers.push("B Zins/Leverage: zu wenig Daten (ICR/NDE/DCF fehlt)");
  } else {

    // 1) Primär: ICR + NetDebt/EBITDA (sauber & stabil)
    if( (icrKnown && icr < 1) || (ndeKnown && nde >= 6) ){
      B = 3; // Dunkelrot
    }
    else if(
      (icrKnown && icr >= 1 && icr < 2) ||
      (ndeKnown && nde >= 4 && nde < 6)
    ){
      B = 2; // Rot
    }
    else if(
      (icrKnown && icr >= 2 && icr < 3) ||
      (ndeKnown && nde >= 3 && nde < 4)
    ){
      B = 1; // Gelb
    }
    else if(
      (icrKnown ? icr >= 3 : true) &&
      (ndeKnown ? nde < 3 : true)
    ){
      B = 0; // Grün
    } else {
      B = 1;
    }

    // 2) Sekundär: Debt/FCF nur als Verstärker (max +1), nie alleine Dunkelrot
    const fcfOk = (fcfPos === true) || (Number.isFinite(fcf) && fcf > 0);
    if(dcfKnown && fcfOk){
      if(dcf >= 50 && B < 3) { B = Math.min(3, B + 1); triggers.push("Verstärker B: Debt/FCF sehr hoch (≥50)"); }
      else if(dcf >= 25 && B < 2) { B = Math.min(2, B + 1); triggers.push("Verstärker B: Debt/FCF hoch (≥25)"); }
      else if(dcf >= 15 && B < 1) { B = Math.min(1, B + 1); triggers.push("Verstärker B: Debt/FCF erhöht (≥15)"); }
    }
  }

  triggers.push(`Block B (Zins/Leverage): ${sevLabel[sevName[B]]}` +
    (icrKnown ? ` | ICR=${icr}` : "") +
    (ndeKnown ? ` | NetDebt/EBITDA=${nde}` : "") +
    (dcfKnown ? ` | Debt/FCF=${dcf}` : "")
  );


  // =========================================================
  // Block C — Cashflow/FCF
  // =========================================================
  let C = 1;

  const ocfKnown = Number.isFinite(ocf);
  const fcfKnown = Number.isFinite(fcf);
  const fcfMgnKnown = Number.isFinite(fcfMgn);
  const fcfConvKnown = Number.isFinite(fcfConv);

  const fcfYes = (fcfPos === true);
  const fcfNo  = (fcfPos === false);

  // Dunkelrot
  const cDark =
    (ocfKnown && fcfKnown && ocf <= 0 && fcf < 0) ||
    (fcfNo && fcfMgnKnown && fcfMgn < 0);

  if(cDark){
    C = 3;
  } else {
    // Rot
    if( (fcfKnown && fcf < 0) || fcfNo ){
      C = 2;
    }
    // Grün
    else if( (ocfKnown && ocf > 0) && (fcfKnown && fcf > 0) && fcfYes ){
      C = 0;
    }
    // Gelb: FCF >=0 aber Conversion schwach oder Marge sehr niedrig
    else {
      const convWeak = fcfConvKnown && (fcfConv < 0.5);
      const mgnVeryLow = fcfMgnKnown && (fcfMgn >= 0 && fcfMgn < 5);
      if( (fcfKnown && fcf >= 0) && (convWeak || mgnVeryLow) ){
        C = 1;
      } else {
        // Default bei Mischdaten: gelb
        C = 1;
      }
    }
  }

  // CapEx-Erklärung/Entschärfung: wenn FCF<0 aber OCF stark positiv und CapEx der Haupttreiber,
  // dann eher Gelb statt Rot (nicht wenn Dunkelrot!)
  if(C === 2 && fcfKnown && fcf < 0 && ocfKnown && ocf > 0 && Number.isFinite(capex)){
    // typischer CapEx ist negativ
    const capexAbs = Math.abs(capex);
    const ocfAbs   = Math.abs(ocf);
    if(capexAbs > 0 && ocfAbs > 0 && capexAbs >= 0.7 * ocfAbs){
      C = 1;
      triggers.push("C Hinweis: FCF negativ wirkt capex-getrieben (OCF positiv, CapEx hoch) → Gelb statt Rot");
    }
  }

  triggers.push(`Block C (Cashflow/FCF): ${sevLabel[sevName[C]]}` +
    (ocfKnown ? ` | OCF=${ocf}` : "") +
    (fcfKnown ? ` | FCF=${fcf}` : "") +
    (fcfPos!==null ? ` | FCFPos=${fcfPos ? "Ja":"Nein"}` : "")
  );

  // =========================================================
  // Block D — Profitabilität
  // =========================================================
  let D = 1;

  const niYes = (netIncomePos === true);
  const niNo  = (netIncomePos === false);

  const opmKnown = Number.isFinite(opm1y);
  const pmKnown  = Number.isFinite(pm1y);
  const opmTrendKnown = Number.isFinite(opmCagr4);

  // Dunkelrot
  if( niNo && ( (opmKnown && opm1y <= 0) || (pmKnown && pm1y <= 0) ) ){
    D = 3;
  }
  // Rot
  else if( niNo || (opmKnown && opm1y <= 0) || (pmKnown && pm1y <= 0) ){
    D = 2;
  }
  // Grün (mit Bonus-Info)
  else if( niYes && (opmKnown && opm1y > 0) && (pmKnown && pm1y > 0) ){
    D = 0;
    if(opmTrendKnown && opmCagr4 >= 0){
      triggers.push("D Bonus: Operating Margin Trend (4Y pp CAGR) ≥ 0");
    }
  }
  // Gelb: Margen positiv, aber Trend schlecht
  else {
    if(opmTrendKnown && opmCagr4 < 0){
      D = 1;
    } else {
      D = 1;
    }
  }

  triggers.push(`Block D (Profitabilität): ${sevLabel[sevName[D]]}` +
    (netIncomePos!==null ? ` | NIPos=${netIncomePos ? "Ja":"Nein"}` : "") +
    (opmKnown ? ` | OPM=${opm1y}%` : "") +
    (pmKnown ? ` | PM=${pm1y}%` : "")
  );

  // =========================================================
  // Gesamt (Health)
  // =========================================================
  const blocks = { A, B, C, D };

  const darkCount = [A,B,C,D].filter(x => x === 3).length;
  const redCount  = [A,B,C,D].filter(x => x === 2).length;
  const yelCount  = [A,B,C,D].filter(x => x === 1).length;

  const marketStress = marketVolHigh || near52Low;

  let baseMode = "green";

  // 1) Dunkelrot
  if(A === 3 || B === 3){
    baseMode = "darkred";
  } else if(redCount >= 2 && marketStress){
    baseMode = "darkred";
  }
  // 2) Rot
  else if(redCount >= 2){
    baseMode = "red";
  } else if(redCount >= 1 && yelCount >= 2){
    baseMode = "red";
  }
  // 3) Gelb
  else if(yelCount >= 2){
    baseMode = "yellow";
  } else if(redCount === 1){
    baseMode = "yellow";
  }
  // 4) Grün
  else {
    baseMode = "green";
  }

  let baseSev = baseMode === "green" ? 0 : baseMode === "yellow" ? 1 : baseMode === "red" ? 2 : 3;

  triggers.push(`Gesamt (Basis): ${sevLabel[baseMode]} | Rot=${redCount}, Gelb=${yelCount}, Dunkelrot=${darkCount}` +
    (marketStress ? " | Marktstress bestätigt (Vol hoch oder nahe 52W Low)" : "")
  );

  // =========================================================
  // Verstärker / Entlastung (±1 Stufe max. einmal)
  // =========================================================
  let finalSev = baseSev;

  // Verschlechtert: nur wenn Gelb oder Rot-nah (=> baseSev >= 1) und nicht schon Dunkelrot
  if(finalSev >= 1 && finalSev < 3){
    const dilutionHigh = Number.isFinite(sharesCh) && sharesCh >= 5; // 5%+ YoY als "stark"
    const betaVolHigh  = marketBetaHigh && marketVolHigh;
    const rangeVeryWide= Number.isFinite(rangePct) && rangePct >= 1.0; // >=100% Spanne

    if(dilutionHigh || betaVolHigh || rangeVeryWide){
      const why = [
        dilutionHigh ? `Shares Change YoY hoch (${sharesCh.toFixed(1)}%)` : null,
        betaVolHigh  ? `Beta & Vol hoch (Beta=${beta}, Vol=${vol1y}%)` : null,
        rangeVeryWide? `52W Range sehr breit (${(rangePct*100).toFixed(0)}%)` : null
      ].filter(Boolean).join(" | ");
      finalSev = worsenOnce(finalSev, why);
    }
  }

  // Verbessert: nur wenn NICHT Rot/Dunkelrot
  if(finalSev <= 1){
    const qualityStrong = (
      (Number.isFinite(roic) && roic >= 15) ||
      (Number.isFinite(roce) && roce >= 15)
    );
    const icrStrong = Number.isFinite(icr) && icr >= 5;

    if(qualityStrong && fcfPos === true && icrStrong){
      finalSev = improveOnce(finalSev, "Sehr starke Qualität (ROIC/ROCE hoch) + FCF positiv + ICR ≥ 5");
    }
  }


  const mode = sevName[finalSev];
  triggers.push(`Gesamt (Final): ${sevLabel[mode]}`);

  const baseLine =
    `BASE: Gesamt = ${sevLabel[mode]} (A=${sevLabel[sevName[A]]}, B=${sevLabel[sevName[B]]}, C=${sevLabel[sevName[C]]}, D=${sevLabel[sevName[D]]})`;

  const healthLine =
    `HEALTH: ${(triggers && triggers.length) ? triggers.join(" | ") : "keine Trigger"}`;

  const why = baseLine + "\n" + healthLine;

  return { mode, triggers, blocks, why };


}
 







/* =========================
   ROLES ENGINE (Phase 5)
   ========================= */

function roleChk(label, ok, missing=false){
  return { label, ok: !!ok, missing: !!missing };
}

function roleBuildWhy(checks){
  return (checks || []).map(c => {
    const icon = c.missing ? "…" : (c.ok ? "✅" : "❌");
    return `${icon} ${c.label}`;
  });
}

function roleHealthLabel(pct, known){
  if(known <= 0) return "Health: – (zu wenig Daten)";
  if(pct >= 0.75) return "Health: stark";
  if(pct >= 0.60) return "Health: ok";
  return "Health: schwach";
}

function roleEval(baseChecks, healthChecks, healthMinPct=0.60){
  const baseOk = (baseChecks || []).every(c => c.missing ? true : !!c.ok);

  const known = (healthChecks || []).filter(c => !c.missing);
  const okCnt = known.filter(c => !!c.ok).length;
  const max   = known.length;
  const pct   = max > 0 ? okCnt / max : 0;

  let state = "off";
if(baseOk){
  if(max === 0) state = "on";     // <- statt "warn"
  else state = (pct >= healthMinPct) ? "on" : "warn";
}
  return { state, baseOk, okCnt, max, pct };
}

function roleSet(out, role, baseChecks, healthChecks, healthMinPct=0.60){
  const ev = roleEval(baseChecks, healthChecks, healthMinPct);
  const header =
    `BASE: ${ev.baseOk ? "✅ ok" : "❌ nicht"} | ` +
    `HEALTH: ${ev.max ? `${ev.okCnt}/${ev.max}` : "–"} (${roleHealthLabel(ev.pct, ev.max)})`;

  out[role] = {
    state: ev.state,
    why: [
      header,
      ...roleBuildWhy(baseChecks).map(x => "BASE: " + x),
      ...roleBuildWhy(healthChecks).map(x => "HEALTH: " + x),
    ]
  };
}

function scoreChecks(checks){
  const known = checks.filter(c => !c.missing);
  const okCnt = known.filter(c => c.ok).length;
  return { okCnt, knownCnt: known.length };
}






function buildNutzenCtx(m){
  // Vol-Pack einmal parsen
  const volPack = nzParseVolPack(nzGet(m, "Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y"));

  const ctx = {
    // Wachstum / Profit
    revCagr4: nzPct(nzGet(m, "Revenue 4Y (CAGR)")),
    epsCagr4: nzPct(nzGet(m, "EPS Growth 4Y (CAGR)")),
    revYoy:   nzPct(nzGet(m, "Revenue Growth 1Y (YoY)")),

    opm1y:    nzPct(nzGet(m, "Operating Margin 1Y")),
    opmCagr4: nzPct(nzGet(m, "Operating Margin 4Y pp (CAGR)")),

    // Margen
    profitMargin1y: nzPct(nzGet(m, "Profit Margin 1Y")),
    grossMargin1y:  nzPct(nzGet(m, "Gross Margin 1Y")),
    pm1y: nzPct(nzGet(m, "Profit Margin 1Y")),
    gm1y: nzPct(nzGet(m, "Gross Margin 1Y")),

    // EBITDA
    ebitda: nzNum(nzGet(m, "EBITDA 1Y")),
    ebitdaMargin: nzPct(nzGet(m, "EBITDA Margin 1Y")),

    // Dividende
    dpsCagr4: nzPct(nzGet(m, "Dividende (DPS) 4Y (CAGR)")),
    divYears: nzNum(nzGet(m, "Dividend Growth years")),
    divYield: nzPct(nzGet(m, "Div.-Rendite aktuell (%)")),
    payout: nzPct(nzGet(m, "Payout Ratio 1Y")),
    fcfPayout: nzPct(nzGet(m, "FCF-Payout")),
    divFreq: nzStr(nzGet(m, "Div.-Frequency")),
    divGrowthTxt: nzLower(nzGet(m, "Dividend Growth")),

    // Bewertung / Preise
    pe:    nzNum(nzGet(m, "KGV (PE Ratio) 1Y")),
    fair:  nutzenComputeFairPrice(m),
    price: nzNum(nzGet(m, "Kurs aktuell")),
    fcfYield: nzPct(nzGet(m, "FCF Yield 1Y")),

    // Cashflow / FCF
    ocf:       nzNum(nzGet(m, "Operating Cash Flow 1Y")),
    capex:     nzNum(nzGet(m, "Capital Expenditures 1Y")),
    fcf:       nzNum(nzGet(m, "FCF 1Y")),
    fcfConv:   nzPct(nzGet(m, "FCF Conversion")),
    fcfMargin: nzPct(nzGet(m, "FCF-Marge 1Y")),
    fcfPos:    nzYesNo(nzGet(m, "FCF positiv (Ja/Nein)")),

    // Cash
    cash: nzNum(nzGet(m, "Cash & Short-Term Investments 1Y")),

    // Profit flags
    netIncomePos: nzYesNo(nzGet(m, "Net Income positiv (Ja/Nein)")),

    // Risiko (aus Pack)
    beta: nzNum(nzGet(m, "Beta")),
    vol:  volPack.v1,
    vol5y: volPack.v5,
    vol10y: volPack.v10,
    rangePct: nzRangePct(nzGet(m, "52-Week Range")),

    // 52W Low/High optional (nur wenn du sie irgendwoher hast)
    range52Low:  nzNum(nzGet(m, "52W Low")),
    range52High: nzNum(nzGet(m, "52W High")),

    // Debt / Liquidity / Coverage
    debtFcf: nzNum(nzGet(m, "Debt / FCF Ratio")),
    netDebtEbitda: nzNum(nzGet(m, "Net Debt / EBITDA Ratio 1Y")),
    icr: nzNum(nzGet(m, "Zinsdeckung 1Y (Interest Coverage)")),
    quick: nzNum(nzGet(m, "Quick Ratio 1Y")),
    currentRatio: nzNum(nzGet(m, "Current Ratio 1Y")),
    current: nzNum(nzGet(m, "Current Ratio 1Y")), // Alias

    // Qualität
    roic: nzPct(nzGet(m, "ROIC 1Y")),
    roce: nzPct(nzGet(m, "ROCE 1Y")),

    // Größe/Shares
    mcap: nzNum(nzGet(m, "Marktkapitalisierung")),
    sharesChangeYoY: nzPct(nzGet(m, "Shares Change (YoY)")),
    sharesChg: nzPct(nzGet(m, "Shares Change (YoY)")),

    // Engine hooks
    has: (x) => Number.isFinite(x),
    opt: (x, pred) => {
      if(!Number.isFinite(x)) return { ok:true, missing:true };
      return { ok: !!pred(x), missing:false };
    },
    chk: roleChk,
  };

  // Derived: FCF Conversion berechnen (wenn Spalte fehlt)
// Achtung: ratio ist 0..1 (z.B. 0.65 = 65%)
const conv = nzCalcFcfConversion(m);
ctx.fcfConvCalc = conv.ratio;
ctx.fcfConvCalcSrc = conv.src;

  // Derived
  ctx.peUsable = nzIsPeUsable(ctx.pe);

  ctx.mos85 = (Number.isFinite(ctx.fair) && ctx.fair>0 && Number.isFinite(ctx.price) && ctx.price>0)
    ? (ctx.price <= 0.85 * ctx.fair) : false;

  ctx.mos90 = (Number.isFinite(ctx.fair) && ctx.fair>0 && Number.isFinite(ctx.price) && ctx.price>0)
    ? (ctx.price <= 0.90 * ctx.fair) : false;

  ctx.regularDiv = nzIsRegularDividend(ctx.divFreq);

  ctx.divGrowthTxtMissing = !nzStr(nzGet(m, "Dividend Growth"));
  ctx.divGrowthLooksBad = (() => {
    const t = nzLower(nzGet(m, "Dividend Growth"));
    if(!t) return false;
    return t.includes("cut") || t.includes("kürz") || t.includes("negativ") || t.includes("stop") || t.includes("suspend");
  })();

  ctx.peg = (() => {
    const pe = ctx.pe;
    const g  = ctx.epsCagr4;
    if(!Number.isFinite(pe) || pe <= 0) return NaN;
    if(!Number.isFinite(g) || g <= 0) return NaN;
    return pe / g;
  })();

  return ctx;
}






/* =========================================
   ROLES (ersetzt deine Funktion)
   ========================================= */

function nutzenComputeRoles(m){
  /* =========================
     A) Kleine Check-Engine
     ========================= */
  function chk(label, ok, missing=false){ return { label, ok: !!ok, missing: !!missing }; }

  function buildWhy(checks){
    return (checks || []).map(c => {
      const icon = c.missing ? "…" : (c.ok ? "✅" : "❌");
      return `${icon} ${c.label}`;
    });
  }

  function healthLabel(pct, known){
    if(known <= 0) return "Health: – (zu wenig Daten)";
    if(pct >= 0.75) return "Health: stark";
    if(pct >= 0.60) return "Health: ok";
    return "Health: schwach";
  }

  function evalRole(baseChecks, healthChecks, healthMinPct=0.60){
    const baseOk = (baseChecks || []).every(c => c.missing ? true : !!c.ok);

    const known = (healthChecks || []).filter(c => !c.missing);
    const okCnt = known.filter(c => !!c.ok).length;
    const max   = known.length;
    const pct   = max > 0 ? okCnt / max : 0;

let state = "off";
if(baseOk){
  if(max === 0) state = "on";     // <- statt "warn"
  else state = (pct >= healthMinPct) ? "on" : "warn";
}
    return { state, baseOk, okCnt, max, pct };
  }

  function setRole(out, role, baseChecks, healthChecks, healthMinPct=0.60){
    const ev = evalRole(baseChecks, healthChecks, healthMinPct);
    const header =
      `BASE: ${ev.baseOk ? "✅ ok" : "❌ nicht"} | ` +
      `HEALTH: ${ev.max ? `${ev.okCnt}/${ev.max}` : "–"} (${healthLabel(ev.pct, ev.max)})`;

    out[role] = {
      state: ev.state, // on | warn | off
      why: [
        header,
        ...buildWhy(baseChecks).map(x => "BASE: " + x),
        ...buildWhy(healthChecks).map(x => "HEALTH: " + x),
      ]
    };
  }

  function missingNum(x){ return !Number.isFinite(x); }
  function missingYesNo(x){ return (x !== true && x !== false); }

  /* =========================
     B) Context (alles 1x parsen)
     ========================= */
  const ctx = buildNutzenCtx(m);



  /* =========================
     C) Derived helpers (MoS etc.)
     ========================= */
  ctx.peUsable = nzIsPeUsable(ctx.pe);

ctx.mos85 = (Number.isFinite(ctx.fair) && ctx.fair>0 && Number.isFinite(ctx.price) && ctx.price>0)
  ? (ctx.price <= 0.85 * ctx.fair) : false;

ctx.mos90 = (Number.isFinite(ctx.fair) && ctx.fair>0 && Number.isFinite(ctx.price) && ctx.price>0)
  ? (ctx.price <= 0.90 * ctx.fair) : false;

  ctx.regularDiv = nzIsRegularDividend(ctx.divFreq);

  ctx.divGrowthLooksBad =
    ctx.divGrowthTxt.includes("cut") ||
    ctx.divGrowthTxt.includes("kürz") ||
    ctx.divGrowthTxt.includes("negativ") ||
    ctx.divGrowthTxt.includes("stop");

  /* =========================
     D) ROLE RULES – HIER baust du nach und nach aus
     =========================
     Jede Rolle: base(ctx)->checks, health(ctx)->checks, healthMin
     Wenn du noch keine Regeln hast: lass base/health weg.
     ========================= */





// =====================
// TURNAROUND – nach deinen Regeln (Gate A/B/C + Risky Flag)
// benötigt in ctx: netIncomePos, fcfPos, opm1y, pm1y, opmPpCagr1/2/3/4, ebitda, ebitdaMargin,
//                  fcfConv, revYoy, revCagr1/2/3, epsFY, epsCagr1/2 (optional),
//                  icr, quick, current, netDebtEbitda, debtFcf, cash,
//                  beta, vol, range52Low (optional), range52High (optional), price (optional)
//
// Hinweis: ctx.current = Current Ratio (wie wir’s zuletzt getrennt haben), ctx.price = Kurs aktuell
// Wenn du noch keinen 52W low/high im ctx hast, ist "nearLow" einfach missing.

function buildTurnaroundRole(ctx){
  // ---------- Helpers ----------
  const has = ctx.has || ((x)=>Number.isFinite(x));
  const chk = ctx.chk || ((label, ok, missing=false)=>({label, ok:!!ok, missing:!!missing}));

  // "optional" check: fehlt => missing=true und ok=true (blockt nicht)
  const opt = ctx.opt || ((x, pred)=>{
    if(!Number.isFinite(x)) return { ok:true, missing:true };
    return { ok: !!pred(x), missing:false };
  });

  function countOk(checks){
    const known = checks.filter(c => !c.missing);
    const okCnt = known.filter(c => c.ok).length;
    return { okCnt, knownCnt: known.length };
  }

  function anyOk(checks){
    const known = checks.filter(c => !c.missing);
    if(known.length === 0) return { ok:false, missing:true };
    return { ok: known.some(c=>c.ok), missing:false };
  }

  // ---------- Inputs ----------
  const netIncomePos = ctx.netIncomePos;         // true/false/null
  const fcfPos       = ctx.fcfPos;               // true/false/null

  const opm1y = ctx.opm1y;                       // %
  const pm1y  = ctx.pm1y ?? ctx.profitMargin1y;  // %
  const icr   = ctx.icr;                         // number
  const quick = ctx.quick;                       // number
  const currentRatio = ctx.currentRatio; // Current Ratio
  const netDebtEbitda = ctx.netDebtEbitda;       // number
  const debtFcf = ctx.debtFcf;                   // number
  const cash = ctx.cash;                         // number

  const opmPp1 = ctx.opmPpCagr1 ?? ctx.opmPpCagr1y ?? ctx.opmPp1; // %p.a. (pp-CAGR)
  const opmPp2 = ctx.opmPpCagr2 ?? ctx.opmPpCagr2y ?? ctx.opmPp2;
  const opmPp3 = ctx.opmPpCagr3 ?? ctx.opmPpCagr3y ?? ctx.opmPp3;
  const opmPp4 = ctx.opmPpCagr4 ?? ctx.opmCagr4; // falls du opmCagr4 als pp-CAGR nutzt

  const ebitda = ctx.ebitda;
  const ebitdaMargin = ctx.ebitdaMargin;

  const convRatio = ctx.fcfConvCalc; // 0..1 (z.B. 0.65)

  const revYoy  = ctx.revYoy;
  const revCagr1 = ctx.revCagr1 ?? ctx.revCagr1y;
  const revCagr2 = ctx.revCagr2 ?? ctx.revCagr2y;
  const revCagr3 = ctx.revCagr3 ?? ctx.revCagr3y;

  const epsFY = ctx.epsFY ?? ctx.eps1y ?? ctx.eps; // EPS 1Y (FY)
  const epsCagr1 = ctx.epsCagr1 ?? ctx.epsGrowthCagr1;
  const epsCagr2 = ctx.epsCagr2 ?? ctx.epsGrowthCagr2;

  const beta = ctx.beta;
  const vol  = ctx.vol;

  // 52W low/high optional
  const low52 = ctx.range52Low;
  const price = ctx.price; // Kurs aktuell (wenn du es im ctx hast)
  const nearLow = (has(low52) && has(price) && low52 > 0) ? (price <= low52 * 1.10) : null;

  // =========================================================
  // Gate A — „Vorher schwach / Problemfall“ (mind. 1 Treffer)
  // =========================================================
  const gateA_checks = [
    chk(`Problem: Net Income negativ`, netIncomePos === false, netIncomePos === null),
    chk(`Problem: Operating Margin < 0`, has(opm1y) ? opm1y < 0 : false, !has(opm1y)),
    chk(`Problem: Profit Margin < 0`, has(pm1y) ? pm1y < 0 : false, !has(pm1y)),
    chk(`Problem: FCF negativ`, fcfPos === false, fcfPos === null),
    chk(`Problem: Zinsdeckung < 1.5`, has(icr) ? icr < 1.5 : false, !has(icr)),
    chk(`Problem: Current Ratio < 1.0`, has(currentRatio) ? currentRatio < 1.0 : false, !has(currentRatio)),
  ];
  const gateA_any = anyOk(gateA_checks);

  // ======================================================
  // Gate B — „Messbare Verbesserung“ (mind. 2 Treffer)
  // ======================================================
  // Margin improves: irgendein pp-CAGR > 0
  const opmImproveKnown = [opmPp1, opmPp2, opmPp3, opmPp4].some(has);
  const opmImproveOk = [opmPp1, opmPp2, opmPp3, opmPp4].some(v => has(v) && v > 0);

  // EBITDA improves: EBITDA > 0 UND EBITDA-Marge positiv (proxy)
  const ebitdaOk = (has(ebitda) && ebitda > 0) && (has(ebitdaMargin) ? (ebitdaMargin > 0) : true);
  const ebitdaMissing = !(has(ebitda) || has(ebitdaMargin));

  // FCF conversion (nur wenn NI nicht negativ)
const convRelevant = (netIncomePos !== false);
const convOk = convRelevant && Number.isFinite(convRatio) && convRatio >= 0.60;

  // Revenue improving: YoY>0 oder RevCAGR1>0; optional stärker: 2Y/3Y>0
  const revOk =
    (has(revYoy) && revYoy > 0) ||
    (has(revCagr1) && revCagr1 > 0) ||
    (has(revCagr2) && revCagr2 > 0) ||
    (has(revCagr3) && revCagr3 > 0);

  const revMissing = !(has(revYoy) || has(revCagr1) || has(revCagr2) || has(revCagr3));

  // EPS: EPS>0 oder EPS-CAGR(1/2)>0 (wenn vorhanden)
  const epsOk =
    (has(epsFY) && epsFY > 0) ||
    (has(epsCagr1) && epsCagr1 > 0) ||
    (has(epsCagr2) && epsCagr2 > 0);

  const epsMissing = !(has(epsFY) || has(epsCagr1) || has(epsCagr2));

  const gateB_checks = [
    chk(`Verbesserung: OPM pp-CAGR > 0 (1–4Y)`, opmImproveOk, !opmImproveKnown),
    chk(`Verbesserung: EBITDA > 0 & EBITDA-Marge positiv`, ebitdaOk, ebitdaMissing),
    chk(`Verbesserung: Net Income positiv (Flip)`, netIncomePos === true, netIncomePos === null),
    chk(`Verbesserung: FCF positiv (Flip)`, fcfPos === true, fcfPos === null),
    chk(
  `Verbesserung: FCF Conversion ≥ 60% (aktuell: ${nzFmtPct01(convRatio)})`,
  convOk,
  !convRelevant || !Number.isFinite(convRatio)
),
    chk(`Verbesserung: Revenue > 0 (YoY oder CAGR)`, revOk, revMissing),
    chk(`Verbesserung: EPS > 0 oder EPS-CAGR > 0`, epsOk, epsMissing),
  ];
  const gateB_cnt = countOk(gateB_checks);

  // ============================================================
  // Gate C — „Nicht kurz vor Umkippen“ (mind. 2 Mindest-Sicherheiten)
  // ============================================================
  const debtFcfOk = (has(debtFcf) && debtFcf <= 8);
  const debtFcfMissing = !has(debtFcf);
  const debtFcfAutoBad = !fcfPos || fcfPos === false; // wenn FCF negativ/unknown => nicht ok (nach deiner Regel)

  const gateC_checks = [
    chk(`Stabilität: Zinsdeckung ≥ 2`, has(icr) ? icr >= 2 : false, !has(icr)),
    chk(`Stabilität: Quick ≥ 1 ODER Current ≥ 1.2`, (has(quick) && quick >= 1) || (has(currentRatio) && currentRatio >= 1.2), !(has(quick) || has(currentRatio))),
    chk(`Stabilität: NetDebt/EBITDA ≤ 4`, has(netDebtEbitda) ? netDebtEbitda <= 4 : false, !has(netDebtEbitda)),
    chk(`Stabilität: Debt/FCF ≤ 8 (nur wenn FCF positiv)`, (!debtFcfAutoBad) && debtFcfOk, debtFcfMissing || debtFcfAutoBad),
    chk(`Stabilität: Cash vorhanden (>0)`, has(cash) ? cash > 0 : false, !has(cash)),
  ];
  const gateC_cnt = countOk(gateC_checks);

  // =========================
  // Warnflaggen → Risky
  // =========================
  const risky_checks = [
    chk(`Risky: Zinsdeckung < 1`, has(icr) ? icr < 1 : false, !has(icr)),
    chk(`Risky: NetDebt/EBITDA > 6`, has(netDebtEbitda) ? netDebtEbitda > 6 : false, !has(netDebtEbitda)),
    chk(`Risky: Current Ratio < 0.9`, has(currentRatio) ? currentRatio < 0.9 : false, !has(currentRatio)),
    chk(`Risky: Vol ≥ 60%`, has(vol) ? vol >= 60 : false, !has(vol)),
    chk(`Risky: Beta ≥ 2`, has(beta) ? beta >= 2 : false, !has(beta)),
    chk(`Risky: Kurs nahe 52W Low (≤ +10%)`, (nearLow === true), nearLow === null),
  ];
  const riskyAny = risky_checks.filter(c=>!c.missing).some(c=>c.ok);

  // =========================
  // Final Decision
  // =========================
  const gateA_ok = (gateA_any.missing ? false : gateA_any.ok);
  const gateB_ok = (gateB_cnt.okCnt >= 2);
  const gateC_ok = (gateC_cnt.okCnt >= 2);

  const isTurnaround = gateA_ok && gateB_ok && gateC_ok;

  // Output: Base/Health so wie dein Role-System es will
  // Base = Gates (A/B/C), Health = Warnflaggen + Details
  const base = [
    chk(`Gate A: mind. 1 Schwäche`, gateA_ok, gateA_any.missing),
    chk(`Gate B: mind. 2 Verbesserungen (aktuell: ${gateB_cnt.okCnt}/${gateB_cnt.knownCnt})`, gateB_ok, gateB_cnt.knownCnt===0),
    chk(`Gate C: mind. 2 Stabilitäten (aktuell: ${gateC_cnt.okCnt}/${gateC_cnt.knownCnt})`, gateC_ok, gateC_cnt.knownCnt===0),
  ];

  const health = [
    ...gateA_checks.map(x => ({...x, label:`A: ${x.label}`})),
    ...gateB_checks.map(x => ({...x, label:`B: ${x.label}`})),
    ...gateC_checks.map(x => ({...x, label:`C: ${x.label}`})),
    ...risky_checks.map(x => ({...x, label:`⚠️ ${x.label}`})),
    chk(`Turnaround Risk-Flag`, isTurnaround ? !riskyAny : false, !isTurnaround), // wenn Turnaround true und riskyAny true => health fail
  ];

  return {
    isTurnaround,
    risky: isTurnaround && riskyAny,
    base,
    health,
    note: isTurnaround ? (riskyAny ? "Risky" : "OK") : "OFF"
  };
}



const ROLE_RULES = {
  "Dividenden-Aristokrat": {
    minPct: 0.60,
    base: (ctx) => [
      ctx.chk(`Dividend Growth Years ≥ 25`, ctx.has(ctx.divYears) && ctx.divYears >= 25, !ctx.has(ctx.divYears)),
      ctx.chk(`Dividende regelmäßig`, ctx.regularDiv === true, ctx.regularDiv === null),
      ctx.chk(`Net Income positiv`, ctx.netIncomePos === true, ctx.netIncomePos === null),
      ctx.chk(`FCF positiv`, ctx.fcfPos === true, ctx.fcfPos === null),
    ],
    health: (ctx) => [
      ctx.chk(`DPS 4Y CAGR > 0%`, ctx.opt(ctx.dpsCagr4, v => v > 0)),
      ctx.chk(`Payout 30–70%`, ctx.opt(ctx.payout, v => v >= 30 && v <= 70)),
      ctx.chk(`FCF-Payout ≤ 80%`, ctx.opt(ctx.fcfPayout, v => v <= 80)),
      ctx.chk(`NetDebt/EBITDA < 3`, ctx.opt(ctx.netDebtEbitda, v => v < 3)),
      ctx.chk(`ICR ≥ 3`, ctx.opt(ctx.icr, v => v >= 3)),
      ctx.chk(`Beta ≤ 1.2`, ctx.opt(ctx.beta, v => v <= 1.2)),
    ]
  },

  "Dividenden-Wachstum": {
    minPct: 0.60,
    base: (ctx) => [
      ctx.chk(`Dividend Growth Years ≥ 5`, ctx.has(ctx.divYears) && ctx.divYears >= 5, !ctx.has(ctx.divYears)),
      ctx.chk(`DPS 4Y CAGR ≥ 5%`, ctx.has(ctx.dpsCagr4) && ctx.dpsCagr4 >= 5, !ctx.has(ctx.dpsCagr4)),
      ctx.chk(`Keine Kürzung (Text)`, ctx.divGrowthLooksBad === false, ctx.divGrowthTxtMissing),
      ctx.chk(`Net Income positiv`, ctx.netIncomePos === true, ctx.netIncomePos === null),
      ctx.chk(`FCF positiv`, ctx.fcfPos === true, ctx.fcfPos === null),
    ],
    health: (ctx) => [
      ctx.chk(`Payout ≤ 70%`, ctx.opt(ctx.payout, v => v <= 70)),
      ctx.chk(`FCF-Payout ≤ 70%`, ctx.opt(ctx.fcfPayout, v => v <= 70)),
      ctx.chk(`Revenue 4Y CAGR ≥ 3%`, ctx.opt(ctx.revCagr4, v => v >= 3)),
      ctx.chk(`EPS 4Y CAGR ≥ 5%`, ctx.opt(ctx.epsCagr4, v => v >= 5)),
      ctx.chk(`NetDebt/EBITDA ≤ 3.5`, ctx.opt(ctx.netDebtEbitda, v => v <= 3.5)),
      ctx.chk(`ICR ≥ 3`, ctx.opt(ctx.icr, v => v >= 3)),
    ]
  },

  "Value": {
    minPct: 0.60,
    base: (ctx) => [
      ctx.chk(`Billig: PE≤18 ODER MOS ODER FCF-Yield≥5`, (ctx.peUsable && ctx.pe <= 18) || ctx.mos85 || (ctx.has(ctx.fcfYield) && ctx.fcfYield >= 5), false),
      ctx.chk(`Net Income positiv`, ctx.netIncomePos === true, ctx.netIncomePos === null),
      ctx.chk(`FCF positiv`, ctx.fcfPos === true, ctx.fcfPos === null),
    ],
    health: (ctx) => [
      ctx.chk(`ROIC/ROCE ≥ 10%`, (ctx.has(ctx.roic)&&ctx.roic>=10) || (ctx.has(ctx.roce)&&ctx.roce>=10), !(ctx.has(ctx.roic)||ctx.has(ctx.roce))),
      ctx.chk(`NetDebt/EBITDA < 3`, ctx.opt(ctx.netDebtEbitda, v => v < 3)),
      ctx.chk(`Debt/FCF < 10`, ctx.opt(ctx.debtFcf, v => v < 10)),
      ctx.chk(`OPM > 0%`, ctx.opt(ctx.opm1y, v => v > 0)),
    ]
  },

  "Wachstum": {
    minPct: 0.60,
    base: (ctx) => [
      ctx.chk(`Revenue 4Y CAGR ≥ 10%`, ctx.has(ctx.revCagr4) && ctx.revCagr4 >= 10, !ctx.has(ctx.revCagr4)),
      ctx.chk(`EPS 4Y CAGR ≥ 12%`, ctx.has(ctx.epsCagr4) && ctx.epsCagr4 >= 12, !ctx.has(ctx.epsCagr4)),
      ctx.chk(`FCF positiv`, ctx.fcfPos === true, ctx.fcfPos === null),
    ],
    health: (ctx) => [
      ctx.chk(`OPM > 0%`, ctx.opt(ctx.opm1y, v => v > 0)),
      ctx.chk(`FCF-Marge ≥ 5%`, ctx.opt(ctx.fcfMargin, v => v >= 5)),
      ctx.chk(`ROIC/ROCE ≥ 10%`, (ctx.has(ctx.roic)&&ctx.roic>=10) || (ctx.has(ctx.roce)&&ctx.roce>=10), !(ctx.has(ctx.roic)||ctx.has(ctx.roce))),
      ctx.chk(`PE nicht absurd (≤45 oder fehlend)`, (!ctx.peUsable) || (ctx.pe <= 45), false),
    ]
  },

  "Quality": {
    minPct: 0.65,
    base: (ctx) => [
      ctx.chk(`ROIC ≥ 12%`, ctx.has(ctx.roic) && ctx.roic >= 12, !ctx.has(ctx.roic)),
      ctx.chk(`Net Income positiv`, ctx.netIncomePos === true, ctx.netIncomePos === null),
      ctx.chk(`FCF positiv`, ctx.fcfPos === true, ctx.fcfPos === null),
    ],
    health: (ctx) => [
      ctx.chk(`ROCE ≥ 12%`, ctx.opt(ctx.roce, v => v >= 12)),
      ctx.chk(`OPM ≥ 15%`, ctx.opt(ctx.opm1y, v => v >= 15)),
      ctx.chk(`OPM Trend ≥ 0 (4Y pp CAGR)`, ctx.opt(ctx.opmCagr4, v => v >= 0)),
      ctx.chk(`FCF-Marge ≥ 10%`, ctx.opt(ctx.fcfMargin, v => v >= 10)),
      ctx.chk(`NetDebt/EBITDA ≤ 3`, ctx.opt(ctx.netDebtEbitda, v => v <= 3)),
      ctx.chk(`ICR ≥ 5`, ctx.opt(ctx.icr, v => v >= 5)),
      ctx.chk(`Beta ≤ 1.2`, ctx.opt(ctx.beta, v => v <= 1.2)),
    ]
  },

  "GARP": {
    minPct: 0.60,
    base: (ctx) => [
      ctx.chk(`Revenue 4Y CAGR ≥ 8%`, ctx.has(ctx.revCagr4) && ctx.revCagr4 >= 8, !ctx.has(ctx.revCagr4)),
      ctx.chk(`EPS 4Y CAGR ≥ 10%`, ctx.has(ctx.epsCagr4) && ctx.epsCagr4 >= 10, !ctx.has(ctx.epsCagr4)),
      // Proxy für PEG: PEG ≈ PE / EPS-CAGR
      ctx.chk(`Preis ok: PE≤30 ODER PEG≤2 (Proxy) ODER MOS≤0.9`, (ctx.peUsable && ctx.pe <= 30) || (ctx.has(ctx.peg) && ctx.peg <= 2) || ctx.mos90, false),
    ],
    health: (ctx) => [
      ctx.chk(`OPM ≥ 10%`, ctx.opt(ctx.opm1y, v => v >= 10)),
      ctx.chk(`ROIC/ROCE ≥ 10%`, (ctx.has(ctx.roic)&&ctx.roic>=10) || (ctx.has(ctx.roce)&&ctx.roce>=10), !(ctx.has(ctx.roic)||ctx.has(ctx.roce))),
      ctx.chk(`FCF positiv`, ctx.fcfPos === true, ctx.fcfPos === null),
      ctx.chk(`NetDebt/EBITDA ≤ 3.5`, ctx.opt(ctx.netDebtEbitda, v => v <= 3.5)),
      ctx.chk(`ICR ≥ 4`, ctx.opt(ctx.icr, v => v >= 4)),
    ]
  },

   "Turnaround": {
     minPct: 0.50,
     base:  (ctx) => buildTurnaroundRole(ctx).base,
     health:(ctx) => buildTurnaroundRole(ctx).health,
   },
  
  "Zykliker": {
    minPct: 0.50,
    base: (ctx) => {
      const sig = [
        ctx.chk(`Volatilität 5Y/10Y hoch`, (ctx.opt(ctx.vol5y, v=>v>=35).ok) || (ctx.opt(ctx.vol10y, v=>v>=35).ok),
          (!ctx.has(ctx.vol5y) && !ctx.has(ctx.vol10y))),
        ctx.chk(`Beta hoch`, ctx.opt(ctx.beta, v=>v>=1.2), !ctx.has(ctx.beta)),
        ctx.chk(`52W-Range breit`, ctx.opt(ctx.rangePct, v=>v>=0.8), !ctx.has(ctx.rangePct)),
        ctx.chk(`Marge dünn/schwankungsanfällig (Proxy)`, ctx.opt(ctx.opm1y, v=>v>0 && v<12), !ctx.has(ctx.opm1y)),
        ctx.chk(`FCF/NetIncome nicht stabil (Proxy)`, (ctx.netIncomePos === false) || (ctx.fcfPos === false),
          (ctx.netIncomePos===null && ctx.fcfPos===null)),
        ctx.chk(`Leverage erhöht (Debt/FCF oder NDE)`, (ctx.opt(ctx.debtFcf, v=>v>=10).ok) || (ctx.opt(ctx.netDebtEbitda, v=>v>=3).ok),
          (!ctx.has(ctx.debtFcf) && !ctx.has(ctx.netDebtEbitda))),
      ];
      const sc = scoreChecks(sig);
      return [
        ctx.chk(`Base-Score ≥ 3 (aktuell: ${sc.okCnt}/${sc.knownCnt})`, sc.knownCnt ? sc.okCnt >= 3 : false, sc.knownCnt === 0),
      ];
    },
    health: (ctx) => {
      const h = [
        ctx.chk(`Cash hoch ODER Quick ≥ 1 ODER Current ≥ 1.5`, 
          (ctx.opt(ctx.cash, v=>v>0).ok) || (ctx.opt(ctx.quick, v=>v>=1).ok) || (ctx.opt(ctx.currentRatio, v=>v>=1.5).ok),
          (!ctx.has(ctx.cash) && !ctx.has(ctx.quick) && !ctx.has(ctx.current))),
        ctx.chk(`Interest Coverage > 3 (besser > 5)`, ctx.opt(ctx.icr, v=>v>3), !ctx.has(ctx.icr)),
        ctx.chk(`NetDebt/EBITDA moderat (≤3)`, ctx.opt(ctx.netDebtEbitda, v=>v<=3), !ctx.has(ctx.netDebtEbitda)),
        ctx.chk(`OCF positiv`, ctx.opt(ctx.ocf, v=>v>0), !ctx.has(ctx.ocf)),
        ctx.chk(`CapEx flexibel/FCF nicht dauerhaft negativ (Proxy)`, (ctx.fcfPos !== false) || ctx.opt(ctx.fcf, v=>v>=0), (!ctx.has(ctx.fcf) && ctx.fcfPos===null)),
        ctx.chk(`ROIC/ROCE ordentlich`, (ctx.opt(ctx.roic, v=>v>=8).ok) || (ctx.opt(ctx.roce, v=>v>=8).ok),
          (!ctx.has(ctx.roic) && !ctx.has(ctx.roce))),
      ];
      const sc = scoreChecks(h);
      return [
        ...h,
        ctx.chk(`Health-Score ≥ 4 (aktuell: ${sc.okCnt}/${sc.knownCnt})`, sc.knownCnt ? sc.okCnt >= 4 : true, sc.knownCnt === 0),
      ];
    }
  },

   "Spekulation": {
    minPct: 0.50,
    base: (ctx) => {
      const sig = [
        ctx.chk(`Beta hoch (≥1.8)`, ctx.opt(ctx.beta, v=>v>=1.8), !ctx.has(ctx.beta)),
        ctx.chk(`Volatilität 1Y hoch (≥45%)`, ctx.opt(ctx.vol, v=>v>=45), !ctx.has(ctx.vol)),
        ctx.chk(`52W-Range sehr breit (≥120%)`, ctx.opt(ctx.rangePct, v=>v>=1.2), !ctx.has(ctx.rangePct)),
        ctx.chk(`Net Income negativ`, ctx.netIncomePos === false, ctx.netIncomePos===null),
        ctx.chk(`FCF negativ oder FCF-Marge sehr niedrig`, (ctx.fcfPos === false) || (ctx.opt(ctx.fcfMargin, v=>v<3).ok),
          (ctx.fcfPos===null && !ctx.has(ctx.fcfMargin))),
        ctx.chk(`Bewertung extrem (PE sehr hoch/negativ/unbrauchbar)`, (!ctx.peUsable) || (ctx.has(ctx.pe) && ctx.pe>=45),
          (!ctx.has(ctx.pe) && ctx.peUsable===false)),
        ctx.chk(`Leverage/Refi-Risiko (Debt/FCF hoch oder ICR niedrig)`, (ctx.opt(ctx.debtFcf, v=>v>=12).ok) || (ctx.opt(ctx.icr, v=>v<3).ok),
          (!ctx.has(ctx.debtFcf) && !ctx.has(ctx.icr))),
      ];
      const sc = scoreChecks(sig);
      return [
        ctx.chk(`Base-Score ≥ 3 (aktuell: ${sc.okCnt}/${sc.knownCnt})`, sc.knownCnt ? sc.okCnt >= 3 : false, sc.knownCnt === 0),
      ];
    },
    health: (ctx) => [
      ctx.chk(`Hinweis: Spekulation = Screening (kein Qualitätslabel)`, true, false),
    ]
  },


  "Krisenfall": {
    minPct: 0.50,
    base: (ctx) => {
      const acute = [
        ctx.chk(`ICR < 1`, ctx.opt(ctx.icr, v=>v<1), !ctx.has(ctx.icr)),
        ctx.chk(`OCF ≤ 0`, ctx.opt(ctx.ocf, v=>v<=0), !ctx.has(ctx.ocf)),
        ctx.chk(`FCF negativ oder FCF positiv = Nein`, (ctx.fcfPos === false) || ctx.opt(ctx.fcf, v=>v<0), (ctx.fcfPos===null && !ctx.has(ctx.fcf))),
        ctx.chk(`Quick < 1 oder Current < 1`, (ctx.opt(ctx.quick, v=>v<1).ok) || (ctx.opt(ctx.currentRatio, v=>v<1).ok),
          (!ctx.has(ctx.quick) && !ctx.has(ctx.currentRatio))),
      ];

      const otherBlocks = [
        ctx.chk(`Leverage hoch (NDE ≥ 5 oder Debt/FCF ≥ 15)`, (ctx.opt(ctx.netDebtEbitda, v=>v>=5).ok) || (ctx.opt(ctx.debtFcf, v=>v>=15).ok),
          (!ctx.has(ctx.netDebtEbitda) && !ctx.has(ctx.debtFcf))),
        ctx.chk(`Profitabilität negativ (OPM ≤ 0 oder Profit Margin ≤ 0)`, (ctx.opt(ctx.opm1y, v=>v<=0).ok) || (ctx.opt(ctx.pm1y, v=>v<=0).ok),
          (!ctx.has(ctx.opm1y) && !ctx.has(ctx.pm1y))),
        ctx.chk(`Umsatztrend schwach (Revenue YoY < 0)`, ctx.opt(ctx.revYoy, v=>v<0), !ctx.has(ctx.revYoy)),
        ctx.chk(`Marktstress (Vol 1Y hoch oder nahe 52W Low Proxy: Range sehr breit)`, (ctx.opt(ctx.vol, v=>v>=60).ok) || (ctx.opt(ctx.rangePct, v=>v>=0.8).ok),
          (!ctx.has(ctx.vol) && !ctx.has(ctx.rangePct))),
      ];

      const a = scoreChecks(acute);
      const o = scoreChecks(otherBlocks);

      // PDF-Idee: 1 akuter Trigger + mindestens 1 weiterer Block schwach
      const ok = (a.knownCnt ? a.okCnt >= 1 : false) && (o.knownCnt ? o.okCnt >= 1 : false);

      return [
        ctx.chk(`Akut-Trigger ≥1 UND weiterer Block schwach`, ok,
          (a.knownCnt===0 && o.knownCnt===0)),
      ];
    },
    health: (ctx) => [
      // Health (managbar vs existenziell) kannst du später fein machen – PDF beschreibt die Dimensionen.
      ctx.chk(`Health-Hinweis: Cash + Quick/Current ok = eher “managbar”`, true, false),
    ]
  },


  "Defensiv": {
    minPct: 0.60,
    base: (ctx)=>[
      ctx.chk(`Beta ≤ 1.0`, ctx.has(ctx.beta) && ctx.beta <= 1.0, !ctx.has(ctx.beta)),
    ],
    health:(ctx)=>[
      ctx.chk(`Vol ≤ 30%`, ctx.opt(ctx.vol, v => v <= 30)),
      ctx.chk(`52W Range ≤ 60%`, ctx.opt(ctx.rangePct, v => v <= 0.6)),
    ]
  },

  "Stabil defensiv": {
    minPct: 0.65,
    base: (ctx)=>[
      ctx.chk(`Beta ≤ 0.9`, ctx.opt(ctx.beta, v => v <= 0.9), !ctx.has(ctx.beta)),
      ctx.chk(`Vol 5Y/10Y moderat/niedrig (Proxy ≤ 30%)`, 
        (ctx.opt(ctx.vol5y, v=>v<=30).ok) || (ctx.opt(ctx.vol10y, v=>v<=30).ok),
        (!ctx.has(ctx.vol5y) && !ctx.has(ctx.vol10y))),
      ctx.chk(`Net Income positiv`, ctx.netIncomePos === true, ctx.netIncomePos === null),
      ctx.chk(`Operating Margin > 0`, ctx.opt(ctx.opm1y, v => v > 0), !ctx.has(ctx.opm1y)),
      ctx.chk(`Profit Margin > 0`, ctx.opt(ctx.pm1y, v => v > 0), !ctx.has(ctx.pm1y)),
      ctx.chk(`OCF > 0`, ctx.opt(ctx.ocf, v => v > 0), !ctx.has(ctx.ocf)),
      ctx.chk(`FCF positiv`, ctx.fcfPos === true, ctx.fcfPos === null),
      ctx.chk(`FCF-Marge > 0`, ctx.opt(ctx.fcfMargin, v => v > 0), !ctx.has(ctx.fcfMargin)),
      ctx.chk(`Interest Coverage > 5`, ctx.opt(ctx.icr, v => v > 5), !ctx.has(ctx.icr)),
      ctx.chk(`Quick ≥ 1 ODER Current ≥ 1.5`, (ctx.opt(ctx.quick, v=>v>=1).ok) || (ctx.opt(ctx.currentRatio, v=>v>=1.5).ok),
        (!ctx.has(ctx.quick) && !ctx.has(ctx.currentRatio))),
      ctx.chk(`Leverage moderat (NDE ≤ 3 & Debt/FCF ≤ 10)`, 
        (ctx.opt(ctx.netDebtEbitda, v=>v<=3).ok) && (ctx.opt(ctx.debtFcf, v=>v<=10).ok),
        (!ctx.has(ctx.netDebtEbitda) && !ctx.has(ctx.debtFcf))),
    ],
    health:(ctx)=>[
      ctx.chk(`OPM Trend (4Y pp) ≥ 0`, ctx.opt(ctx.opmCagr4, v => v >= 0), !ctx.has(ctx.opmCagr4)),
      ctx.chk(`ROIC/ROCE hoch`, (ctx.opt(ctx.roic, v=>v>=12).ok) || (ctx.opt(ctx.roce, v=>v>=12).ok),
        (!ctx.has(ctx.roic) && !ctx.has(ctx.roce))),
      ctx.chk(`Shares Change (YoY) nicht stark positiv`, ctx.opt(ctx.sharesChg, v=>v<=5), !ctx.has(ctx.sharesChg)),
      ctx.chk(`Dividende gedeckt (optional)`, 
        (ctx.opt(ctx.payout, v=>v<=70).ok) && (ctx.opt(ctx.fcfPayout, v=>v<=80).ok),
        (!ctx.has(ctx.payout) && !ctx.has(ctx.fcfPayout))),
    ]
  },

  "Pricing Power": {
    minPct: 0.60,
    base:(ctx)=> {
      const sig = [
        ctx.chk(`Gross Margin solide/hoch`, ctx.opt(ctx.gm1y, v => v >= 40), !ctx.has(ctx.gm1y)),
        ctx.chk(`Operating Margin klar positiv`, ctx.opt(ctx.opm1y, v => v > 0), !ctx.has(ctx.opm1y)),
        ctx.chk(`OPM Trend ≥ 0 (4Y pp CAGR)`, ctx.opt(ctx.opmCagr4, v => v >= 0), !ctx.has(ctx.opmCagr4)),
        ctx.chk(`Profit Margin positiv & Net Income positiv`, (ctx.opt(ctx.pm1y, v=>v>0).ok) && (ctx.netIncomePos === true),
          (!ctx.has(ctx.pm1y) && ctx.netIncomePos===null)),
        ctx.chk(`ROIC/ROCE hoch`, (ctx.opt(ctx.roic, v=>v>=12).ok) || (ctx.opt(ctx.roce, v=>v>=12).ok),
          (!ctx.has(ctx.roic) && !ctx.has(ctx.roce))),
        ctx.chk(`OCF>0 & FCF positiv & FCF-Marge>0`, (ctx.opt(ctx.ocf, v=>v>0).ok) && (ctx.fcfPos===true) && (ctx.opt(ctx.fcfMargin, v=>v>0).ok),
          (!ctx.has(ctx.ocf) && ctx.fcfPos===null && !ctx.has(ctx.fcfMargin))),
      ];
      const sc = scoreChecks(sig);
      return [
        ctx.chk(`Base-Score ≥ 4 (aktuell: ${sc.okCnt}/${sc.knownCnt})`, sc.knownCnt ? sc.okCnt >= 4 : false, sc.knownCnt === 0),
      ];
    },
    health:(ctx)=>[
      // PDF-Health Themen: Margen-Resilienz, Cashflow-Qualität, ROIC/ROCE, Bilanzstress, Risiko, Bewertung
      ctx.chk(`Margen-Resilienz: EBITDA/Profit/Gross positiv & Trend nicht fallend`, 
        (ctx.opt(ctx.ebitdaMargin, v=>v>0).ok) && (ctx.opt(ctx.pm1y, v=>v>0).ok) && (ctx.opt(ctx.gm1y, v=>v>0).ok) && (ctx.opt(ctx.opmCagr4, v=>v>=0).ok),
        (!ctx.has(ctx.ebitdaMargin) && !ctx.has(ctx.pm1y) && !ctx.has(ctx.gm1y) && !ctx.has(ctx.opmCagr4))),
      ctx.chk(`Bilanzstress niedrig: ICR hoch + Leverage moderat`, 
        (ctx.opt(ctx.icr, v=>v>3).ok) && (ctx.opt(ctx.netDebtEbitda, v=>v<=3).ok),
        (!ctx.has(ctx.icr) && !ctx.has(ctx.netDebtEbitda))),
    ]
  },



  "Recurring Revenue / Abo Modell": {
    minPct: 0.55,
    base:(ctx)=> {
      const sig = [
        ctx.chk(`Revenue 4Y CAGR > 0 & Revenue YoY > 0`, (ctx.opt(ctx.revCagr4, v=>v>0).ok) && (ctx.opt(ctx.revYoy, v=>v>0).ok),
          (!ctx.has(ctx.revCagr4) && !ctx.has(ctx.revYoy))),
        ctx.chk(`Gross Margin hoch/robust`, ctx.opt(ctx.gm1y, v=>v>=40), !ctx.has(ctx.gm1y)),
        ctx.chk(`OPM Trend ≥ 0 (4Y pp CAGR)`, ctx.opt(ctx.opmCagr4, v=>v>=0), !ctx.has(ctx.opmCagr4)),
        ctx.chk(`OCF > 0`, ctx.opt(ctx.ocf, v=>v>0), !ctx.has(ctx.ocf)),
        ctx.chk(`FCF positiv ODER FCF Conversion solide`, (ctx.fcfPos===true) || (ctx.opt(ctx.fcfConv, v=>v>=0.6).ok),
          (ctx.fcfPos===null && !ctx.has(ctx.fcfConv))),
        ctx.chk(`CapEx moderat ggü. OCF (Proxy)`, (ctx.has(ctx.capex) && ctx.has(ctx.ocf)) ? (Math.abs(ctx.capex) <= 0.6*Math.abs(ctx.ocf)) : true,
          (!ctx.has(ctx.capex) || !ctx.has(ctx.ocf))),
      ];
      const sc = scoreChecks(sig);
      return [
        ctx.chk(`Base-Score ≥ 4 (aktuell: ${sc.okCnt}/${sc.knownCnt})`, sc.knownCnt ? sc.okCnt >= 4 : false, sc.knownCnt === 0),
      ];
    },
    health:(ctx)=> {
      const h = [
        ctx.chk(`FCF positiv & FCF-Marge > 0`, (ctx.fcfPos===true) && ctx.opt(ctx.fcfMargin, v=>v>0).ok, (ctx.fcfPos===null && !ctx.has(ctx.fcfMargin))),
        ctx.chk(`Net Income positiv`, ctx.netIncomePos===true, ctx.netIncomePos===null),
        ctx.chk(`ROIC/ROCE ordentlich`, (ctx.opt(ctx.roic, v=>v>=10).ok) || (ctx.opt(ctx.roce, v=>v>=10).ok),
          (!ctx.has(ctx.roic) && !ctx.has(ctx.roce))),
        ctx.chk(`Interest Coverage > 3 (besser > 5)`, ctx.opt(ctx.icr, v=>v>3), !ctx.has(ctx.icr)),
        ctx.chk(`Leverage moderat + Quick/Current ok`, 
         (ctx.opt(ctx.netDebtEbitda, v=>v<=3).ok) && ((ctx.opt(ctx.quick, v=>v>=1).ok) || (ctx.opt(ctx.currentRatio, v=>v>=1.2).ok)),
         (!ctx.has(ctx.netDebtEbitda) && !ctx.has(ctx.quick) && !ctx.has(ctx.currentRatio))),
        ctx.chk(`Vol 5Y/10Y moderat (Proxy ≤ 35%)`, 
          (ctx.opt(ctx.vol5y, v=>v<=35).ok) || (ctx.opt(ctx.vol10y, v=>v<=35).ok),
          (!ctx.has(ctx.vol5y) && !ctx.has(ctx.vol10y))),
      ];
      const sc = scoreChecks(h);
      return [
        ...h,
        ctx.chk(`Health-Score ≥ 4 (aktuell: ${sc.okCnt}/${sc.knownCnt})`, sc.knownCnt ? sc.okCnt >= 4 : true, sc.knownCnt === 0),
      ];
    }
  },


  "Balance Sheet Strong": {
    minPct: 0.60,
    base:(ctx)=>[
      // Block 1: Liquidität
      ctx.chk(`Quick ≥ 1.0`, ctx.opt(ctx.quick, v=>v>=1.0), !ctx.has(ctx.quick)),
      ctx.chk(`Current ≥ 1.5 (oder mind. ≥ 1.2 ok)`, ctx.opt(ctx.currentRatio, v=>v>=1.2), !ctx.has(ctx.currentRatio)),
      ctx.chk(`Cash-Puffer sichtbar (Cash > 0)`, ctx.opt(ctx.cash, v=>v>0), !ctx.has(ctx.cash)),

      // Block 2: Zinsdienst
      ctx.chk(`ICR ≥ 5 (≥3 ok)`, ctx.opt(ctx.icr, v=>v>=3), !ctx.has(ctx.icr)),

      // Block 3: moderate Verschuldung
      ctx.chk(`NetDebt/EBITDA ≤ 3 (≤2 stark)`, ctx.opt(ctx.netDebtEbitda, v=>v<=3), !ctx.has(ctx.netDebtEbitda)),
      ctx.chk(`Debt/FCF nicht hoch (Warnsignal bei neg. FCF)`, (ctx.fcfPos===false) ? false : ctx.opt(ctx.debtFcf, v=>v<10),
        (ctx.fcfPos===null && !ctx.has(ctx.debtFcf))),

      // Block 4: Cashflow stützt Bilanz
      ctx.chk(`OCF > 0`, ctx.opt(ctx.ocf, v=>v>0), !ctx.has(ctx.ocf)),
      ctx.chk(`FCF positiv (oder FCF ≥ 0)`, (ctx.fcfPos===true) || ctx.opt(ctx.fcf, v=>v>=0), (ctx.fcfPos===null && !ctx.has(ctx.fcf))),
      ctx.chk(`FCF Conversion solide`, ctx.opt(ctx.fcfConv, v=>v>=0.6), !ctx.has(ctx.fcfConv)),
    ],
    health:(ctx)=>[
      ctx.chk(`Streng: Quick≥1.2 & Current≥1.5`, (ctx.opt(ctx.quick, v=>v>=1.2).ok) && (ctx.opt(ctx.currentRatio, v=>v>=1.5).ok),
        (!ctx.has(ctx.quick) && !ctx.has(ctx.currentRatio))),
      ctx.chk(`Streng: ICR ≥ 5`, ctx.opt(ctx.icr, v=>v>=5), !ctx.has(ctx.icr)),
      ctx.chk(`Streng: NetDebt/EBITDA ≤ 2`, ctx.opt(ctx.netDebtEbitda, v=>v<=2), !ctx.has(ctx.netDebtEbitda)),
    ]
  },

  "Leveraged / Schuldenlastig": {
    minPct: 0.50,
    base:(ctx)=>[
      ctx.chk(
        `Leveraged-Trigger (NDE≥3 ODER Debt/FCF≥10 ODER ICR≤3 ODER (FCF negativ + Schulden))`,
        (ctx.opt(ctx.netDebtEbitda, v=>v>=3).ok) ||
        (ctx.opt(ctx.debtFcf, v=>v>=10).ok) ||
        (ctx.opt(ctx.icr, v=>v<=3).ok) ||
        ((ctx.fcfPos===false) && (ctx.has(ctx.netDebtEbitda) ? ctx.netDebtEbitda>0 : true)),
        (!ctx.has(ctx.netDebtEbitda) && !ctx.has(ctx.debtFcf) && !ctx.has(ctx.icr) && ctx.fcfPos===null)
      ),
    ],
    health:(ctx)=>[
      ctx.chk(`Managebar: ICR>3 & OCF>0 & FCFPos=Ja & Quick≥1`, 
        (ctx.opt(ctx.icr, v=>v>3).ok) && (ctx.opt(ctx.ocf, v=>v>0).ok) && (ctx.fcfPos===true) && (ctx.opt(ctx.quick, v=>v>=1).ok),
        (!ctx.has(ctx.icr) && !ctx.has(ctx.ocf) && ctx.fcfPos===null && !ctx.has(ctx.quick))),
      ctx.chk(`Riskant: ICR≤2 ODER FCF negativ ODER Quick/Current<1 ODER NDE≥5`,
        (ctx.opt(ctx.icr, v=>v<=2).ok) || (ctx.fcfPos===false) || (ctx.opt(ctx.quick, v=>v<1).ok) || (ctx.opt(ctx.currentRatio, v=>v<1).ok) || (ctx.opt(ctx.netDebtEbitda, v=>v>=5).ok),
        false),
      ctx.chk(`Krisennah: ICR<1 ODER OCF≤0 + hohe Leverage`, 
        (ctx.opt(ctx.icr, v=>v<1).ok) || ((ctx.opt(ctx.ocf, v=>v<=0).ok) && ((ctx.opt(ctx.netDebtEbitda, v=>v>=5).ok)||(ctx.opt(ctx.debtFcf, v=>v>=15).ok))),
        false),
    ]
  },

  // Market-Cap Größen (gängige Schwellen; du kannst sie jederzeit ändern)  [oai_citation:1‡Wikipedia](https://en.wikipedia.org/wiki/Market_capitalization?utm_source=chatgpt.com)
  "Small Cap": { minPct:0.0, base:(ctx)=>[ctx.chk(`MCap 300M–2B`, ctx.has(ctx.mcap)&&ctx.mcap>=3e8&&ctx.mcap<2e9, !ctx.has(ctx.mcap))], health:()=>[] },
  "Mid Cap":   { minPct:0.0, base:(ctx)=>[ctx.chk(`MCap 2B–10B`,  ctx.has(ctx.mcap)&&ctx.mcap>=2e9&&ctx.mcap<1e10, !ctx.has(ctx.mcap))], health:()=>[] },
  "Large Cap": { minPct:0.0, base:(ctx)=>[ctx.chk(`MCap 10B–200B`,ctx.has(ctx.mcap)&&ctx.mcap>=1e10&&ctx.mcap<2e11, !ctx.has(ctx.mcap))], health:()=>[] },
  "Mega Cap":  { minPct:0.0, base:(ctx)=>[ctx.chk(`MCap ≥ 200B`,  ctx.has(ctx.mcap)&&ctx.mcap>=2e11, !ctx.has(ctx.mcap))], health:()=>[] },
};







  /* =========================
     E) Auswertung über Catalog
     ========================= */
  const out = {};

  for(const rawRole of (NUTZEN_ROLE_CATALOG || [])){
    const role = normalizeNutzenRoleName(rawRole);
    if(!role) continue;

    const rule = ROLE_RULES[role];
    if(!rule){
      // wenn im Katalog aber keine Rule definiert:
      out[role] = { state:"off", why:["… noch keine Regeln definiert"] };
      continue;
    }

    const baseChecks = typeof rule.base === "function" ? rule.base(ctx) : [];
    const healthChecks = typeof rule.health === "function" ? rule.health(ctx) : [];
    const min = Number.isFinite(rule.minPct) ? rule.minPct : 0.60;

    setRole(out, role, baseChecks, healthChecks, min);
  }

  // Safety: falls normalize names Rollen erzeugt, die nicht im Catalog sind
  for(const r of (NUTZEN_ROLE_CATALOG || [])){
    const rr = normalizeNutzenRoleName(r);
    if(rr && !out[rr]) out[rr] = { state:"off", why:["… noch keine Regeln"] };
  }

  return out;
}









/* =========================
   STRESS MODULE
   ========================= */

// optional: nur Alias, damit überall der gleiche Name genutzt wird
function computeStressFlag(m){
  return nutzenComputeStress(m);
}




function nutzenEvaluateAll(){
  const m = nutzenGetTableMap();
  const fair = nutzenComputeFairPrice(m);
  const stress = computeStressFlag(m);
  const roles = nutzenComputeRoles(m);
  const actions = nutzenComputeActions(m, fair);

  return { map:m, fair, stress, roles, actions };
}








/* =========================================
   3) UI: Render using REAL evaluation
   ========================================= */

function nutzenApplyAutoToUI(ev){
  // Fairer Preis in Tabelle zurückschreiben, falls leer/NaN und wir etwas berechnen konnten
  if(Number.isFinite(ev.fair)){
    // schreibe nur, wenn Zelle leer ist
    const valRow = document.getElementById("nutzenValueRow");
    if(valRow){
      const cells = Array.from(valRow.querySelectorAll("td"));
      const idxFair = NUTZEN_HEADERS.indexOf("Fairer Preis");
      if(idxFair >= 0 && cells[idxFair]){
        if(!nzStr(cells[idxFair].textContent)) cells[idxFair].textContent = ev.fair.toFixed(2);
      }
    }
  }

  // Stress nur setzen, wenn auf "auto" (nicht manuell überschreiben)
  const selMain = document.getElementById("nutzenStressSelect");
  const selOv   = document.getElementById("nutzenOverlayStressSelect");
  const isAutoMain = !selMain || selMain.value === "auto";
  const isAutoOv   = !selOv   || selOv.value   === "auto";


  if(isAutoMain || isAutoOv){
    const mode = ev.stress.mode; // green/yellow/red
    nutzenSyncStress(mode);

    const whyTxt = ev.stress.triggers.length
      ? ("Auto-Trigger: " + ev.stress.triggers.join(" | "))
      : "Auto: keine Stress-Trigger erkannt.";
    const whyMain = document.getElementById("nutzenStressWhy");
    const whyOv   = document.getElementById("nutzenOverlayStressWhy");
    if(whyMain) whyMain.textContent = whyTxt;
    if(whyOv)   whyOv.textContent   = whyTxt;
  }

  // Overlay Actions Felder automatisch füllen (wenn leer)
  const fp = ovGetEl("ov_fairPrice");
if(fp && !fp.dataset.manual && !nzStr(fp.value) && Number.isFinite(ev.fair)){
  fp.value = ev.fair.toFixed(2);
}
  const cp = ovGetEl("ov_currentPrice");
  const buy = ovGetEl("ov_buySelect");
  const add = ovGetEl("ov_addSelect");

  if(fp && !nzStr(fp.value) && Number.isFinite(ev.fair)) fp.value = ev.fair.toFixed(2);

const currentPrice = nzNum(ev.map["Kurs aktuell"]);
if(cp && !nzStr(cp.value) && Number.isFinite(currentPrice)) cp.value = currentPrice.toFixed(2);

if(buy) buy.value = ev.actions.buy || "auto";
if(add) add.value = ev.actions.add || "auto";

  ovRenderActionsSummary();



   }



function renderNutzenRolesBox(){
  const host = document.getElementById("nutzen_roles");
  if(!host) return;

  const ev = nutzenEvaluateAll();
  const statusMap = ev.roles;

  host.innerHTML = `
    <div class="out" style="margin-top:12px">
      <div class="kpi">
        <span><b>Rollen</b></span>
        <span class="small">Auto aus Kennzahlen</span>
      </div>

      <div class="roleGrid">
${NUTZEN_ROLE_CATALOG.map(roleRaw => {
  const role = normalizeNutzenRoleName(roleRaw) || roleRaw;
  const st = statusMap[role]?.state || "unknown";
  const why = statusMap[role]?.why || [];
          const whyHtml = (why.length)
            ? `<ul class="roleChecks">${why.map(x => `<li class="muted">${String(x).replace(/</g,"&lt;").replace(/>/g,"&gt;")}</li>`).join("")}</ul>`
            : `<div class="roleMeta">–</div>`;

          return `
            <details class="roleDetails">
              <summary>
                <span class="sumRow">
                  <span>${role}</span>
                  ${roleBadgeHtml(st)}
                </span>
              </summary>
              ${whyHtml}
            </details>
          `;
        }).join("")}
      </div>
    </div>
  `;
      

  // nach Render: Auto-UI anwenden (Stress/Fair/Actions)
  nutzenApplyAutoToUI(ev);
}




function nutzenOverlayFillRoles(){
  const box = document.getElementById("nutzenOverlayRoles");
  const why = document.getElementById("nutzenOverlayRolesWhy");
  if(!box) return;

  const ev = nutzenEvaluateAll();
  const statusMap = ev.roles || {};

  // Chips
  box.innerHTML = NUTZEN_ROLE_CATALOG.map(roleRaw => {
    const key  = normalizeNutzenRoleName(roleRaw) || roleRaw;
    const st   = statusMap[key]?.state || "unknown";
    const on   = (st === "on");
    const off  = !on;
    const icon = on ? "✅" : (st === "warn" ? "⚠️" : "…");
    return `<span class="roleChip ${off ? "off" : ""}">${icon} ${key}</span>`;
  }).join("");

  // Begründung
  if(why){
    const lines = [];

    // 1) Base/Health (wenn vorhanden)
    for(const roleRaw of NUTZEN_ROLE_CATALOG){
      const key = normalizeNutzenRoleName(roleRaw) || roleRaw;
      const r = statusMap[key];
      if(!r?.why?.length) continue;
      if(r.state === "off") continue;
      lines.push(`• ${key}: ${r.why[0]}`); // Header "BASE... | HEALTH..."
    }

    // 2) Fallback wie bei dir: Stress Status
    if(lines.length === 0){
      const t = ev.stress?.triggers?.length ? ev.stress.triggers.join(" | ") : "Keine Stress-Trigger.";
      why.textContent = `Auto-Status. Stress: ${(ev.stress?.mode || "–").toUpperCase()} (${t})`;
    } else {
      why.textContent = lines.join("\n");
    }
  }

  nutzenApplyAutoToUI(ev);
}





/* =========================================
   4) Overlay open: use real fills
   ========================================= */

function openNutzenOverlay(){

  bindOverlayActionsUI();

  const ov = document.getElementById("nutzenOverlay");
  const bd = document.getElementById("nutzenOverlayBackdrop");
  if(!ov) return;

  ov.classList.add("isOpen");
  ov.setAttribute("aria-hidden","false");
  ov.style.display = "flex";
  if(bd) bd.style.display = "block";

  const ev = nutzenEvaluateAll();

  const fp = ovGetEl("ov_fairPrice");
  const cp = ovGetEl("ov_currentPrice"); 



  // 1) Auto-Werte in UI (fair, kurs, stress mode, buy/add etc.)
  if(typeof nutzenApplyAutoToUI === "function"){
    nutzenApplyAutoToUI(ev);
  }

  // 2) Fallback: falls du noch alte Füllfunktionen hast
  if(typeof nutzenOverlayFillRoles === "function"){
    try { nutzenOverlayFillRoles(ev); } catch(e) {}
  }
  if(typeof nutzenOverlayFillRangeBase === "function"){
    try { nutzenOverlayFillRangeBase(ev); } catch(e) {}
  }
}



// ===== Phase 7: Overlay-Glue (robust & einheitlich) =====

function ovGetEl(id){
  return document.getElementById(id);
}

function ovIsOpen(){
  const ov = ovGetEl("nutzenOverlay");
  if(!ov) return false;
  return ov.classList.contains("isOpen") || ov.getAttribute("aria-hidden") === "false" || ov.style.display === "flex";
}



function closeNutzenOverlay(){
  const ov = ovGetEl("nutzenOverlay");
  const bd = ovGetEl("nutzenOverlayBackdrop");
  if(!ov) return;

  ov.classList.remove("isOpen");
  ov.setAttribute("aria-hidden", "true");
  ov.style.display = "none";
  if(bd) bd.style.display = "none";
}





/* =========================================
   5) Guard: prevent double-binding Overlay/Actions
   ========================================= */

let _nutzenOverlayBound = false;



function bindNutzenOverlayUI(){
  // 1) Globaler Guard (nur 1x)
  if(window._nutzenOverlayBound) return;
  window._nutzenOverlayBound = true;

  const btnOpen   = document.getElementById("nutzen_overlayBtn");
  const btnClose  = document.getElementById("nutzenOverlayCloseBtn");
  const backdrop  = document.getElementById("nutzenOverlayBackdrop");
  const selStress = document.getElementById("nutzenOverlayStressSelect");

  // 2) Pro-Element Guard via dataset.bound
  if(btnOpen && !btnOpen.dataset.bound){
    btnOpen.dataset.bound = "1";
    btnOpen.addEventListener("click", openNutzenOverlay);
  }

  if(btnClose && !btnClose.dataset.bound){
    btnClose.dataset.bound = "1";
    btnClose.addEventListener("click", closeNutzenOverlay);
  }

  if(backdrop && !backdrop.dataset.bound){
    backdrop.dataset.bound = "1";
    backdrop.addEventListener("click", closeNutzenOverlay);
  }

  // 3) ESC schließt – nur 1x binden
  if(!document.body.dataset.nutzenEscBound){
    document.body.dataset.nutzenEscBound = "1";
    document.addEventListener("keydown", (e) => {
      if(e.key !== "Escape") return;

      const ov = document.getElementById("nutzenOverlay");
      if(!ov) return;

      const isOpen =
        ov.classList.contains("isOpen") ||
        ov.getAttribute("aria-hidden") === "false" ||
        ov.style.display === "flex";

      if(isOpen) closeNutzenOverlay();
    });
  }

  // 4) Stress-Select im Overlay (manuell/auto)
  // Pro-Element Guard, damit kein doppeltes "change" entsteht
  if(selStress && !selStress.dataset.bound){
    selStress.dataset.bound = "1";
    selStress.addEventListener("change", () => {
      const v = selStress.value;

      // Zurück auf "auto" => neu berechnen und anwenden
      const ev = nutzenEvaluateAll();
      nutzenSyncStress(ev.stress.mode);

      const whyTxt = ev.stress.triggers.length
        ? ("Auto-Trigger: " + ev.stress.triggers.join(" | "))
        : "Auto: keine Stress-Trigger erkannt.";

      const whyOv   = document.getElementById("nutzenOverlayStressWhy");
      const whyMain = document.getElementById("nutzenStressWhy");
      if(whyOv)   whyOv.textContent   = whyTxt;
      if(whyMain) whyMain.textContent = whyTxt;

      function bindNutzenOverlayUI(){
  // ... dein bisheriger Code (Buttons, Backdrop, Stress-Select etc.)

  // ✅ HIER EINFÜGEN (am Ende der Funktion, vor der letzten })
  if(!document.body.dataset.nutzenSpaceCloseBound){
    document.body.dataset.nutzenSpaceCloseBound = "1";

    document.addEventListener("keydown", (e) => {
      if(e.code !== "Space") return;

      const ov = document.getElementById("nutzenOverlay");
      if(!ov) return;

      const isOpen =
        ov.classList.contains("isOpen") ||
        ov.getAttribute("aria-hidden") === "false" ||
        ov.style.display === "flex";

      if(!isOpen) return;

      e.preventDefault();
      closeNutzenOverlay();
    });
  }
}


    });
  }
}



const btnOpen   = document.getElementById("nutzen_overlayBtn");
const btnClose  = document.getElementById("nutzenOverlayCloseBtn");
const backdrop  = document.getElementById("nutzenOverlayBackdrop");
const selStress = document.getElementById("nutzenOverlayStressSelect");


let _actionsBound = false;

function bindOverlayActionsUI(){
  if(window._actionsBound) return;
  window._actionsBound = true;

  const fp = ovGetEl("ov_fairPrice");
  const cp = ovGetEl("ov_currentPrice");
  const clearBtn = ovGetEl("ov_clearActions");


  if(fp){
    fp.addEventListener("input", () => {
      fp.dataset.manual = "1";          // ✅ merken: User hat Fair manuell gesetzt
      ovRenderActionsSummary();
      nutzenOverlayFillRangeBase();     // ✅ Ranges neu berechnen
    });
  }

  if(cp){
    cp.addEventListener("input", () => {
      cp.dataset.manual = "1";          // optional
      ovRenderActionsSummary();
      nutzenOverlayFillRangeBase();     // optional, aber sinnvoll
    });
  }

  if(clearBtn){
    clearBtn.addEventListener("click", () => {
      if(fp){ fp.value = ""; delete fp.dataset.manual; }
      if(cp){ cp.value = ""; delete cp.dataset.manual; }
      ovRenderActionsSummary();
      nutzenOverlayFillRangeBase();     // ✅ zurück auf Auto-Ranges
    });
  }

  ovRenderActionsSummary();
}



let _nutzenAutoRerenderBound = false;

function bindNutzenAutoRerender(){
  if(_nutzenAutoRerenderBound) return;
  _nutzenAutoRerenderBound = true;

  const valRow = document.getElementById("nutzenValueRow");
  if(!valRow) return;

  // Wenn du in Zellen tippst (contenteditable), kommt "input" zuverlässig
  valRow.addEventListener("input", () => {
    renderNutzenRolesBox();        // <- recalcs roles + nutztApplyAutoToUI(ev)
  });

  // Falls jemand nur klickt/verlässt (manchmal bei contenteditable nötig)
  valRow.addEventListener("blur", () => {
    renderNutzenRolesBox();
  }, true);
}



document.addEventListener("DOMContentLoaded", () => {
  bindNutzenUI();
});



function bindNutzenStressUI(){
  const selMain = document.getElementById("nutzenStressSelect");
  const selOv   = document.getElementById("nutzenOverlayStressSelect");
  if(selMain) selMain.disabled = true;
  if(selOv)   selOv.disabled   = true;

  // Startwert (falls du direkt was zeigen willst)
  // Wenn du später aus der Berechnung setzt, kannst du das auch weglassen.
  nutzenSyncStress("green", "Initial gesetzt (später aus Berechnung).");
}




window.debugNutzenStress = function(){
  try{
    const ev = nutzenEvaluateAll();
    console.log("EV.STRESS", ev.stress);
    console.log("EV.MAP", ev.map);

    // wichtige Inputs (roh + geparsed)
    const m = ev.map || {};
    const get = (k)=> nzGet(m,k);

    console.log("INPUTS RAW", {
      quick: get("Quick Ratio 1Y"),
      current: get("Current Ratio 1Y"),
      icr: get("Zinsdeckung 1Y (Interest Coverage)"),
      nde: get("Net Debt / EBITDA Ratio 1Y"),
      dcf: get("Debt / FCF Ratio 1Y"),
      fcf: get("FCF 1Y"),
      fcfPos: get("FCF positiv (Ja/Nein)"),
      ocf: get("Operating Cash Flow 1Y"),
      vol1y: get("Volatilität annualisiert (Std-Abw.) 1Y"),
      volPack: get("Volatilität annualisiert (Std-Abw.) 1Y/5Y/10Y"),
      range: get("52-Week Range"),
      price: get("Kurs aktuell"),
      shares: get("Shares Change (YoY)")
    });

    return ev;
  }catch(e){
    console.error("debugNutzenStress ERROR", e);
    return null;
  }
};



</script>
</body>
</html>
